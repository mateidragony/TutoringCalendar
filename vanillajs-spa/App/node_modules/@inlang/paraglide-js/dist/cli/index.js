var _a, _b;
import { Command } from "commander";
import { p as pattern, b as assertValidProjectPath, c as getDefaultExportFromCjs, g as getDirname, a as getBasename, d as parseOrigin, t as transformRemote, e as commonjsGlobal, f as getAugmentedNamespace, h as parseLixUri, w as withProxy, compile, writeOutput, Logger, l as loadProject, classifyProjectErrors, i as typebox, n as normalizePath$2, v as value, j as telemetry, k as pathExists$1, m as findPackageJson } from "../index.js";
import dedent from "dedent";
import nodeFsPromises from "node:fs/promises";
import * as nodePath from "node:path";
import nodePath__default, { resolve } from "node:path";
import require$$0$1 from "buffer";
import consola from "consola";
import childProcess from "node:child_process";
import JSON5 from "json5";
import { detectJsonFormatting } from "@inlang/detect-json-formatting";
import "tty";
import "util";
import "os";
import "posthog-node";
import "node:crypto";
import "consola/utils";
const isValidLanguageTag = (languageTag) => RegExp(`${pattern}`).test(languageTag);
const defaultProjectSettings = {
  $schema: "https://inlang.com/schema/project-settings",
  sourceLanguageTag: "en",
  languageTags: ["en"],
  modules: [
    // for instant gratification, we're adding common rules
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@latest/dist/index.js",
    // default to the message format plugin because it supports all features
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@latest/dist/index.js",
    // the m function matcher should be installed by default in case Sherlock (VS Code extension) is adopted
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@latest/dist/index.js"
  ],
  "plugin.inlang.messageFormat": {
    pathPattern: "./messages/{languageTag}.json"
  }
};
async function createNewProject(args) {
  assertValidProjectPath(args.projectPath);
  const nodeishFs = args.repo.nodeishFs;
  if (await directoryExists(args.projectPath, nodeishFs)) {
    throw new Error(`projectPath already exists, received "${args.projectPath}"`);
  }
  const settingsText = JSON.stringify(args.projectSettings ?? defaultProjectSettings, void 0, 2);
  await nodeishFs.mkdir(args.projectPath, { recursive: true });
  await Promise.all([
    nodeishFs.writeFile(`${args.projectPath}/settings.json`, settingsText),
    nodeishFs.writeFile(`${args.projectPath}/.gitignore`, "cache"),
    nodeishFs.mkdir(`${args.projectPath}/cache/modules`, { recursive: true })
  ]);
}
async function directoryExists(filePath, nodeishFs) {
  try {
    const stat = await nodeishFs.stat(filePath);
    return stat.isDirectory();
  } catch (error) {
    if (error && "code" in error && error.code === "ENOENT") {
      return false;
    } else {
      throw new Error(`Failed to check if path exists: ${error}`, { cause: error });
    }
  }
}
var AsyncLock$1 = function(opts) {
  opts = opts || {};
  this.Promise = opts.Promise || Promise;
  this.queues = /* @__PURE__ */ Object.create(null);
  this.domainReentrant = opts.domainReentrant || false;
  if (this.domainReentrant) {
    if (typeof process === "undefined" || typeof process.domain === "undefined") {
      throw new Error(
        "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
      );
    }
    this.domains = /* @__PURE__ */ Object.create(null);
  }
  this.timeout = opts.timeout || AsyncLock$1.DEFAULT_TIMEOUT;
  this.maxOccupationTime = opts.maxOccupationTime || AsyncLock$1.DEFAULT_MAX_OCCUPATION_TIME;
  this.maxExecutionTime = opts.maxExecutionTime || AsyncLock$1.DEFAULT_MAX_EXECUTION_TIME;
  if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {
    this.maxPending = opts.maxPending;
  } else {
    this.maxPending = AsyncLock$1.DEFAULT_MAX_PENDING;
  }
};
AsyncLock$1.DEFAULT_TIMEOUT = 0;
AsyncLock$1.DEFAULT_MAX_OCCUPATION_TIME = 0;
AsyncLock$1.DEFAULT_MAX_EXECUTION_TIME = 0;
AsyncLock$1.DEFAULT_MAX_PENDING = 1e3;
AsyncLock$1.prototype.acquire = function(key, fn, cb, opts) {
  if (Array.isArray(key)) {
    return this._acquireBatch(key, fn, cb, opts);
  }
  if (typeof fn !== "function") {
    throw new Error("You must pass a function to execute");
  }
  var deferredResolve = null;
  var deferredReject = null;
  var deferred = null;
  if (typeof cb !== "function") {
    opts = cb;
    cb = null;
    deferred = new this.Promise(function(resolve2, reject) {
      deferredResolve = resolve2;
      deferredReject = reject;
    });
  }
  opts = opts || {};
  var resolved = false;
  var timer = null;
  var occupationTimer = null;
  var executionTimer = null;
  var self2 = this;
  var done = function(locked, err2, ret) {
    if (occupationTimer) {
      clearTimeout(occupationTimer);
      occupationTimer = null;
    }
    if (executionTimer) {
      clearTimeout(executionTimer);
      executionTimer = null;
    }
    if (locked) {
      if (!!self2.queues[key] && self2.queues[key].length === 0) {
        delete self2.queues[key];
      }
      if (self2.domainReentrant) {
        delete self2.domains[key];
      }
    }
    if (!resolved) {
      if (!deferred) {
        if (typeof cb === "function") {
          cb(err2, ret);
        }
      } else {
        if (err2) {
          deferredReject(err2);
        } else {
          deferredResolve(ret);
        }
      }
      resolved = true;
    }
    if (locked) {
      if (!!self2.queues[key] && self2.queues[key].length > 0) {
        self2.queues[key].shift()();
      }
    }
  };
  var exec = function(locked) {
    if (resolved) {
      return done(locked);
    }
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    if (self2.domainReentrant && locked) {
      self2.domains[key] = process.domain;
    }
    var maxExecutionTime = opts.maxExecutionTime || self2.maxExecutionTime;
    if (maxExecutionTime) {
      executionTimer = setTimeout(function() {
        if (!!self2.queues[key]) {
          done(locked, new Error("Maximum execution time is exceeded " + key));
        }
      }, maxExecutionTime);
    }
    if (fn.length === 1) {
      var called = false;
      try {
        fn(function(err2, ret) {
          if (!called) {
            called = true;
            done(locked, err2, ret);
          }
        });
      } catch (err2) {
        if (!called) {
          called = true;
          done(locked, err2);
        }
      }
    } else {
      self2._promiseTry(function() {
        return fn();
      }).then(function(ret) {
        done(locked, void 0, ret);
      }, function(error) {
        done(locked, error);
      });
    }
  };
  if (self2.domainReentrant && !!process.domain) {
    exec = process.domain.bind(exec);
  }
  var maxPending = opts.maxPending || self2.maxPending;
  if (!self2.queues[key]) {
    self2.queues[key] = [];
    exec(true);
  } else if (self2.domainReentrant && !!process.domain && process.domain === self2.domains[key]) {
    exec(false);
  } else if (self2.queues[key].length >= maxPending) {
    done(false, new Error("Too many pending tasks in queue " + key));
  } else {
    var taskFn = function() {
      exec(true);
    };
    if (opts.skipQueue) {
      self2.queues[key].unshift(taskFn);
    } else {
      self2.queues[key].push(taskFn);
    }
    var timeout = opts.timeout || self2.timeout;
    if (timeout) {
      timer = setTimeout(function() {
        timer = null;
        done(false, new Error("async-lock timed out in queue " + key));
      }, timeout);
    }
  }
  var maxOccupationTime = opts.maxOccupationTime || self2.maxOccupationTime;
  if (maxOccupationTime) {
    occupationTimer = setTimeout(function() {
      if (!!self2.queues[key]) {
        done(false, new Error("Maximum occupation time is exceeded in queue " + key));
      }
    }, maxOccupationTime);
  }
  if (deferred) {
    return deferred;
  }
};
AsyncLock$1.prototype._acquireBatch = function(keys, fn, cb, opts) {
  if (typeof cb !== "function") {
    opts = cb;
    cb = null;
  }
  var self2 = this;
  var getFn = function(key, fn2) {
    return function(cb2) {
      self2.acquire(key, fn2, cb2, opts);
    };
  };
  var fnx = keys.reduceRight(function(prev, key) {
    return getFn(key, prev);
  }, fn);
  if (typeof cb === "function") {
    fnx(cb);
  } else {
    return new this.Promise(function(resolve2, reject) {
      if (fnx.length === 1) {
        fnx(function(err2, ret) {
          if (err2) {
            reject(err2);
          } else {
            resolve2(ret);
          }
        });
      } else {
        resolve2(fnx());
      }
    });
  }
};
AsyncLock$1.prototype.isBusy = function(key) {
  if (!key) {
    return Object.keys(this.queues).length > 0;
  } else {
    return !!this.queues[key];
  }
};
AsyncLock$1.prototype._promiseTry = function(fn) {
  try {
    return this.Promise.resolve(fn());
  } catch (e) {
    return this.Promise.reject(e);
  }
};
var lib$1 = AsyncLock$1;
var asyncLock = lib$1;
const AsyncLock = /* @__PURE__ */ getDefaultExportFromCjs(asyncLock);
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  var util$1 = require("util");
  if (typeof util$1.inherits !== "function")
    throw "";
  inherits$1.exports = util$1.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}
var inheritsExports = inherits$1.exports;
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer = require$$0$1;
  var Buffer2 = buffer.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var Buffer$2 = safeBufferExports.Buffer;
function Hash$2(blockSize, finalSize) {
  this._block = Buffer$2.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$2.prototype.update = function(data, enc) {
  if (typeof data === "string") {
    enc = enc || "utf8";
    data = Buffer$2.from(data, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;
  for (var offset = 0; offset < length; ) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash$2.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash2 = this._hash();
  return enc ? hash2.toString(enc) : hash2;
};
Hash$2.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash = Hash$2;
var inherits = inheritsExports;
var Hash = hash;
var Buffer$1 = safeBufferExports.Buffer;
var K = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W = new Array(80);
function Sha1() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num2) {
  return num2 << 1 | num2 >>> 31;
}
function rotl5(num2) {
  return num2 << 5 | num2 >>> 27;
}
function rotl30(num2) {
  return num2 << 30 | num2 >>> 2;
}
function ft(s, b, c2, d) {
  if (s === 0)
    return b & c2 | ~b & d;
  if (s === 2)
    return b & c2 | b & d | c2 & d;
  return b ^ c2 ^ d;
}
Sha1.prototype._update = function(M) {
  var W2 = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c2 = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i)
    W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c2, d) + e + W2[j] + K[s] | 0;
    e = d;
    d = c2;
    c2 = rotl30(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H = Buffer$1.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
var sha1 = Sha1;
const Hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha1);
var crc32$4 = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(exports) {
  (function(factory2) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      {
        factory2(exports);
      }
    } else {
      factory2({});
    }
  })(function(CRC32) {
    CRC32.version = "1.2.2";
    function signed_crc_table() {
      var c2 = 0, table = new Array(256);
      for (var n = 0; n != 256; ++n) {
        c2 = n;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        table[n] = c2;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c2 = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0; n != 256; ++n)
        table[n] = T[n];
      for (n = 0; n != 256; ++n) {
        v = T[n];
        for (c2 = 256 + n; c2 < 4096; c2 += 256)
          v = table[c2] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1; n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length; i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (; i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str2, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str2.length, c2 = 0, d = 0; i < L; ) {
        c2 = str2.charCodeAt(i++);
        if (c2 < 128) {
          C = C >>> 8 ^ T0[(C ^ c2) & 255];
        } else if (c2 < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c2 >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
        } else if (c2 >= 55296 && c2 < 57344) {
          c2 = (c2 & 1023) + 64;
          d = str2.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c2 >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c2 & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c2 >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC32.table = T0;
    CRC32.bstr = crc32_bstr;
    CRC32.buf = crc32_buf;
    CRC32.str = crc32_str;
  });
})(crc32$4);
const crc32$3 = /* @__PURE__ */ getDefaultExportFromCjs(crc32$4);
var common$2 = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common$2);
var deflate$5 = {};
var deflate$4 = {};
var trees$1 = {};
var utils$7 = common$2;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value2, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value2 >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c2, tree) {
  send_bits(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res2 = 0;
  do {
    res2 |= code & 1;
    code >>>= 1;
    res2 <<= 1;
  } while (--len > 0);
  return res2 >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  utils$7.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last2) {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n] = c2;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t = crcTable, end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$6 = common$2;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg$2 = messages;
var Z_NO_FLUSH$1 = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$2 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$2 = 0;
var Z_STREAM_END$2 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION$1 = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY$1 = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$2 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg$2[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$6.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last2) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$6.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str2;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$6.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str2 = s.strstart - s.insert;
      s.ins_h = s.window[str2];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str2 + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str2 + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$1) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$6.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$6.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$6.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$6.Buf16(MAX_BITS + 1);
  this.heap = new utils$6.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$6.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$1;
  trees._tr_init(s);
  return Z_OK$2;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$2) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$2;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils$6.Buf8(s.w_size * 2);
  s.head = new utils$6.Buf16(s.hash_size);
  s.prev = new utils$6.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$6.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
}
function deflate$3(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$2) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$2;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$2) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$2;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$2;
      }
    }
  }
  if (flush !== Z_FINISH$2) {
    return Z_OK$2;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$2;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
}
function deflateEnd(strm) {
  var status2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status2 = strm.state.status;
  if (status2 !== INIT_STATE && status2 !== EXTRA_STATE && status2 !== NAME_STATE && status2 !== COMMENT_STATE && status2 !== HCRC_STATE && status2 !== BUSY_STATE && status2 !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status2 === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$2;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str2, n;
  var wrap;
  var avail;
  var next2;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s = strm.state;
  wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$6.Buf8(s.w_size);
    utils$6.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next2 = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str2 = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str2 + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str2 & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str2;
      str2++;
    } while (--n);
    s.strstart = str2;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$2;
}
deflate$4.deflateInit = deflateInit;
deflate$4.deflateInit2 = deflateInit2;
deflate$4.deflateReset = deflateReset;
deflate$4.deflateResetKeep = deflateResetKeep;
deflate$4.deflateSetHeader = deflateSetHeader;
deflate$4.deflate = deflate$3;
deflate$4.deflateEnd = deflateEnd;
deflate$4.deflateSetDictionary = deflateSetDictionary;
deflate$4.deflateInfo = "pako deflate (from Nodeca project)";
var strings$2 = {};
var utils$5 = common$2;
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new utils$5.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
strings$2.string2buf = function(str2) {
  var buf, c2, c22, m_pos, i, str_len = str2.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str2.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str2.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$5.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str2.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str2.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring(buf, len) {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils$5.shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$2.buf2binstring = function(buf) {
  return buf2binstring(buf, buf.length);
};
strings$2.binstring2buf = function(str2) {
  var buf = new utils$5.Buf8(str2.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str2.charCodeAt(i);
  }
  return buf;
};
strings$2.buf2string = function(buf, max) {
  var i, out, c2, c_len;
  var len = max || buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
strings$2.utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream$2;
var zlib_deflate = deflate$4;
var utils$4 = common$2;
var strings$1 = strings$2;
var msg$1 = messages;
var ZStream$1 = zstream;
var toString$2 = Object.prototype.toString;
var Z_NO_FLUSH = 0;
var Z_FINISH$1 = 4;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED$1 = 8;
function Deflate(options) {
  if (!(this instanceof Deflate))
    return new Deflate(options);
  this.options = utils$4.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$1();
  this.strm.avail_out = 0;
  var status2 = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status2 !== Z_OK$1) {
    throw new Error(msg$1[status2]);
  }
  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$1.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status2 = zlib_deflate.deflateSetDictionary(this.strm, dict);
    if (status2 !== Z_OK$1) {
      throw new Error(msg$1[status2]);
    }
    this._dict_set = true;
  }
}
Deflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status2, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$1 : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = strings$1.string2buf(data);
  } else if (toString$2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$4.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status2 = zlib_deflate.deflate(strm, _mode);
    if (status2 !== Z_STREAM_END$1 && status2 !== Z_OK$1) {
      this.onEnd(status2);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(strings$1.buf2binstring(utils$4.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$4.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status2 !== Z_STREAM_END$1);
  if (_mode === Z_FINISH$1) {
    status2 = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status2);
    this.ended = true;
    return status2 === Z_OK$1;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function(status2) {
  if (status2 === Z_OK$1) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$4.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status2;
  this.msg = this.strm.msg;
};
function deflate$2(input, options) {
  var deflator = new Deflate(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$2(input, options);
}
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$2(input, options);
}
deflate$5.Deflate = Deflate;
deflate$5.deflate = deflate$2;
deflate$5.deflateRaw = deflateRaw;
deflate$5.gzip = gzip;
var inflate$5 = {};
var inflate$4 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var utils$3 = common$2;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type2, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask;
  var next2;
  var base = null;
  var base_index = 0;
  var end;
  var count = new utils$3.Buf16(MAXBITS + 1);
  var offs = new utils$3.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type2 === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next2 = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next2 += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var utils$2 = common$2;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$2.Buf16(320);
  this.work = new utils$2.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new utils$2.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils$2.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix, distfix;
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = new utils$2.Buf32(512);
    distfix = new utils$2.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table2(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src2, end, copy) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils$2.Buf8(state.wsize);
  }
  if (copy >= state.wsize) {
    utils$2.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    utils$2.arraySet(state.window, src2, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      utils$2.arraySet(state.window, src2, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$3(strm, flush) {
  var state;
  var input, output;
  var next2;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils$2.Buf8(4);
  var opts;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                utils$2.arraySet(
                  state.head.extra,
                  input,
                  next2,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next2);
              }
              have -= copy;
              next2 += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            utils$2.arraySet(output, input, next2, copy, put);
            have -= copy;
            next2 += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table2(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table2(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table2(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK;
}
inflate$4.inflateReset = inflateReset;
inflate$4.inflateReset2 = inflateReset2;
inflate$4.inflateResetKeep = inflateResetKeep;
inflate$4.inflateInit = inflateInit;
inflate$4.inflateInit2 = inflateInit2;
inflate$4.inflate = inflate$3;
inflate$4.inflateEnd = inflateEnd;
inflate$4.inflateGetHeader = inflateGetHeader;
inflate$4.inflateSetDictionary = inflateSetDictionary;
inflate$4.inflateInfo = "pako inflate (from Nodeca project)";
var constants$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$1() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader$1;
var zlib_inflate = inflate$4;
var utils$1 = common$2;
var strings = strings$2;
var c = constants$1;
var msg = messages;
var ZStream = zstream;
var GZheader = gzheader;
var toString$1 = Object.prototype.toString;
function Inflate(options) {
  if (!(this instanceof Inflate))
    return new Inflate(options);
  this.options = utils$1.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status2 = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status2 !== c.Z_OK) {
    throw new Error(msg[status2]);
  }
  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status2 = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status2 !== c.Z_OK) {
        throw new Error(msg[status2]);
      }
    }
  }
}
Inflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status2, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = strings.binstring2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$1.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status2 = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
    if (status2 === c.Z_NEED_DICT && dictionary) {
      status2 = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }
    if (status2 === c.Z_BUF_ERROR && allowBufError === true) {
      status2 = c.Z_OK;
      allowBufError = false;
    }
    if (status2 !== c.Z_STREAM_END && status2 !== c.Z_OK) {
      this.onEnd(status2);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status2 === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$1.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$1.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status2 !== c.Z_STREAM_END);
  if (status2 === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }
  if (_mode === c.Z_FINISH) {
    status2 = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status2);
    this.ended = true;
    return status2 === c.Z_OK;
  }
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function(status2) {
  if (status2 === c.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status2;
  this.msg = this.strm.msg;
};
function inflate$2(input, options) {
  var inflator = new Inflate(options);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }
  return inflator.result;
}
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$2(input, options);
}
inflate$5.Inflate = Inflate;
inflate$5.inflate = inflate$2;
inflate$5.inflateRaw = inflateRaw;
inflate$5.ungzip = inflate$2;
var assign$2 = common$2.assign;
var deflate$1 = deflate$5;
var inflate$1 = inflate$5;
var constants = constants$1;
var pako = {};
assign$2(pako, deflate$1, inflate$1, constants);
var pako_1 = pako;
const pako$1 = /* @__PURE__ */ getDefaultExportFromCjs(pako_1);
const processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
  const P = options.promiseModule;
  return new P((resolve2, reject) => {
    if (options.multiArgs) {
      arguments_.push((...result) => {
        if (options.errorFirst) {
          if (result[0]) {
            reject(result);
          } else {
            result.shift();
            resolve2(result);
          }
        } else {
          resolve2(result);
        }
      });
    } else if (options.errorFirst) {
      arguments_.push((error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve2(result);
        }
      });
    } else {
      arguments_.push(resolve2);
    }
    const self2 = this === proxy ? unwrapped : this;
    Reflect.apply(fn, self2, arguments_);
  });
};
const filterCache = /* @__PURE__ */ new WeakMap();
var pify = (input, options) => {
  options = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise,
    ...options
  };
  const objectType = typeof input;
  if (!(input !== null && (objectType === "object" || objectType === "function"))) {
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
  }
  const filter = (target, key) => {
    let cached = filterCache.get(target);
    if (!cached) {
      cached = {};
      filterCache.set(target, cached);
    }
    if (key in cached) {
      return cached[key];
    }
    const match = (pattern2) => typeof pattern2 === "string" || typeof key === "symbol" ? key === pattern2 : pattern2.test(key);
    const desc = Reflect.getOwnPropertyDescriptor(target, key);
    const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
    const included = options.include ? options.include.some(match) : !options.exclude.some(match);
    const shouldFilter = included && writableOrConfigurableOwn;
    cached[key] = shouldFilter;
    return shouldFilter;
  };
  const cache2 = /* @__PURE__ */ new WeakMap();
  const proxy = new Proxy(input, {
    apply(target, thisArg, args) {
      const cached = cache2.get(target);
      if (cached) {
        return Reflect.apply(cached, thisArg, args);
      }
      const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
      cache2.set(target, pified);
      return Reflect.apply(pified, thisArg, args);
    },
    get(target, key) {
      const property = target[key];
      if (!filter(target, key) || property === Function.prototype[key]) {
        return property;
      }
      const cached = cache2.get(property);
      if (cached) {
        return cached;
      }
      if (typeof property === "function") {
        const pified = processFn(property, options, proxy, target);
        cache2.set(property, pified);
        return pified;
      }
      return property;
    }
  });
  return proxy;
};
const pify$1 = /* @__PURE__ */ getDefaultExportFromCjs(pify);
function makeArray(subject) {
  return Array.isArray(subject) ? subject : [subject];
}
const EMPTY$3 = "";
const SPACE$1 = " ";
const ESCAPE = "\\";
const REGEX_TEST_BLANK_LINE = /^\s+$/;
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const REGEX_SPLITALL_CRLF = /\r?\n/g;
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
const SLASH = "/";
let TMP_KEY_IGNORE = "node-ignore";
if (typeof Symbol !== "undefined") {
  TMP_KEY_IGNORE = Symbol.for("node-ignore");
}
const KEY_IGNORE = TMP_KEY_IGNORE;
const define$2 = (object, key, value2) => Object.defineProperty(object, key, { value: value2 });
const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
const RETURN_FALSE = () => false;
const sanitizeRange = (range) => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY$3
);
const cleanRangeBackSlash = (slashes) => {
  const { length } = slashes;
  return slashes.slice(0, length - length % 2);
};
const REPLACERS = [
  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () => EMPTY$3
  ],
  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    (match) => match.indexOf("\\") === 0 ? SPACE$1 : EMPTY$3
  ],
  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE$1
  ],
  // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    (match) => `\\${match}`
  ],
  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => "[^/]"
  ],
  // leading slash
  [
    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => "^"
  ],
  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => "\\/"
  ],
  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,
    // '**/foo' <-> 'foo'
    () => "^(?:.*\\/)?"
  ],
  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer() {
      return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
    }
  ],
  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,
    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer
    // Check if it is not the last `'/**'`
    (_, index2, str2) => index2 + 6 < str2.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
  ],
  // normal intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'
    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,
    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1, p2) => {
      const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
      return p1 + unescaped;
    }
  ],
  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],
  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],
  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.
    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
  ],
  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,
    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38
    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.
    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
  ],
  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
      return `${prefix}(?=$|\\/$)`;
    }
  ]
];
const regexCache = /* @__PURE__ */ Object.create(null);
const makeRegex = (pattern2, ignoreCase) => {
  let source = regexCache[pattern2];
  if (!source) {
    source = REPLACERS.reduce(
      (prev, current2) => prev.replace(current2[0], current2[1].bind(pattern2)),
      pattern2
    );
    regexCache[pattern2] = source;
  }
  return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
};
const isString$3 = (subject) => typeof subject === "string";
const checkPattern = (pattern2) => pattern2 && isString$3(pattern2) && !REGEX_TEST_BLANK_LINE.test(pattern2) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern2) && pattern2.indexOf("#") !== 0;
const splitPattern = (pattern2) => pattern2.split(REGEX_SPLITALL_CRLF);
class IgnoreRule {
  constructor(origin, pattern2, negative, regex2) {
    this.origin = origin;
    this.pattern = pattern2;
    this.negative = negative;
    this.regex = regex2;
  }
}
const createRule = (pattern2, ignoreCase) => {
  const origin = pattern2;
  let negative = false;
  if (pattern2.indexOf("!") === 0) {
    negative = true;
    pattern2 = pattern2.substr(1);
  }
  pattern2 = pattern2.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
  const regex2 = makeRegex(pattern2, ignoreCase);
  return new IgnoreRule(
    origin,
    pattern2,
    negative,
    regex2
  );
};
const throwError$1 = (message, Ctor) => {
  throw new Ctor(message);
};
const checkPath = (path, originalPath, doThrow) => {
  if (!isString$3(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    );
  }
  if (!path) {
    return doThrow(`path must not be empty`, TypeError);
  }
  if (checkPath.isNotRelative(path)) {
    const r = "`path.relative()`d";
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    );
  }
  return true;
};
const isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
checkPath.isNotRelative = isNotRelative;
checkPath.convert = (p) => p;
class Ignore {
  constructor({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define$2(this, KEY_IGNORE, true);
    this._rules = [];
    this._ignoreCase = ignoreCase;
    this._allowRelativePaths = allowRelativePaths;
    this._initCache();
  }
  _initCache() {
    this._ignoreCache = /* @__PURE__ */ Object.create(null);
    this._testCache = /* @__PURE__ */ Object.create(null);
  }
  _addPattern(pattern2) {
    if (pattern2 && pattern2[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern2._rules);
      this._added = true;
      return;
    }
    if (checkPattern(pattern2)) {
      const rule = createRule(pattern2, this._ignoreCase);
      this._added = true;
      this._rules.push(rule);
    }
  }
  // @param {Array<string> | string | Ignore} pattern
  add(pattern2) {
    this._added = false;
    makeArray(
      isString$3(pattern2) ? splitPattern(pattern2) : pattern2
    ).forEach(this._addPattern, this);
    if (this._added) {
      this._initCache();
    }
    return this;
  }
  // legacy
  addPattern(pattern2) {
    return this.add(pattern2);
  }
  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X
  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen
  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.
  // @returns {TestResult} true if a file is ignored
  _testOne(path, checkUnignored) {
    let ignored = false;
    let unignored = false;
    this._rules.forEach((rule) => {
      const { negative } = rule;
      if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
        return;
      }
      const matched = rule.regex.test(path);
      if (matched) {
        ignored = !negative;
        unignored = negative;
      }
    });
    return {
      ignored,
      unignored
    };
  }
  // @returns {TestResult}
  _test(originalPath, cache2, checkUnignored, slices) {
    const path = originalPath && checkPath.convert(originalPath);
    checkPath(
      path,
      originalPath,
      this._allowRelativePaths ? RETURN_FALSE : throwError$1
    );
    return this._t(path, cache2, checkUnignored, slices);
  }
  _t(path, cache2, checkUnignored, slices) {
    if (path in cache2) {
      return cache2[path];
    }
    if (!slices) {
      slices = path.split(SLASH);
    }
    slices.pop();
    if (!slices.length) {
      return cache2[path] = this._testOne(path, checkUnignored);
    }
    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache2,
      checkUnignored,
      slices
    );
    return cache2[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
  }
  ignores(path) {
    return this._test(path, this._ignoreCache, false).ignored;
  }
  createFilter() {
    return (path) => !this.ignores(path);
  }
  filter(paths) {
    return makeArray(paths).filter(this.createFilter());
  }
  // @returns {TestResult}
  test(path) {
    return this._test(path, this._testCache, true);
  }
}
const factory = (options) => new Ignore(options);
const isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
factory.isPathValid = isPathValid;
factory.default = factory;
var ignore = factory;
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
) {
  const makePosix = (str2) => /^\\\\\?\\/.test(str2) || /["<>|\u0000-\u001F]+/u.test(str2) ? str2 : str2.replace(/\\/g, "/");
  checkPath.convert = makePosix;
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
  checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
}
const ignore$1 = /* @__PURE__ */ getDefaultExportFromCjs(ignore);
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str2, search, replacement) {
  search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), "g");
  return str2.replace(search, replacement);
}
var CleanGitRef = {
  clean: function clean(value2) {
    if (typeof value2 !== "string") {
      throw new Error("Expected a string, received: " + value2);
    }
    value2 = replaceAll(value2, "./", "/");
    value2 = replaceAll(value2, "..", ".");
    value2 = replaceAll(value2, " ", "-");
    value2 = replaceAll(value2, /^[~^:?*\\\-]/g, "");
    value2 = replaceAll(value2, /[~^:?*\\]/g, "-");
    value2 = replaceAll(value2, /[~^:?*\\\-]$/g, "");
    value2 = replaceAll(value2, "@{", "-");
    value2 = replaceAll(value2, /\.$/g, "");
    value2 = replaceAll(value2, /\/$/g, "");
    value2 = replaceAll(value2, /\.lock$/g, "");
    return value2;
  }
};
var lib = CleanGitRef;
const cleanGitRef = /* @__PURE__ */ getDefaultExportFromCjs(lib);
function onp(a_, b_) {
  var a = a_, b = b_, m = a.length, n = b.length, reverse = false, offset = m + 1, path = [], pathposi = [];
  var tmp1, tmp2;
  var init2 = function() {
    if (m >= n) {
      tmp1 = a;
      tmp2 = m;
      a = b;
      b = tmp1;
      m = n;
      n = tmp2;
      reverse = true;
      offset = m + 1;
    }
  };
  var P = function(startX, startY, endX, endY, r) {
    return {
      startX,
      startY,
      endX,
      endY,
      r
    };
  };
  var snake = function(k, p, pp) {
    var r, x, y, startX, startY;
    if (p > pp) {
      r = path[k - 1 + offset];
    } else {
      r = path[k + 1 + offset];
    }
    startY = y = Math.max(p, pp);
    startX = x = y - k;
    while (x < m && y < n && a[x] === b[y]) {
      ++x;
      ++y;
    }
    if (startX == x && startY == y) {
      path[k + offset] = r;
    } else {
      path[k + offset] = pathposi.length;
      pathposi[pathposi.length] = new P(startX, startY, x, y, r);
    }
    return y;
  };
  init2();
  return {
    compose: function() {
      var delta, size, fp, p, r, i, k, lastStartX, lastStartY, result;
      delta = n - m;
      size = m + n + 3;
      fp = {};
      for (i = 0; i < size; ++i) {
        fp[i] = -1;
        path[i] = -1;
      }
      p = -1;
      do {
        ++p;
        for (k = -p; k <= delta - 1; ++k) {
          fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
        }
        for (k = delta + p; k >= delta + 1; --k) {
          fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset] + 1, fp[delta + 1 + offset]);
      } while (fp[delta + offset] !== n);
      r = path[delta + offset];
      lastStartX = m;
      lastStartY = n;
      result = [];
      while (r !== -1) {
        let elem = pathposi[r];
        if (m != elem.endX || n != elem.endY) {
          result.push({
            file1: [
              reverse ? elem.endY : elem.endX,
              reverse ? lastStartY - elem.endY : lastStartX - elem.endX
            ],
            file2: [
              reverse ? elem.endX : elem.endY,
              reverse ? lastStartX - elem.endX : lastStartY - elem.endY
            ]
          });
        }
        lastStartX = elem.startX;
        lastStartY = elem.startY;
        r = pathposi[r].r;
      }
      if (lastStartX != 0 || lastStartY != 0) {
        result.push({
          file1: [0, reverse ? lastStartY : lastStartX],
          file2: [0, reverse ? lastStartX : lastStartY]
        });
      }
      result.reverse();
      return result;
    }
  };
}
function diff3MergeIndices(a, o, b) {
  var i;
  var m1 = new onp(o, a).compose();
  var m2 = new onp(o, b).compose();
  var hunks = [];
  function addHunk(h, side2) {
    hunks.push([h.file1[0], side2, h.file1[1], h.file2[0], h.file2[1]]);
  }
  for (i = 0; i < m1.length; i++) {
    addHunk(m1[i], 0);
  }
  for (i = 0; i < m2.length; i++) {
    addHunk(m2[i], 2);
  }
  hunks.sort(function(x, y) {
    return x[0] - y[0];
  });
  var result = [];
  var commonOffset = 0;
  function copyCommon(targetOffset) {
    if (targetOffset > commonOffset) {
      result.push([1, commonOffset, targetOffset - commonOffset]);
      commonOffset = targetOffset;
    }
  }
  for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
    var firstHunkIndex = hunkIndex;
    var hunk = hunks[hunkIndex];
    var regionLhs = hunk[0];
    var regionRhs = regionLhs + hunk[2];
    while (hunkIndex < hunks.length - 1) {
      var maybeOverlapping = hunks[hunkIndex + 1];
      var maybeLhs = maybeOverlapping[0];
      if (maybeLhs > regionRhs)
        break;
      regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
      hunkIndex++;
    }
    copyCommon(regionLhs);
    if (firstHunkIndex == hunkIndex) {
      if (hunk[4] > 0) {
        result.push([hunk[1], hunk[3], hunk[4]]);
      }
    } else {
      var regions = {
        0: [a.length, -1, o.length, -1],
        2: [b.length, -1, o.length, -1]
      };
      for (i = firstHunkIndex; i <= hunkIndex; i++) {
        hunk = hunks[i];
        var side = hunk[1];
        var r = regions[side];
        var oLhs = hunk[0];
        var oRhs = oLhs + hunk[2];
        var abLhs = hunk[3];
        var abRhs = abLhs + hunk[4];
        r[0] = Math.min(abLhs, r[0]);
        r[1] = Math.max(abRhs, r[1]);
        r[2] = Math.min(oLhs, r[2]);
        r[3] = Math.max(oRhs, r[3]);
      }
      var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
      var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
      var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
      var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
      result.push([
        -1,
        aLhs,
        aRhs - aLhs,
        regionLhs,
        regionRhs - regionLhs,
        bLhs,
        bRhs - bLhs
      ]);
    }
    commonOffset = regionRhs;
  }
  copyCommon(o.length);
  return result;
}
function diff3Merge(a, o, b) {
  var result = [];
  var files = [a, o, b];
  var indices = diff3MergeIndices(a, o, b);
  var okLines = [];
  function flushOk() {
    if (okLines.length) {
      result.push({
        ok: okLines
      });
    }
    okLines = [];
  }
  function pushOk(xs) {
    for (const x_ of xs) {
      okLines.push(x_);
    }
  }
  function isTrueConflict(rec) {
    if (rec[2] != rec[6])
      return true;
    var aoff = rec[1];
    var boff = rec[5];
    for (var j = 0; j < rec[2]; j++) {
      if (a[j + aoff] != b[j + boff])
        return true;
    }
    return false;
  }
  for (var x of indices) {
    var side = x[0];
    if (side == -1) {
      if (!isTrueConflict(x)) {
        pushOk(files[0].slice(x[1], x[1] + x[2]));
      } else {
        flushOk();
        result.push({
          conflict: {
            a: a.slice(x[1], x[1] + x[2]),
            aIndex: x[1],
            o: o.slice(x[3], x[3] + x[4]),
            oIndex: x[3],
            b: b.slice(x[5], x[5] + x[6]),
            bIndex: x[5]
          }
        });
      }
    } else {
      pushOk(files[side].slice(x[1], x[1] + x[2]));
    }
  }
  flushOk();
  return result;
}
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(json2) {
    const e = new BaseError(json2.message);
    e.code = json2.code;
    e.data = json2.data;
    e.caller = json2.caller;
    e.stack = json2.stack;
    return e;
  }
  get isIsomorphicGitError() {
    return true;
  }
}
class UnmergedPathsError extends BaseError {
  /**
   * @param {Array<string>} filepaths
   */
  constructor(filepaths) {
    super(
      `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
    );
    this.code = this.name = UnmergedPathsError.code;
    this.data = { filepaths };
  }
}
UnmergedPathsError.code = "UnmergedPathsError";
class InternalError extends BaseError {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
    );
    this.code = this.name = InternalError.code;
    this.data = { message };
  }
}
InternalError.code = "InternalError";
class UnsafeFilepathError extends BaseError {
  /**
   * @param {string} filepath
   */
  constructor(filepath) {
    super(`The filepath "${filepath}" contains unsafe character sequences`);
    this.code = this.name = UnsafeFilepathError.code;
    this.data = { filepath };
  }
}
UnsafeFilepathError.code = "UnsafeFilepathError";
class BufferCursor {
  constructor(buffer) {
    this.buffer = buffer;
    this._start = 0;
  }
  eof() {
    return this._start >= this.buffer.length;
  }
  tell() {
    return this._start;
  }
  seek(n) {
    this._start = n;
  }
  slice(n) {
    const r = this.buffer.slice(this._start, this._start + n);
    this._start += n;
    return r;
  }
  toString(enc, length) {
    const r = this.buffer.toString(enc, this._start, this._start + length);
    this._start += length;
    return r;
  }
  write(value2, length, enc) {
    const r = this.buffer.write(value2, this._start, length, enc);
    this._start += length;
    return r;
  }
  copy(source, start, end) {
    const r = source.copy(this.buffer, this._start, start, end);
    this._start += r;
    return r;
  }
  readUInt8() {
    const r = this.buffer.readUInt8(this._start);
    this._start += 1;
    return r;
  }
  writeUInt8(value2) {
    const r = this.buffer.writeUInt8(value2, this._start);
    this._start += 1;
    return r;
  }
  readUInt16BE() {
    const r = this.buffer.readUInt16BE(this._start);
    this._start += 2;
    return r;
  }
  writeUInt16BE(value2) {
    const r = this.buffer.writeUInt16BE(value2, this._start);
    this._start += 2;
    return r;
  }
  readUInt32BE() {
    const r = this.buffer.readUInt32BE(this._start);
    this._start += 4;
    return r;
  }
  writeUInt32BE(value2) {
    const r = this.buffer.writeUInt32BE(value2, this._start);
    this._start += 4;
    return r;
  }
}
function compareStrings(a, b) {
  return -(a < b) || +(a > b);
}
function comparePath(a, b) {
  return compareStrings(a.path, b.path);
}
function normalizeMode(mode) {
  let type2 = mode > 0 ? mode >> 12 : 0;
  if (type2 !== 4 && type2 !== 8 && type2 !== 10 && type2 !== 14) {
    type2 = 8;
  }
  let permissions = mode & 511;
  if (permissions & 73) {
    permissions = 493;
  } else {
    permissions = 420;
  }
  if (type2 !== 8)
    permissions = 0;
  return (type2 << 12) + permissions;
}
const MAX_UINT32 = 2 ** 32;
function SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {
  if (givenSeconds !== void 0 && givenNanoseconds !== void 0) {
    return [givenSeconds, givenNanoseconds];
  }
  if (milliseconds === void 0) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / 1e3);
  const nanoseconds = (milliseconds - seconds * 1e3) * 1e6;
  return [seconds, nanoseconds];
}
function normalizeStats(e) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e.ctimeSeconds,
    e.ctimeNanoseconds,
    e.ctimeMs,
    e.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e.mtimeSeconds,
    e.mtimeNanoseconds,
    e.mtimeMs,
    e.mtime
  );
  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT32,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
    mtimeSeconds: mtimeSeconds % MAX_UINT32,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
    dev: e.dev % MAX_UINT32,
    ino: e.ino % MAX_UINT32,
    mode: normalizeMode(e.mode % MAX_UINT32),
    uid: e.uid % MAX_UINT32,
    gid: e.gid % MAX_UINT32,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e.size > -1 ? e.size % MAX_UINT32 : 0
  };
}
function toHex(buffer) {
  let hex = "";
  for (const byte of new Uint8Array(buffer)) {
    if (byte < 16)
      hex += "0";
    hex += byte.toString(16);
  }
  return hex;
}
let supportsSubtleSHA1 = null;
async function shasum(buffer) {
  if (supportsSubtleSHA1 === null) {
    supportsSubtleSHA1 = await testSubtleSHA1();
  }
  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);
}
function shasumSync(buffer) {
  return new Hash$1().update(buffer).digest("hex");
}
async function subtleSHA1(buffer) {
  const hash2 = await crypto.subtle.digest("SHA-1", buffer);
  return toHex(hash2);
}
async function testSubtleSHA1() {
  try {
    const hash2 = await subtleSHA1(new Uint8Array([]));
    if (hash2 === "da39a3ee5e6b4b0d3255bfef95601890afd80709")
      return true;
  } catch (_) {
  }
  return false;
}
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & 32768),
    extended: Boolean(bits & 16384),
    stage: (bits & 12288) >> 12,
    nameLength: bits & 4095
  };
}
function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  flags.extended = false;
  flags.nameLength = Math.min(Buffer.from(entry.path).length, 4095);
  return (flags.assumeValid ? 32768 : 0) + (flags.extended ? 16384 : 0) + ((flags.stage & 3) << 12) + (flags.nameLength & 4095);
}
class GitIndex {
  /*::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   */
  constructor(entries, unmergedPaths) {
    this._dirty = false;
    this._unmergedPaths = unmergedPaths || /* @__PURE__ */ new Set();
    this._entries = entries || /* @__PURE__ */ new Map();
  }
  _addEntry(entry) {
    if (entry.flags.stage === 0) {
      entry.stages = [entry];
      this._entries.set(entry.path, entry);
      this._unmergedPaths.delete(entry.path);
    } else {
      let existingEntry = this._entries.get(entry.path);
      if (!existingEntry) {
        this._entries.set(entry.path, entry);
        existingEntry = entry;
      }
      existingEntry.stages[entry.flags.stage] = entry;
      this._unmergedPaths.add(entry.path);
    }
  }
  static async from(buffer) {
    if (Buffer.isBuffer(buffer)) {
      return GitIndex.fromBuffer(buffer);
    } else if (buffer === null) {
      return new GitIndex(null);
    } else {
      throw new InternalError("invalid type passed to GitIndex.from");
    }
  }
  static async fromBuffer(buffer) {
    if (buffer.length === 0) {
      throw new InternalError("Index file is empty (.git/index)");
    }
    const index2 = new GitIndex();
    const reader = new BufferCursor(buffer);
    const magic = reader.toString("utf8", 4);
    if (magic !== "DIRC") {
      throw new InternalError(`Invalid dircache magic file number: ${magic}`);
    }
    const shaComputed = await shasum(buffer.slice(0, -20));
    const shaClaimed = buffer.slice(-20).toString("hex");
    if (shaClaimed !== shaComputed) {
      throw new InternalError(
        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
      );
    }
    const version2 = reader.readUInt32BE();
    if (version2 !== 2) {
      throw new InternalError(`Unsupported dircache version: ${version2}`);
    }
    const numEntries = reader.readUInt32BE();
    let i = 0;
    while (!reader.eof() && i < numEntries) {
      const entry = {};
      entry.ctimeSeconds = reader.readUInt32BE();
      entry.ctimeNanoseconds = reader.readUInt32BE();
      entry.mtimeSeconds = reader.readUInt32BE();
      entry.mtimeNanoseconds = reader.readUInt32BE();
      entry.dev = reader.readUInt32BE();
      entry.ino = reader.readUInt32BE();
      entry.mode = reader.readUInt32BE();
      entry.uid = reader.readUInt32BE();
      entry.gid = reader.readUInt32BE();
      entry.size = reader.readUInt32BE();
      entry.oid = reader.slice(20).toString("hex");
      const flags = reader.readUInt16BE();
      entry.flags = parseCacheEntryFlags(flags);
      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
      if (pathlength < 1) {
        throw new InternalError(`Got a path length of: ${pathlength}`);
      }
      entry.path = reader.toString("utf8", pathlength);
      if (entry.path.includes("..\\") || entry.path.includes("../")) {
        throw new UnsafeFilepathError(entry.path);
      }
      let padding = 8 - (reader.tell() - 12) % 8;
      if (padding === 0)
        padding = 8;
      while (padding--) {
        const tmp = reader.readUInt8();
        if (tmp !== 0) {
          throw new InternalError(
            `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
          );
        } else if (reader.eof()) {
          throw new InternalError("Unexpected end of file");
        }
      }
      entry.stages = [];
      index2._addEntry(entry);
      i++;
    }
    return index2;
  }
  get unmergedPaths() {
    return [...this._unmergedPaths];
  }
  get entries() {
    return [...this._entries.values()].sort(comparePath);
  }
  get entriesMap() {
    return this._entries;
  }
  get entriesFlat() {
    return [...this.entries].flatMap((entry) => {
      return entry.stages.length > 1 ? entry.stages.filter((x) => x) : entry;
    });
  }
  *[Symbol.iterator]() {
    for (const entry of this.entries) {
      yield entry;
    }
  }
  insert({ filepath, stats, oid, stage = 0 }) {
    if (!stats) {
      stats = {
        ctimeSeconds: 0,
        ctimeNanoseconds: 0,
        mtimeSeconds: 0,
        mtimeNanoseconds: 0,
        dev: 0,
        ino: 0,
        mode: 0,
        uid: 0,
        gid: 0,
        size: 0
      };
    }
    stats = normalizeStats(stats);
    const bfilepath = Buffer.from(filepath);
    const entry = {
      ctimeSeconds: stats.ctimeSeconds,
      ctimeNanoseconds: stats.ctimeNanoseconds,
      mtimeSeconds: stats.mtimeSeconds,
      mtimeNanoseconds: stats.mtimeNanoseconds,
      dev: stats.dev,
      ino: stats.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '100644' is for a "regular non-executable file"
      mode: stats.mode || 33188,
      uid: stats.uid,
      gid: stats.gid,
      size: stats.size,
      path: filepath,
      oid,
      flags: {
        assumeValid: false,
        extended: false,
        stage,
        nameLength: bfilepath.length < 4095 ? bfilepath.length : 4095
      },
      stages: []
    };
    this._addEntry(entry);
    this._dirty = true;
  }
  delete({ filepath }) {
    if (this._entries.has(filepath)) {
      this._entries.delete(filepath);
    } else {
      for (const key of this._entries.keys()) {
        if (key.startsWith(filepath + "/")) {
          this._entries.delete(key);
        }
      }
    }
    if (this._unmergedPaths.has(filepath)) {
      this._unmergedPaths.delete(filepath);
    }
    this._dirty = true;
  }
  clear() {
    this._entries.clear();
    this._dirty = true;
  }
  has({ filepath }) {
    return this._entries.has(filepath);
  }
  render() {
    return this.entries.map((entry) => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`).join("\n");
  }
  static async _entryToBuffer(entry) {
    const bpath = Buffer.from(entry.path);
    const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
    const written = Buffer.alloc(length);
    const writer = new BufferCursor(written);
    const stat = normalizeStats(entry);
    writer.writeUInt32BE(stat.ctimeSeconds);
    writer.writeUInt32BE(stat.ctimeNanoseconds);
    writer.writeUInt32BE(stat.mtimeSeconds);
    writer.writeUInt32BE(stat.mtimeNanoseconds);
    writer.writeUInt32BE(stat.dev);
    writer.writeUInt32BE(stat.ino);
    writer.writeUInt32BE(stat.mode);
    writer.writeUInt32BE(stat.uid);
    writer.writeUInt32BE(stat.gid);
    writer.writeUInt32BE(stat.size);
    writer.write(entry.oid, 20, "hex");
    writer.writeUInt16BE(renderCacheEntryFlags(entry));
    writer.write(entry.path, bpath.length, "utf8");
    return written;
  }
  async toObject() {
    const header = Buffer.alloc(12);
    const writer = new BufferCursor(header);
    writer.write("DIRC", 4, "utf8");
    writer.writeUInt32BE(2);
    writer.writeUInt32BE(this.entriesFlat.length);
    let entryBuffers = [];
    for (const entry of this.entries) {
      entryBuffers.push(GitIndex._entryToBuffer(entry));
      if (entry.stages.length > 1) {
        for (const stage of entry.stages) {
          if (stage && stage !== entry) {
            entryBuffers.push(GitIndex._entryToBuffer(stage));
          }
        }
      }
    }
    entryBuffers = await Promise.all(entryBuffers);
    const body = Buffer.concat(entryBuffers);
    const main = Buffer.concat([header, body]);
    const sum = await shasum(main);
    return Buffer.concat([main, Buffer.from(sum, "hex")]);
  }
}
function compareStats(entry, stats) {
  const e = normalizeStats(entry);
  const s = normalizeStats(stats);
  const staleness = e.mode !== s.mode || e.mtimeSeconds !== s.mtimeSeconds || e.ctimeSeconds !== s.ctimeSeconds || e.uid !== s.uid || e.gid !== s.gid || e.ino !== s.ino || e.size !== s.size;
  return staleness;
}
let lock = null;
const IndexCache = Symbol("IndexCache");
function createCache() {
  return {
    map: /* @__PURE__ */ new Map(),
    stats: /* @__PURE__ */ new Map()
  };
}
async function updateCachedIndexFile(fs, filepath, cache2) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index2 = await GitIndex.from(rawIndexFile);
  cache2.map.set(filepath, index2);
  cache2.stats.set(filepath, stat);
}
async function isIndexStale(fs, filepath, cache2) {
  const savedStats = cache2.stats.get(filepath);
  if (savedStats === void 0)
    return true;
  const currStats = await fs.lstat(filepath);
  if (savedStats === null)
    return false;
  if (currStats === null)
    return false;
  return compareStats(savedStats, currStats);
}
class GitIndexManager {
  /**
   *
   * @param {object} opts
   * @param {import('../models/FileSystem.js').FileSystem} opts.fs
   * @param {string} opts.gitdir
   * @param {object} opts.cache
   * @param {bool} opts.allowUnmerged
   * @param {function(GitIndex): any} closure
   */
  static async acquire({ fs, gitdir, cache: cache2, allowUnmerged = true }, closure) {
    if (!cache2[IndexCache])
      cache2[IndexCache] = createCache();
    const filepath = `${gitdir}/index`;
    if (lock === null)
      lock = new AsyncLock({ maxPending: Infinity });
    let result;
    let unmergedPaths = [];
    await lock.acquire(filepath, async () => {
      if (await isIndexStale(fs, filepath, cache2[IndexCache])) {
        await updateCachedIndexFile(fs, filepath, cache2[IndexCache]);
      }
      const index2 = cache2[IndexCache].map.get(filepath);
      unmergedPaths = index2.unmergedPaths;
      if (unmergedPaths.length && !allowUnmerged)
        throw new UnmergedPathsError(unmergedPaths);
      result = await closure(index2);
      if (index2._dirty) {
        const buffer = await index2.toObject();
        await fs.write(filepath, buffer);
        cache2[IndexCache].stats.set(filepath, await fs.lstat(filepath));
        index2._dirty = false;
      }
    });
    return result;
  }
}
function basename(path) {
  const last2 = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last2 > -1) {
    path = path.slice(last2 + 1);
  }
  return path;
}
function dirname(path) {
  const last2 = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last2 === -1)
    return ".";
  if (last2 === 0)
    return "/";
  return path.slice(0, last2);
}
function flatFileListToDirectoryStructure(files) {
  const inodes = /* @__PURE__ */ new Map();
  const mkdir = function(name) {
    if (!inodes.has(name)) {
      const dir = {
        type: "tree",
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: []
      };
      inodes.set(name, dir);
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir)
        dir.parent.children.push(dir);
    }
    return inodes.get(name);
  };
  const mkfile = function(name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: "blob",
        fullpath: name,
        basename: basename(name),
        metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: []
      };
      if (file.parent)
        file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name);
  };
  mkdir(".");
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes;
}
function mode2type(mode) {
  switch (mode) {
    case 16384:
      return "tree";
    case 33188:
      return "blob";
    case 33261:
      return "blob";
    case 40960:
      return "blob";
    case 57344:
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);
}
class GitWalkerIndex {
  constructor({ fs, gitdir, cache: cache2 }) {
    this.treePromise = GitIndexManager.acquire(
      { fs, gitdir, cache: cache2 },
      async function(index2) {
        return flatFileListToDirectoryStructure(index2.entries);
      }
    );
    const walker = this;
    this.ConstructEntry = class StageEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const tree = await this.treePromise;
    const inode = tree.get(filepath);
    if (!inode)
      return null;
    if (inode.type === "blob")
      return null;
    if (inode.type !== "tree") {
      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
    }
    const names = inode.children.map((inode2) => inode2.fullpath);
    names.sort(compareStrings);
    return names;
  }
  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode;
  }
  async stat(entry) {
    if (entry._stat === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      if (!inode) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        );
      }
      const stats = inode.type === "tree" ? {} : normalizeStats(inode.metadata);
      entry._type = inode.type === "tree" ? "tree" : mode2type(stats.mode);
      entry._mode = stats.mode;
      if (inode.type === "tree") {
        entry._stat = void 0;
      } else {
        entry._stat = stats;
      }
    }
    return entry._stat;
  }
  async content(_entry) {
  }
  async oid(entry) {
    if (entry._oid === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      entry._oid = inode.metadata.oid;
    }
    return entry._oid;
  }
}
const GitWalkSymbol = Symbol("GitWalkSymbol");
function STAGE$1() {
  const o = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache: cache2 }) {
      return new GitWalkerIndex({ fs, gitdir, cache: cache2 });
    }
  });
  Object.freeze(o);
  return o;
}
class NotFoundError extends BaseError {
  /**
   * @param {string} what
   */
  constructor(what) {
    super(`Could not find ${what}.`);
    this.code = this.name = NotFoundError.code;
    this.data = { what };
  }
}
NotFoundError.code = "NotFoundError";
class ObjectTypeError extends BaseError {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(oid, actual, expected, filepath) {
    super(
      `Object ${oid} ${filepath ? `at ${filepath}` : ""}was anticipated to be a ${expected} but it is a ${actual}.`
    );
    this.code = this.name = ObjectTypeError.code;
    this.data = { oid, actual, expected, filepath };
  }
}
ObjectTypeError.code = "ObjectTypeError";
class InvalidOidError extends BaseError {
  /**
   * @param {string} value
   */
  constructor(value2) {
    super(`Expected a 40-char hex object id but saw "${value2}".`);
    this.code = this.name = InvalidOidError.code;
    this.data = { value: value2 };
  }
}
InvalidOidError.code = "InvalidOidError";
class NoRefspecError extends BaseError {
  /**
   * @param {string} remote
   */
  constructor(remote) {
    super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`);
    this.code = this.name = NoRefspecError.code;
    this.data = { remote };
  }
}
NoRefspecError.code = "NoRefspecError";
class GitPackedRefs {
  constructor(text) {
    this.refs = /* @__PURE__ */ new Map();
    this.parsedConfig = [];
    if (text) {
      let key = null;
      this.parsedConfig = text.trim().split("\n").map((line) => {
        if (/^\s*#/.test(line)) {
          return { line, comment: true };
        }
        const i = line.indexOf(" ");
        if (line.startsWith("^")) {
          const value2 = line.slice(1);
          this.refs.set(key + "^{}", value2);
          return { line, ref: key, peeled: value2 };
        } else {
          const value2 = line.slice(0, i);
          key = line.slice(i + 1);
          this.refs.set(key, value2);
          return { line, ref: key, oid: value2 };
        }
      });
    }
    return this;
  }
  static from(text) {
    return new GitPackedRefs(text);
  }
  delete(ref) {
    this.parsedConfig = this.parsedConfig.filter((entry) => entry.ref !== ref);
    this.refs.delete(ref);
  }
  toString() {
    return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
  }
}
class GitRefSpec {
  constructor({ remotePath, localPath, force, matchPrefix }) {
    Object.assign(this, {
      remotePath,
      localPath,
      force,
      matchPrefix
    });
  }
  static from(refspec) {
    const [
      forceMatch,
      remotePath,
      remoteGlobMatch,
      localPath,
      localGlobMatch
    ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
    const force = forceMatch === "+";
    const remoteIsGlob = remoteGlobMatch === "*";
    const localIsGlob = localGlobMatch === "*";
    if (remoteIsGlob !== localIsGlob) {
      throw new InternalError("Invalid refspec");
    }
    return new GitRefSpec({
      remotePath,
      localPath,
      force,
      matchPrefix: remoteIsGlob
    });
  }
  translate(remoteBranch) {
    if (this.matchPrefix) {
      if (remoteBranch.startsWith(this.remotePath)) {
        return this.localPath + remoteBranch.replace(this.remotePath, "");
      }
    } else {
      if (remoteBranch === this.remotePath)
        return this.localPath;
    }
    return null;
  }
  reverseTranslate(localBranch) {
    if (this.matchPrefix) {
      if (localBranch.startsWith(this.localPath)) {
        return this.remotePath + localBranch.replace(this.localPath, "");
      }
    } else {
      if (localBranch === this.localPath)
        return this.remotePath;
    }
    return null;
  }
}
class GitRefSpecSet {
  constructor(rules = []) {
    this.rules = rules;
  }
  static from(refspecs) {
    const rules = [];
    for (const refspec of refspecs) {
      rules.push(GitRefSpec.from(refspec));
    }
    return new GitRefSpecSet(rules);
  }
  add(refspec) {
    const rule = GitRefSpec.from(refspec);
    this.rules.push(rule);
  }
  translate(remoteRefs) {
    const result = [];
    for (const rule of this.rules) {
      for (const remoteRef of remoteRefs) {
        const localRef = rule.translate(remoteRef);
        if (localRef) {
          result.push([remoteRef, localRef]);
        }
      }
    }
    return result;
  }
  translateOne(remoteRef) {
    let result = null;
    for (const rule of this.rules) {
      const localRef = rule.translate(remoteRef);
      if (localRef) {
        result = localRef;
      }
    }
    return result;
  }
  localNamespaces() {
    return this.rules.filter((rule) => rule.matchPrefix).map((rule) => rule.localPath.replace(/\/$/, ""));
  }
}
function compareRefNames(a, b) {
  const _a2 = a.replace(/\^\{\}$/, "");
  const _b2 = b.replace(/\^\{\}$/, "");
  const tmp = -(_a2 < _b2) || +(_a2 > _b2);
  if (tmp === 0) {
    return a.endsWith("^{}") ? 1 : -1;
  }
  return tmp;
}
const memo = /* @__PURE__ */ new Map();
function normalizePath(path) {
  let normalizedPath = memo.get(path);
  if (!normalizedPath) {
    normalizedPath = normalizePathInternal(path);
    memo.set(path, normalizedPath);
  }
  return normalizedPath;
}
function normalizePathInternal(path) {
  path = path.split("/./").join("/").replace(/\/{2,}/g, "/");
  if (path === "/.")
    return "/";
  if (path === "./")
    return ".";
  if (path.startsWith("./"))
    path = path.slice(2);
  if (path.endsWith("/."))
    path = path.slice(0, -2);
  if (path.length > 1 && path.endsWith("/"))
    path = path.slice(0, -1);
  if (path === "")
    return ".";
  return path;
}
function join$2(...parts) {
  return normalizePath(parts.map(normalizePath).join("/"));
}
const num = (val) => {
  val = val.toLowerCase();
  let n = parseInt(val);
  if (val.endsWith("k"))
    n *= 1024;
  if (val.endsWith("m"))
    n *= 1024 * 1024;
  if (val.endsWith("g"))
    n *= 1024 * 1024 * 1024;
  return n;
};
const bool$1 = (val) => {
  val = val.trim().toLowerCase();
  if (val === "true" || val === "yes" || val === "on")
    return true;
  if (val === "false" || val === "no" || val === "off")
    return false;
  throw Error(
    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
  );
};
const schema$1 = {
  core: {
    filemode: bool$1,
    bare: bool$1,
    logallrefupdates: bool$1,
    symlinks: bool$1,
    ignorecase: bool$1,
    bigFileThreshold: num
  }
};
const SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
const SECTION_REGEX = /^[A-Za-z0-9-.]+$/;
const VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
const VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;
const VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;
const extractSectionLine = (line) => {
  const matches = SECTION_LINE_REGEX.exec(line);
  if (matches != null) {
    const [section, subsection] = matches.slice(1);
    return [section, subsection];
  }
  return null;
};
const extractVariableLine = (line) => {
  const matches = VARIABLE_LINE_REGEX.exec(line);
  if (matches != null) {
    const [name, rawValue = "true"] = matches.slice(1);
    const valueWithoutComments = removeComments(rawValue);
    const valueWithoutQuotes = removeQuotes(valueWithoutComments);
    return [name, valueWithoutQuotes];
  }
  return null;
};
const removeComments = (rawValue) => {
  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
  if (commentMatches == null) {
    return rawValue;
  }
  const [valueWithoutComment, comment] = commentMatches.slice(1);
  if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {
    return `${valueWithoutComment}${comment}`;
  }
  return valueWithoutComment;
};
const hasOddNumberOfQuotes = (text) => {
  const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
  return numberOfQuotes % 2 !== 0;
};
const removeQuotes = (text) => {
  return text.split("").reduce((newText, c2, idx, text2) => {
    const isQuote = c2 === '"' && text2[idx - 1] !== "\\";
    const isEscapeForQuote = c2 === "\\" && text2[idx + 1] === '"';
    if (isQuote || isEscapeForQuote) {
      return newText;
    }
    return newText + c2;
  }, "");
};
const lower = (text) => {
  return text != null ? text.toLowerCase() : null;
};
const getPath = (section, subsection, name) => {
  return [lower(section), subsection, lower(name)].filter((a) => a != null).join(".");
};
const normalizePath$1 = (path) => {
  const pathSegments = path.split(".");
  const section = pathSegments.shift();
  const name = pathSegments.pop();
  const subsection = pathSegments.length ? pathSegments.join(".") : void 0;
  return {
    section,
    subsection,
    name,
    path: getPath(section, subsection, name),
    sectionPath: getPath(section, subsection, null)
  };
};
const findLastIndex = (array2, callback) => {
  return array2.reduce((lastIndex, item, index2) => {
    return callback(item) ? index2 : lastIndex;
  }, -1);
};
class GitConfig {
  constructor(text) {
    let section = null;
    let subsection = null;
    this.parsedConfig = text.split("\n").map((line) => {
      let name = null;
      let value2 = null;
      const trimmedLine = line.trim();
      const extractedSection = extractSectionLine(trimmedLine);
      const isSection = extractedSection != null;
      if (isSection) {
        [section, subsection] = extractedSection;
      } else {
        const extractedVariable = extractVariableLine(trimmedLine);
        const isVariable = extractedVariable != null;
        if (isVariable) {
          [name, value2] = extractedVariable;
        }
      }
      const path = getPath(section, subsection, name);
      return { line, isSection, section, subsection, name, value: value2, path };
    });
  }
  static from(text) {
    return new GitConfig(text);
  }
  async get(path, getall = false) {
    const normalizedPath = normalizePath$1(path).path;
    const allValues = this.parsedConfig.filter((config) => config.path === normalizedPath).map(({ section, name, value: value2 }) => {
      const fn = schema$1[section] && schema$1[section][name];
      return fn ? fn(value2) : value2;
    });
    return getall ? allValues : allValues.pop();
  }
  async getall(path) {
    return this.get(path, true);
  }
  async getSubsections(section) {
    return this.parsedConfig.filter((config) => config.section === section && config.isSection).map((config) => config.subsection);
  }
  async deleteSection(section, subsection) {
    this.parsedConfig = this.parsedConfig.filter(
      (config) => !(config.section === section && config.subsection === subsection)
    );
  }
  async append(path, value2) {
    return this.set(path, value2, true);
  }
  async set(path, value2, append = false) {
    const {
      section,
      subsection,
      name,
      path: normalizedPath,
      sectionPath
    } = normalizePath$1(path);
    const configIndex = findLastIndex(
      this.parsedConfig,
      (config) => config.path === normalizedPath
    );
    if (value2 == null) {
      if (configIndex !== -1) {
        this.parsedConfig.splice(configIndex, 1);
      }
    } else {
      if (configIndex !== -1) {
        const config = this.parsedConfig[configIndex];
        const modifiedConfig = Object.assign({}, config, {
          name,
          value: value2,
          modified: true
        });
        if (append) {
          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
        } else {
          this.parsedConfig[configIndex] = modifiedConfig;
        }
      } else {
        const sectionIndex = this.parsedConfig.findIndex(
          (config) => config.path === sectionPath
        );
        const newConfig = {
          section,
          subsection,
          name,
          value: value2,
          modified: true,
          path: normalizedPath
        };
        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
          if (sectionIndex >= 0) {
            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
          } else {
            const newSection = {
              section,
              subsection,
              modified: true,
              path: sectionPath
            };
            this.parsedConfig.push(newSection, newConfig);
          }
        }
      }
    }
  }
  toString() {
    return this.parsedConfig.map(({ line, section, subsection, name, value: value2, modified: modified2 = false }) => {
      if (!modified2) {
        return line;
      }
      if (name != null && value2 != null) {
        if (typeof value2 === "string" && /[#;]/.test(value2)) {
          return `	${name} = "${value2}"`;
        }
        return `	${name} = ${value2}`;
      }
      if (subsection != null) {
        return `[${section} "${subsection}"]`;
      }
      return `[${section}]`;
    }).join("\n");
  }
}
class GitConfigManager {
  static async get({ fs, gitdir }) {
    const text = await fs.read(`${gitdir}/config`, { encoding: "utf8" });
    return GitConfig.from(text);
  }
  static async save({ fs, gitdir, config }) {
    await fs.write(`${gitdir}/config`, config.toString(), {
      encoding: "utf8"
    });
  }
}
const refpaths = (ref) => [
  `${ref}`,
  `refs/${ref}`,
  `refs/tags/${ref}`,
  `refs/heads/${ref}`,
  `refs/remotes/${ref}`,
  `refs/remotes/${ref}/HEAD`
];
const GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
let lock$1;
async function acquireLock(ref, callback) {
  if (lock$1 === void 0)
    lock$1 = new AsyncLock();
  return lock$1.acquire(ref, callback);
}
class GitRefManager {
  static async updateRemoteRefs({
    fs,
    gitdir,
    remote,
    refs,
    symrefs,
    tags,
    refspecs = void 0,
    prune = false,
    pruneTags = false
  }) {
    for (const value2 of refs.values()) {
      if (!value2.match(/[0-9a-f]{40}/)) {
        throw new InvalidOidError(value2);
      }
    }
    const config = await GitConfigManager.get({ fs, gitdir });
    if (!refspecs) {
      refspecs = await config.getall(`remote.${remote}.fetch`);
      if (refspecs.length === 0) {
        throw new NoRefspecError(remote);
      }
      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
    }
    const refspec = GitRefSpecSet.from(refspecs);
    const actualRefsToWrite = /* @__PURE__ */ new Map();
    if (pruneTags) {
      const tags2 = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: "refs/tags"
      });
      await GitRefManager.deleteRefs({
        fs,
        gitdir,
        refs: tags2.map((tag2) => `refs/tags/${tag2}`)
      });
    }
    if (tags) {
      for (const serverRef of refs.keys()) {
        if (serverRef.startsWith("refs/tags") && !serverRef.endsWith("^{}")) {
          if (!await GitRefManager.exists({ fs, gitdir, ref: serverRef })) {
            const oid = refs.get(serverRef);
            actualRefsToWrite.set(serverRef, oid);
          }
        }
      }
    }
    const refTranslations = refspec.translate([...refs.keys()]);
    for (const [serverRef, translatedRef] of refTranslations) {
      const value2 = refs.get(serverRef);
      actualRefsToWrite.set(translatedRef, value2);
    }
    const symrefTranslations = refspec.translate([...symrefs.keys()]);
    for (const [serverRef, translatedRef] of symrefTranslations) {
      const value2 = symrefs.get(serverRef);
      const symtarget = refspec.translateOne(value2);
      if (symtarget) {
        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
      }
    }
    const pruned = [];
    if (prune) {
      for (const filepath of refspec.localNamespaces()) {
        const refs2 = (await GitRefManager.listRefs({
          fs,
          gitdir,
          filepath
        })).map((file) => `${filepath}/${file}`);
        for (const ref of refs2) {
          if (!actualRefsToWrite.has(ref)) {
            pruned.push(ref);
          }
        }
      }
      if (pruned.length > 0) {
        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
      }
    }
    for (const [key, value2] of actualRefsToWrite) {
      await acquireLock(
        key,
        async () => fs.write(join$2(gitdir, key), `${value2.trim()}
`, "utf8")
      );
    }
    return { pruned };
  }
  // TODO: make this less crude?
  static async writeRef({ fs, gitdir, ref, value: value2 }) {
    if (!value2.match(/[0-9a-f]{40}/)) {
      throw new InvalidOidError(value2);
    }
    await acquireLock(
      ref,
      async () => fs.write(join$2(gitdir, ref), `${value2.trim()}
`, "utf8")
    );
  }
  static async writeSymbolicRef({ fs, gitdir, ref, value: value2 }) {
    await acquireLock(
      ref,
      async () => fs.write(join$2(gitdir, ref), `ref: ${value2.trim()}
`, "utf8")
    );
  }
  static async deleteRef({ fs, gitdir, ref }) {
    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] });
  }
  static async deleteRefs({ fs, gitdir, refs }) {
    await Promise.all(refs.map((ref) => fs.rm(join$2(gitdir, ref))));
    let text = await acquireLock(
      "packed-refs",
      async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
    );
    const packed = GitPackedRefs.from(text);
    const beforeSize = packed.refs.size;
    for (const ref of refs) {
      if (packed.refs.has(ref)) {
        packed.delete(ref);
      }
    }
    if (packed.refs.size < beforeSize) {
      text = packed.toString();
      await acquireLock(
        "packed-refs",
        async () => fs.write(`${gitdir}/packed-refs`, text, { encoding: "utf8" })
      );
    }
  }
  /**
   * @param {object} args
   * @param {import('../models/FileSystem.js').FileSystem} args.fs
   * @param {string} args.gitdir
   * @param {string} args.ref
   * @param {number} [args.depth]
   * @returns {Promise<string>}
   */
  static async resolve({ fs, gitdir, ref, depth = void 0 }) {
    if (depth !== void 0) {
      depth--;
      if (depth === -1) {
        return ref;
      }
    }
    if (ref.startsWith("ref: ")) {
      ref = ref.slice("ref: ".length);
      return GitRefManager.resolve({ fs, gitdir, ref, depth });
    }
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref;
    }
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    const allpaths = refpaths(ref).filter((p) => !GIT_FILES.includes(p));
    for (const ref2 of allpaths) {
      const sha = await acquireLock(
        ref2,
        async () => await fs.read(`${gitdir}/${ref2}`, { encoding: "utf8" }) || packedMap.get(ref2)
      );
      if (sha) {
        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth });
      }
    }
    throw new NotFoundError(ref);
  }
  static async exists({ fs, gitdir, ref }) {
    try {
      await GitRefManager.expand({ fs, gitdir, ref });
      return true;
    } catch (err2) {
      return false;
    }
  }
  static async expand({ fs, gitdir, ref }) {
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref;
    }
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    const allpaths = refpaths(ref);
    for (const ref2 of allpaths) {
      const refExists = await acquireLock(
        ref2,
        async () => fs.exists(`${gitdir}/${ref2}`)
      );
      if (refExists)
        return ref2;
      if (packedMap.has(ref2))
        return ref2;
    }
    throw new NotFoundError(ref);
  }
  static async expandAgainstMap({ ref, map: map2 }) {
    const allpaths = refpaths(ref);
    for (const ref2 of allpaths) {
      if (await map2.has(ref2))
        return ref2;
    }
    throw new NotFoundError(ref);
  }
  static resolveAgainstMap({ ref, fullref = ref, depth = void 0, map: map2 }) {
    if (depth !== void 0) {
      depth--;
      if (depth === -1) {
        return { fullref, oid: ref };
      }
    }
    if (ref.startsWith("ref: ")) {
      ref = ref.slice("ref: ".length);
      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map: map2 });
    }
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return { fullref, oid: ref };
    }
    const allpaths = refpaths(ref);
    for (const ref2 of allpaths) {
      const sha = map2.get(ref2);
      if (sha) {
        return GitRefManager.resolveAgainstMap({
          ref: sha.trim(),
          fullref: ref2,
          depth,
          map: map2
        });
      }
    }
    throw new NotFoundError(ref);
  }
  static async packedRefs({ fs, gitdir }) {
    const text = await acquireLock(
      "packed-refs",
      async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
    );
    const packed = GitPackedRefs.from(text);
    return packed.refs;
  }
  // List all the refs that match the `filepath` prefix
  static async listRefs({ fs, gitdir, filepath }) {
    const packedMap = GitRefManager.packedRefs({ fs, gitdir });
    let files = null;
    try {
      files = await fs.readdirDeep(`${gitdir}/${filepath}`);
      files = files.map((x) => x.replace(`${gitdir}/${filepath}/`, ""));
    } catch (err2) {
      files = [];
    }
    for (let key of (await packedMap).keys()) {
      if (key.startsWith(filepath)) {
        key = key.replace(filepath + "/", "");
        if (!files.includes(key)) {
          files.push(key);
        }
      }
    }
    files.sort(compareRefNames);
    return files;
  }
  static async listBranches({ fs, gitdir, remote }) {
    if (remote) {
      return GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs/remotes/${remote}`
      });
    } else {
      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` });
    }
  }
  static async listTags({ fs, gitdir }) {
    const tags = await GitRefManager.listRefs({
      fs,
      gitdir,
      filepath: `refs/tags`
    });
    return tags.filter((x) => !x.endsWith("^{}"));
  }
}
function compareTreeEntryPath(a, b) {
  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b));
}
function appendSlashIfDir(entry) {
  return entry.mode === "040000" ? entry.path + "/" : entry.path;
}
function mode2type$1(mode) {
  switch (mode) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
}
function parseBuffer(buffer) {
  const _entries = [];
  let cursor = 0;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(32, cursor);
    if (space === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      );
    }
    const nullchar = buffer.indexOf(0, cursor);
    if (nullchar === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      );
    }
    let mode = buffer.slice(cursor, space).toString("utf8");
    if (mode === "40000")
      mode = "040000";
    const type2 = mode2type$1(mode);
    const path = buffer.slice(space + 1, nullchar).toString("utf8");
    if (path.includes("\\") || path.includes("/")) {
      throw new UnsafeFilepathError(path);
    }
    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString("hex");
    cursor = nullchar + 21;
    _entries.push({ mode, path, oid, type: type2 });
  }
  return _entries;
}
function limitModeToAllowed(mode) {
  if (typeof mode === "number") {
    mode = mode.toString(8);
  }
  if (mode.match(/^0?4.*/))
    return "040000";
  if (mode.match(/^1006.*/))
    return "100644";
  if (mode.match(/^1007.*/))
    return "100755";
  if (mode.match(/^120.*/))
    return "120000";
  if (mode.match(/^160.*/))
    return "160000";
  throw new InternalError(`Could not understand file mode: ${mode}`);
}
function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha;
  }
  entry.mode = limitModeToAllowed(entry.mode);
  if (!entry.type) {
    entry.type = mode2type$1(entry.mode);
  }
  return entry;
}
class GitTree {
  constructor(entries) {
    if (Buffer.isBuffer(entries)) {
      this._entries = parseBuffer(entries);
    } else if (Array.isArray(entries)) {
      this._entries = entries.map(nudgeIntoShape);
    } else {
      throw new InternalError("invalid type passed to GitTree constructor");
    }
    this._entries.sort(comparePath);
  }
  static from(tree) {
    return new GitTree(tree);
  }
  render() {
    return this._entries.map((entry) => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join("\n");
  }
  toObject() {
    const entries = [...this._entries];
    entries.sort(compareTreeEntryPath);
    return Buffer.concat(
      entries.map((entry) => {
        const mode = Buffer.from(entry.mode.replace(/^0/, ""));
        const space = Buffer.from(" ");
        const path = Buffer.from(entry.path, "utf8");
        const nullchar = Buffer.from([0]);
        const oid = Buffer.from(entry.oid, "hex");
        return Buffer.concat([mode, space, path, nullchar, oid]);
      })
    );
  }
  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries;
  }
  *[Symbol.iterator]() {
    for (const entry of this._entries) {
      yield entry;
    }
  }
}
class GitObject {
  static wrap({ type: type2, object }) {
    return Buffer.concat([
      Buffer.from(`${type2} ${object.byteLength.toString()}\0`),
      Buffer.from(object)
    ]);
  }
  static unwrap(buffer) {
    const s = buffer.indexOf(32);
    const i = buffer.indexOf(0);
    const type2 = buffer.slice(0, s).toString("utf8");
    const length = buffer.slice(s + 1, i).toString("utf8");
    const actualLength = buffer.length - (i + 1);
    if (parseInt(length) !== actualLength) {
      throw new InternalError(
        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
      );
    }
    return {
      type: type2,
      object: Buffer.from(buffer.slice(i + 1))
    };
  }
}
async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null;
  }
  return { object: file, format: "deflated", source };
}
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);
  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    );
  }
  const targetSize = readVarIntLE(reader);
  let target;
  const firstOp = readOp(reader, source);
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);
    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }
    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      );
    }
  }
  return target;
}
function readVarIntLE(reader) {
  let result = 0;
  let shift = 0;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift;
    shift += 7;
  } while (byte & 128);
  return result;
}
function readCompactLE(reader, flags, size) {
  let result = 0;
  let shift = 0;
  while (size--) {
    if (flags & 1) {
      result |= reader.readUInt8() << shift;
    }
    flags >>= 1;
    shift += 8;
  }
  return result;
}
function readOp(reader, source) {
  const byte = reader.readUInt8();
  const COPY2 = 128;
  const OFFS = 15;
  const SIZE = 112;
  if (byte & COPY2) {
    const offset = readCompactLE(reader, byte & OFFS, 4);
    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);
    if (size === 0)
      size = 65536;
    return source.slice(offset, offset + size);
  } else {
    return reader.slice(byte);
  }
}
function fromValue$1(value2) {
  let queue = [value2];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getIterator$1(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue$1(iterable);
}
class StreamReader {
  constructor(stream) {
    this.stream = getIterator$1(stream);
    this.buffer = null;
    this.cursor = 0;
    this.undoCursor = 0;
    this.started = false;
    this._ended = false;
    this._discardedBytes = 0;
  }
  eof() {
    return this._ended && this.cursor === this.buffer.length;
  }
  tell() {
    return this._discardedBytes + this.cursor;
  }
  async byte() {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended)
        return;
    }
    this._moveCursor(1);
    return this.buffer[this.undoCursor];
  }
  async chunk() {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended)
        return;
    }
    this._moveCursor(this.buffer.length);
    return this.buffer.slice(this.undoCursor, this.cursor);
  }
  async read(n) {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
    return this.buffer.slice(this.undoCursor, this.cursor);
  }
  async skip(n) {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
  }
  async undo() {
    this.cursor = this.undoCursor;
  }
  async _next() {
    this.started = true;
    let { done, value: value2 } = await this.stream.next();
    if (done) {
      this._ended = true;
      if (!value2)
        return Buffer.alloc(0);
    }
    if (value2) {
      value2 = Buffer.from(value2);
    }
    return value2;
  }
  _trim() {
    this.buffer = this.buffer.slice(this.undoCursor);
    this.cursor -= this.undoCursor;
    this._discardedBytes += this.undoCursor;
    this.undoCursor = 0;
  }
  _moveCursor(n) {
    this.undoCursor = this.cursor;
    this.cursor += n;
    if (this.cursor > this.buffer.length) {
      this.cursor = this.buffer.length;
    }
  }
  async _accumulate(n) {
    if (this._ended)
      return;
    const buffers = [this.buffer];
    while (this.cursor + n > lengthBuffers(buffers)) {
      const nextbuffer = await this._next();
      if (this._ended)
        break;
      buffers.push(nextbuffer);
    }
    this.buffer = Buffer.concat(buffers);
  }
  async _loadnext() {
    this._discardedBytes += this.buffer.length;
    this.undoCursor = 0;
    this.cursor = 0;
    this.buffer = await this._next();
  }
  async _init() {
    this.buffer = await this._next();
  }
}
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, 0);
}
async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read(4);
  PACK = PACK.toString("utf8");
  if (PACK !== "PACK") {
    throw new InternalError(`Invalid PACK header '${PACK}'`);
  }
  let version2 = await reader.read(4);
  version2 = version2.readUInt32BE(0);
  if (version2 !== 2) {
    throw new InternalError(`Invalid packfile version: ${version2}`);
  }
  let numObjects = await reader.read(4);
  numObjects = numObjects.readUInt32BE(0);
  if (numObjects < 1)
    return;
  while (!reader.eof() && numObjects--) {
    const offset = reader.tell();
    const { type: type2, length, ofs, reference } = await parseHeader(reader);
    const inflator = new pako$1.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (!chunk)
        break;
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`);
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          );
        }
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type: type2,
          num: numObjects,
          offset,
          end,
          reference,
          ofs
        });
      }
    }
  }
}
async function parseHeader(reader) {
  let byte = await reader.byte();
  const type2 = byte >> 4 & 7;
  let length = byte & 15;
  if (byte & 128) {
    let shift = 4;
    do {
      byte = await reader.byte();
      length |= (byte & 127) << shift;
      shift += 7;
    } while (byte & 128);
  }
  let ofs;
  let reference;
  if (type2 === 6) {
    let shift = 0;
    ofs = 0;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & 127) << shift;
      shift += 7;
      bytes.push(byte);
    } while (byte & 128);
    reference = Buffer.from(bytes);
  }
  if (type2 === 7) {
    const buf = await reader.read(20);
    reference = buf;
  }
  return { type: type2, length, ofs, reference };
}
let supportsDecompressionStream = false;
async function inflate(buffer) {
  return supportsDecompressionStream ? browserInflate(buffer) : pako$1.inflate(buffer);
}
async function browserInflate(buffer) {
  const ds = new DecompressionStream("deflate");
  const d = new Blob([buffer]).stream().pipeThrough(ds);
  return new Uint8Array(await new Response(d).arrayBuffer());
}
function decodeVarInt(reader) {
  const bytes = [];
  let byte = 0;
  let multibyte = 0;
  do {
    byte = reader.readUInt8();
    const lastSeven = byte & 127;
    bytes.push(lastSeven);
    multibyte = byte & 128;
  } while (multibyte);
  return bytes.reduce((a, b) => a + 1 << 7 | b, -1);
}
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift = 4;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift;
    shift += 7;
  } while (byte & 128);
  return result;
}
class GitPackIndex {
  constructor(stuff) {
    Object.assign(this, stuff);
    this.offsetCache = {};
  }
  static async fromIdx({ idx, getExternalRefDelta }) {
    const reader = new BufferCursor(idx);
    const magic = reader.slice(4).toString("hex");
    if (magic !== "ff744f63") {
      return;
    }
    const version2 = reader.readUInt32BE();
    if (version2 !== 2) {
      throw new InternalError(
        `Unable to read version ${version2} packfile IDX. (Only version 2 supported)`
      );
    }
    if (idx.byteLength > 2048 * 1024 * 1024) {
      throw new InternalError(
        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
      );
    }
    reader.seek(reader.tell() + 4 * 255);
    const size = reader.readUInt32BE();
    const hashes = [];
    for (let i = 0; i < size; i++) {
      const hash2 = reader.slice(20).toString("hex");
      hashes[i] = hash2;
    }
    reader.seek(reader.tell() + 4 * size);
    const offsets = /* @__PURE__ */ new Map();
    for (let i = 0; i < size; i++) {
      offsets.set(hashes[i], reader.readUInt32BE());
    }
    const packfileSha = reader.slice(20).toString("hex");
    return new GitPackIndex({
      hashes,
      crcs: {},
      offsets,
      packfileSha,
      getExternalRefDelta
    });
  }
  static async fromPack({ pack, getExternalRefDelta, onProgress }) {
    const listpackTypes = {
      1: "commit",
      2: "tree",
      3: "blob",
      4: "tag",
      6: "ofs-delta",
      7: "ref-delta"
    };
    const offsetToObject = {};
    const packfileSha = pack.slice(-20).toString("hex");
    const hashes = [];
    const crcs = {};
    const offsets = /* @__PURE__ */ new Map();
    let totalObjectCount = null;
    let lastPercent = null;
    await listpack([pack], async ({ data, type: type2, reference, offset, num: num2 }) => {
      if (totalObjectCount === null)
        totalObjectCount = num2;
      const percent = Math.floor(
        (totalObjectCount - num2) * 100 / totalObjectCount
      );
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: "Receiving objects",
            loaded: totalObjectCount - num2,
            total: totalObjectCount
          });
        }
      }
      lastPercent = percent;
      type2 = listpackTypes[type2];
      if (["commit", "tree", "blob", "tag"].includes(type2)) {
        offsetToObject[offset] = {
          type: type2,
          offset
        };
      } else if (type2 === "ofs-delta") {
        offsetToObject[offset] = {
          type: type2,
          offset
        };
      } else if (type2 === "ref-delta") {
        offsetToObject[offset] = {
          type: type2,
          offset
        };
      }
    });
    const offsetArray = Object.keys(offsetToObject).map(Number);
    for (const [i, start] of offsetArray.entries()) {
      const end = i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];
      const o = offsetToObject[start];
      const crc = crc32$3.buf(pack.slice(start, end)) >>> 0;
      o.end = end;
      o.crc = crc;
    }
    const p = new GitPackIndex({
      pack: Promise.resolve(pack),
      packfileSha,
      crcs,
      hashes,
      offsets,
      getExternalRefDelta
    });
    lastPercent = null;
    let count = 0;
    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let offset in offsetToObject) {
      offset = Number(offset);
      const percent = Math.floor(count * 100 / totalObjectCount);
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: "Resolving deltas",
            loaded: count,
            total: totalObjectCount
          });
        }
      }
      count++;
      lastPercent = percent;
      const o = offsetToObject[offset];
      if (o.oid)
        continue;
      try {
        p.readDepth = 0;
        p.externalReadDepth = 0;
        const { type: type2, object } = await p.readSlice({ start: offset });
        objectsByDepth[p.readDepth] += 1;
        const oid = await shasum(GitObject.wrap({ type: type2, object }));
        o.oid = oid;
        hashes.push(oid);
        offsets.set(oid, offset);
        crcs[oid] = o.crc;
      } catch (err2) {
        continue;
      }
    }
    hashes.sort();
    return p;
  }
  async toBuffer() {
    const buffers = [];
    const write = (str2, encoding) => {
      buffers.push(Buffer.from(str2, encoding));
    };
    write("ff744f63", "hex");
    write("00000002", "hex");
    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
    for (let i = 0; i < 256; i++) {
      let count = 0;
      for (const hash2 of this.hashes) {
        if (parseInt(hash2.slice(0, 2), 16) <= i)
          count++;
      }
      fanoutBuffer.writeUInt32BE(count);
    }
    buffers.push(fanoutBuffer.buffer);
    for (const hash2 of this.hashes) {
      write(hash2, "hex");
    }
    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash2 of this.hashes) {
      crcsBuffer.writeUInt32BE(this.crcs[hash2]);
    }
    buffers.push(crcsBuffer.buffer);
    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash2 of this.hashes) {
      offsetsBuffer.writeUInt32BE(this.offsets.get(hash2));
    }
    buffers.push(offsetsBuffer.buffer);
    write(this.packfileSha, "hex");
    const totalBuffer = Buffer.concat(buffers);
    const sha = await shasum(totalBuffer);
    const shaBuffer = Buffer.alloc(20);
    shaBuffer.write(sha, "hex");
    return Buffer.concat([totalBuffer, shaBuffer]);
  }
  async load({ pack }) {
    this.pack = pack;
  }
  async unload() {
    this.pack = null;
  }
  async read({ oid }) {
    if (!this.offsets.get(oid)) {
      if (this.getExternalRefDelta) {
        this.externalReadDepth++;
        return this.getExternalRefDelta(oid);
      } else {
        throw new InternalError(`Could not read object ${oid} from packfile`);
      }
    }
    const start = this.offsets.get(oid);
    return this.readSlice({ start });
  }
  async readSlice({ start }) {
    if (this.offsetCache[start]) {
      return Object.assign({}, this.offsetCache[start]);
    }
    this.readDepth++;
    const types2 = {
      16: "commit",
      32: "tree",
      48: "blob",
      64: "tag",
      96: "ofs_delta",
      112: "ref_delta"
    };
    if (!this.pack) {
      throw new InternalError(
        "Tried to read from a GitPackIndex with no packfile loaded into memory"
      );
    }
    const raw = (await this.pack).slice(start);
    const reader = new BufferCursor(raw);
    const byte = reader.readUInt8();
    const btype = byte & 112;
    let type2 = types2[btype];
    if (type2 === void 0) {
      throw new InternalError("Unrecognized type: 0b" + btype.toString(2));
    }
    const lastFour = byte & 15;
    let length = lastFour;
    const multibyte = byte & 128;
    if (multibyte) {
      length = otherVarIntDecode(reader, lastFour);
    }
    let base = null;
    let object = null;
    if (type2 === "ofs_delta") {
      const offset = decodeVarInt(reader);
      const baseOffset = start - offset;
      ({ object: base, type: type2 } = await this.readSlice({ start: baseOffset }));
    }
    if (type2 === "ref_delta") {
      const oid = reader.slice(20).toString("hex");
      ({ object: base, type: type2 } = await this.read({ oid }));
    }
    const buffer = raw.slice(reader.tell());
    object = Buffer.from(await inflate(buffer));
    if (object.byteLength !== length) {
      throw new InternalError(
        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
      );
    }
    if (base) {
      object = Buffer.from(applyDelta(object, base));
    }
    if (this.readDepth > 3) {
      this.offsetCache[start] = { type: type2, object };
    }
    return { type: type2, format: "content", object };
  }
}
const PackfileCache = Symbol("PackfileCache");
async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
}
function readPackIndex({
  fs,
  cache: cache2,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  if (!cache2[PackfileCache])
    cache2[PackfileCache] = /* @__PURE__ */ new Map();
  let p = cache2[PackfileCache].get(filename);
  if (!p) {
    p = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    });
    cache2[PackfileCache].set(filename, p);
  }
  return p;
}
async function readObjectPacked({
  fs,
  cache: cache2,
  gitdir,
  oid,
  format = "content",
  getExternalRefDelta
}) {
  let list = await fs.readdir(join$2(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache: cache2,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    if (p.offsets.has(oid)) {
      if (!p.pack) {
        const packFile = indexFile.replace(/idx$/, "pack");
        p.pack = fs.read(packFile);
      }
      const result = await p.read({ oid, getExternalRefDelta });
      result.format = "content";
      result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
      return result;
    }
  }
  return null;
}
async function _readObject({
  fs,
  cache: cache2,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid2) => _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
  let result;
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    result = { format: "wrapped", object: Buffer.from(`tree 0\0`) };
  }
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache: cache2,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  if (!result) {
    throw new NotFoundError(oid);
  }
  if (format === "deflated") {
    return result;
  }
  if (result.format === "deflated") {
    result.object = Buffer.from(await inflate(result.object));
    result.format = "wrapped";
  }
  if (result.format === "wrapped") {
    if (format === "wrapped" && result.format === "wrapped") {
      return result;
    }
    const sha = await shasum(result.object);
    if (sha !== oid) {
      throw new InternalError(
        `SHA check failed! Expected ${oid}, computed ${sha}`
      );
    }
    const { object, type: type2 } = GitObject.unwrap(result.object);
    result.type = type2;
    result.object = object;
    result.format = "content";
  }
  if (result.format === "content") {
    if (format === "content")
      return result;
    return;
  }
  throw new InternalError(`invalid format "${result.format}"`);
}
class AlreadyExistsError extends BaseError {
  /**
   * @param {'note'|'remote'|'tag'|'branch'} noun
   * @param {string} where
   * @param {boolean} canForce
   */
  constructor(noun, where, canForce = true) {
    super(
      `Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ""}`
    );
    this.code = this.name = AlreadyExistsError.code;
    this.data = { noun, where, canForce };
  }
}
AlreadyExistsError.code = "AlreadyExistsError";
class AmbiguousError extends BaseError {
  /**
   * @param {'oids'|'refs'} nouns
   * @param {string} short
   * @param {string[]} matches
   */
  constructor(nouns, short, matches) {
    super(
      `Found multiple ${nouns} matching "${short}" (${matches.join(
        ", "
      )}). Use a longer abbreviation length to disambiguate them.`
    );
    this.code = this.name = AmbiguousError.code;
    this.data = { nouns, short, matches };
  }
}
AmbiguousError.code = "AmbiguousError";
class CheckoutConflictError extends BaseError {
  /**
   * @param {string[]} filepaths
   */
  constructor(filepaths) {
    super(
      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
        ", "
      )}`
    );
    this.code = this.name = CheckoutConflictError.code;
    this.data = { filepaths };
  }
}
CheckoutConflictError.code = "CheckoutConflictError";
class CommitNotFetchedError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} oid
   */
  constructor(ref, oid) {
    super(
      `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
    );
    this.code = this.name = CommitNotFetchedError.code;
    this.data = { ref, oid };
  }
}
CommitNotFetchedError.code = "CommitNotFetchedError";
class EmptyServerResponseError extends BaseError {
  constructor() {
    super(`Empty response from git server.`);
    this.code = this.name = EmptyServerResponseError.code;
    this.data = {};
  }
}
EmptyServerResponseError.code = "EmptyServerResponseError";
class FastForwardError extends BaseError {
  constructor() {
    super(`A simple fast-forward merge was not possible.`);
    this.code = this.name = FastForwardError.code;
    this.data = {};
  }
}
FastForwardError.code = "FastForwardError";
class GitPushError extends BaseError {
  /**
   * @param {string} prettyDetails
   * @param {PushResult} result
   */
  constructor(prettyDetails, result) {
    super(`One or more branches were not updated: ${prettyDetails}`);
    this.code = this.name = GitPushError.code;
    this.data = { prettyDetails, result };
  }
}
GitPushError.code = "GitPushError";
class HttpError extends BaseError {
  /**
   * @param {number} statusCode
   * @param {string} statusMessage
   * @param {string} response
   */
  constructor(statusCode, statusMessage, response) {
    super(`HTTP Error: ${statusCode} ${statusMessage}`);
    this.code = this.name = HttpError.code;
    this.data = { statusCode, statusMessage, response };
  }
}
HttpError.code = "HttpError";
class InvalidFilepathError extends BaseError {
  /**
   * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
   */
  constructor(reason) {
    let message = "invalid filepath";
    if (reason === "leading-slash" || reason === "trailing-slash") {
      message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
    } else if (reason === "directory") {
      message = `"filepath" should not be a directory.`;
    }
    super(message);
    this.code = this.name = InvalidFilepathError.code;
    this.data = { reason };
  }
}
InvalidFilepathError.code = "InvalidFilepathError";
class InvalidRefNameError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} suggestion
   * @param {boolean} canForce
   */
  constructor(ref, suggestion) {
    super(
      `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
    );
    this.code = this.name = InvalidRefNameError.code;
    this.data = { ref, suggestion };
  }
}
InvalidRefNameError.code = "InvalidRefNameError";
class MaxDepthError extends BaseError {
  /**
   * @param {number} depth
   */
  constructor(depth) {
    super(`Maximum search depth of ${depth} exceeded.`);
    this.code = this.name = MaxDepthError.code;
    this.data = { depth };
  }
}
MaxDepthError.code = "MaxDepthError";
class MergeNotSupportedError extends BaseError {
  constructor() {
    super(`Merges with conflicts are not supported yet.`);
    this.code = this.name = MergeNotSupportedError.code;
    this.data = {};
  }
}
MergeNotSupportedError.code = "MergeNotSupportedError";
class MergeConflictError extends BaseError {
  /**
   * @param {Array<string>} filepaths
   * @param {Array<string>} bothModified
   * @param {Array<string>} deleteByUs
   * @param {Array<string>} deleteByTheirs
   */
  constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {
    super(
      `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
    );
    this.code = this.name = MergeConflictError.code;
    this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };
  }
}
MergeConflictError.code = "MergeConflictError";
class MissingNameError extends BaseError {
  /**
   * @param {'author'|'committer'|'tagger'} role
   */
  constructor(role) {
    super(
      `No name was provided for ${role} in the argument or in the .git/config file.`
    );
    this.code = this.name = MissingNameError.code;
    this.data = { role };
  }
}
MissingNameError.code = "MissingNameError";
class MissingParameterError extends BaseError {
  /**
   * @param {string} parameter
   */
  constructor(parameter) {
    super(
      `The function requires a "${parameter}" parameter but none was provided.`
    );
    this.code = this.name = MissingParameterError.code;
    this.data = { parameter };
  }
}
MissingParameterError.code = "MissingParameterError";
class MultipleGitError extends BaseError {
  /**
   * @param {Error[]} errors
   * @param {string} message
   */
  constructor(errors) {
    super(
      `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
    );
    this.code = this.name = MultipleGitError.code;
    this.data = { errors };
    this.errors = errors;
  }
}
MultipleGitError.code = "MultipleGitError";
class ParseError extends BaseError {
  /**
   * @param {string} expected
   * @param {string} actual
   */
  constructor(expected, actual) {
    super(`Expected "${expected}" but received "${actual}".`);
    this.code = this.name = ParseError.code;
    this.data = { expected, actual };
  }
}
ParseError.code = "ParseError";
class PushRejectedError extends BaseError {
  /**
   * @param {'not-fast-forward'|'tag-exists'} reason
   */
  constructor(reason) {
    let message = "";
    if (reason === "not-fast-forward") {
      message = " because it was not a simple fast-forward";
    } else if (reason === "tag-exists") {
      message = " because tag already exists";
    }
    super(`Push rejected${message}. Use "force: true" to override.`);
    this.code = this.name = PushRejectedError.code;
    this.data = { reason };
  }
}
PushRejectedError.code = "PushRejectedError";
class RemoteCapabilityError extends BaseError {
  /**
   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
   * @param {'depth'|'since'|'exclude'|'relative'} parameter
   */
  constructor(capability, parameter) {
    super(
      `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
    );
    this.code = this.name = RemoteCapabilityError.code;
    this.data = { capability, parameter };
  }
}
RemoteCapabilityError.code = "RemoteCapabilityError";
class SmartHttpError extends BaseError {
  /**
   * @param {string} preview
   * @param {string} response
   */
  constructor(preview, response) {
    super(
      `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
    );
    this.code = this.name = SmartHttpError.code;
    this.data = { preview, response };
  }
}
SmartHttpError.code = "SmartHttpError";
class UnknownTransportError extends BaseError {
  /**
   * @param {string} url
   * @param {string} transport
   * @param {string} [suggestion]
   */
  constructor(url, transport, suggestion) {
    super(
      `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
    );
    this.code = this.name = UnknownTransportError.code;
    this.data = { url, transport, suggestion };
  }
}
UnknownTransportError.code = "UnknownTransportError";
class UrlParseError extends BaseError {
  /**
   * @param {string} url
   */
  constructor(url) {
    super(`Cannot parse remote URL: "${url}"`);
    this.code = this.name = UrlParseError.code;
    this.data = { url };
  }
}
UrlParseError.code = "UrlParseError";
class UserCanceledError extends BaseError {
  constructor() {
    super(`The operation was canceled.`);
    this.code = this.name = UserCanceledError.code;
    this.data = {};
  }
}
UserCanceledError.code = "UserCanceledError";
class IndexResetError extends BaseError {
  /**
   * @param {Array<string>} filepaths
   */
  constructor(filepath) {
    super(
      `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`
    );
    this.code = this.name = IndexResetError.code;
    this.data = { filepath };
  }
}
IndexResetError.code = "IndexResetError";
var Errors = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AlreadyExistsError,
  AmbiguousError,
  CheckoutConflictError,
  CommitNotFetchedError,
  EmptyServerResponseError,
  FastForwardError,
  GitPushError,
  HttpError,
  InternalError,
  InvalidFilepathError,
  InvalidOidError,
  InvalidRefNameError,
  MaxDepthError,
  MergeNotSupportedError,
  MergeConflictError,
  MissingNameError,
  MissingParameterError,
  MultipleGitError,
  NoRefspecError,
  NotFoundError,
  ObjectTypeError,
  ParseError,
  PushRejectedError,
  RemoteCapabilityError,
  SmartHttpError,
  UnknownTransportError,
  UnsafeFilepathError,
  UrlParseError,
  UserCanceledError,
  UnmergedPathsError,
  IndexResetError
});
function formatAuthor({ name, email, timestamp: timestamp2, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp2} ${timezoneOffset}`;
}
function formatTimezoneOffset(minutes) {
  const sign = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / 60);
  minutes -= hours * 60;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < 2)
    strHours = "0" + strHours;
  if (strMinutes.length < 2)
    strMinutes = "0" + strMinutes;
  return (sign === -1 ? "-" : "+") + strHours + strMinutes;
}
function simpleSign(n) {
  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1);
}
function negateExceptForZero(n) {
  return n === 0 ? n : -n;
}
function normalizeNewlines(str2) {
  str2 = str2.replace(/\r/g, "");
  str2 = str2.replace(/^\n+/, "");
  str2 = str2.replace(/\n+$/, "") + "\n";
  return str2;
}
function parseAuthor(author) {
  const [, name, email, timestamp2, offset] = author.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name,
    email,
    timestamp: Number(timestamp2),
    timezoneOffset: parseTimezoneOffset(offset)
  };
}
function parseTimezoneOffset(offset) {
  let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
  return negateExceptForZero$1(minutes);
}
function negateExceptForZero$1(n) {
  return n === 0 ? n : -n;
}
class GitAnnotatedTag {
  constructor(tag2) {
    if (typeof tag2 === "string") {
      this._tag = tag2;
    } else if (Buffer.isBuffer(tag2)) {
      this._tag = tag2.toString("utf8");
    } else if (typeof tag2 === "object") {
      this._tag = GitAnnotatedTag.render(tag2);
    } else {
      throw new InternalError(
        "invalid type passed to GitAnnotatedTag constructor"
      );
    }
  }
  static from(tag2) {
    return new GitAnnotatedTag(tag2);
  }
  static render(obj) {
    return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
  }
  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf("\n\n"));
  }
  message() {
    const tag2 = this.withoutSignature();
    return tag2.slice(tag2.indexOf("\n\n") + 2);
  }
  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig()
    });
  }
  render() {
    return this._tag;
  }
  headers() {
    const headers = this.justHeaders().split("\n");
    const hs = [];
    for (const h of headers) {
      if (h[0] === " ") {
        hs[hs.length - 1] += "\n" + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {};
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(" "));
      const value2 = h.slice(h.indexOf(" ") + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value2);
      } else {
        obj[key] = value2;
      }
    }
    if (obj.tagger) {
      obj.tagger = parseAuthor(obj.tagger);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj;
  }
  withoutSignature() {
    const tag2 = normalizeNewlines(this._tag);
    if (tag2.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
      return tag2;
    return tag2.slice(0, tag2.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
  }
  gpgsig() {
    if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
      return;
    const signature = this._tag.slice(
      this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
    );
    return normalizeNewlines(signature);
  }
  payload() {
    return this.withoutSignature() + "\n";
  }
  toObject() {
    return Buffer.from(this._tag, "utf8");
  }
  static async sign(tag2, sign, secretKey) {
    const payload = tag2.payload();
    let { signature } = await sign({ payload, secretKey });
    signature = normalizeNewlines(signature);
    const signedTag = payload + signature;
    return GitAnnotatedTag.from(signedTag);
  }
}
function indent$1(str2) {
  return str2.trim().split("\n").map((x) => " " + x).join("\n") + "\n";
}
function outdent(str2) {
  return str2.split("\n").map((x) => x.replace(/^ /, "")).join("\n");
}
class GitCommit {
  constructor(commit2) {
    if (typeof commit2 === "string") {
      this._commit = commit2;
    } else if (Buffer.isBuffer(commit2)) {
      this._commit = commit2.toString("utf8");
    } else if (typeof commit2 === "object") {
      this._commit = GitCommit.render(commit2);
    } else {
      throw new InternalError("invalid type passed to GitCommit constructor");
    }
  }
  static fromPayloadSignature({ payload, signature }) {
    const headers = GitCommit.justHeaders(payload);
    const message = GitCommit.justMessage(payload);
    const commit2 = normalizeNewlines(
      headers + "\ngpgsig" + indent$1(signature) + "\n" + message
    );
    return new GitCommit(commit2);
  }
  static from(commit2) {
    return new GitCommit(commit2);
  }
  toObject() {
    return Buffer.from(this._commit, "utf8");
  }
  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders();
  }
  // Todo: allow setting the headers and message
  message() {
    return GitCommit.justMessage(this._commit);
  }
  parse() {
    return Object.assign({ message: this.message() }, this.headers());
  }
  static justMessage(commit2) {
    return normalizeNewlines(commit2.slice(commit2.indexOf("\n\n") + 2));
  }
  static justHeaders(commit2) {
    return commit2.slice(0, commit2.indexOf("\n\n"));
  }
  parseHeaders() {
    const headers = GitCommit.justHeaders(this._commit).split("\n");
    const hs = [];
    for (const h of headers) {
      if (h[0] === " ") {
        hs[hs.length - 1] += "\n" + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {
      parent: []
    };
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(" "));
      const value2 = h.slice(h.indexOf(" ") + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value2);
      } else {
        obj[key] = value2;
      }
    }
    if (obj.author) {
      obj.author = parseAuthor(obj.author);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj;
  }
  static renderHeaders(obj) {
    let headers = "";
    if (obj.tree) {
      headers += `tree ${obj.tree}
`;
    } else {
      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`;
    }
    if (obj.parent) {
      if (obj.parent.length === void 0) {
        throw new InternalError(`commit 'parent' property should be an array`);
      }
      for (const p of obj.parent) {
        headers += `parent ${p}
`;
      }
    }
    const author = obj.author;
    headers += `author ${formatAuthor(author)}
`;
    const committer = obj.committer || obj.author;
    headers += `committer ${formatAuthor(committer)}
`;
    if (obj.gpgsig) {
      headers += "gpgsig" + indent$1(obj.gpgsig);
    }
    return headers;
  }
  static render(obj) {
    return GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message);
  }
  render() {
    return this._commit;
  }
  withoutSignature() {
    const commit2 = normalizeNewlines(this._commit);
    if (commit2.indexOf("\ngpgsig") === -1)
      return commit2;
    const headers = commit2.slice(0, commit2.indexOf("\ngpgsig"));
    const message = commit2.slice(
      commit2.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length
    );
    return normalizeNewlines(headers + "\n" + message);
  }
  isolateSignature() {
    const signature = this._commit.slice(
      this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
    );
    return outdent(signature);
  }
  static async sign(commit2, sign, secretKey) {
    const payload = commit2.withoutSignature();
    const message = GitCommit.justMessage(commit2._commit);
    let { signature } = await sign({ payload, secretKey });
    signature = normalizeNewlines(signature);
    const headers = GitCommit.justHeaders(commit2._commit);
    const signedCommit = headers + "\ngpgsig" + indent$1(signature) + "\n" + message;
    return GitCommit.from(signedCommit);
  }
}
async function resolveTree({ fs, cache: cache2, gitdir, oid }) {
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    return { tree: GitTree.from([]), oid };
  }
  const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
  if (type2 === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache: cache2, gitdir, oid });
  }
  if (type2 === "commit") {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache: cache2, gitdir, oid });
  }
  if (type2 !== "tree") {
    throw new ObjectTypeError(oid, type2, "tree");
  }
  return { tree: GitTree.from(object), oid };
}
class GitWalkerRepo {
  constructor({ fs, gitdir, ref, cache: cache2 }) {
    this.fs = fs;
    this.cache = cache2;
    this.gitdir = gitdir;
    this.mapPromise = (async () => {
      const map2 = /* @__PURE__ */ new Map();
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref });
      } catch (e) {
        if (e instanceof NotFoundError) {
          oid = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
        }
      }
      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
      tree.type = "tree";
      tree.mode = "40000";
      map2.set(".", tree);
      return map2;
    })();
    const walker = this;
    this.ConstructEntry = class TreeEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, cache: cache2, gitdir } = this;
    const map2 = await this.mapPromise;
    const obj = map2.get(filepath);
    if (!obj)
      throw new Error(`No obj for ${filepath}`);
    const oid = obj.oid;
    if (!oid)
      throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
    if (obj.type !== "tree") {
      return null;
    }
    const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
    if (type2 !== obj.type) {
      throw new ObjectTypeError(oid, type2, obj.type);
    }
    const tree = GitTree.from(object);
    for (const entry2 of tree) {
      map2.set(join$2(filepath, entry2.path), entry2);
    }
    return tree.entries().map((entry2) => join$2(filepath, entry2.path));
  }
  async type(entry) {
    if (entry._type === false) {
      const map2 = await this.mapPromise;
      const { type: type2 } = map2.get(entry._fullpath);
      entry._type = type2;
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      const map2 = await this.mapPromise;
      const { mode } = map2.get(entry._fullpath);
      entry._mode = normalizeMode(parseInt(mode, 8));
    }
    return entry._mode;
  }
  async stat(_entry) {
  }
  async content(entry) {
    if (entry._content === false) {
      const map2 = await this.mapPromise;
      const { fs, cache: cache2, gitdir } = this;
      const obj = map2.get(entry._fullpath);
      const oid = obj.oid;
      const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
      if (type2 !== "blob") {
        entry._content = void 0;
      } else {
        entry._content = new Uint8Array(object);
      }
    }
    return entry._content;
  }
  async oid(entry) {
    if (entry._oid === false) {
      const map2 = await this.mapPromise;
      const obj = map2.get(entry._fullpath);
      entry._oid = obj.oid;
    }
    return entry._oid;
  }
}
function TREE$1({ ref = "HEAD" } = {}) {
  const o = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache: cache2 }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache: cache2 });
    }
  });
  Object.freeze(o);
  return o;
}
class GitWalkerFs {
  constructor({ fs, dir, gitdir, cache: cache2 }) {
    this.fs = fs;
    this.cache = cache2;
    this.dir = dir;
    this.gitdir = gitdir;
    const walker = this;
    this.ConstructEntry = class WorkdirEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, dir } = this;
    const names = await fs.readdir(join$2(dir, filepath));
    if (names === null)
      return null;
    return names.map((name) => join$2(filepath, name));
  }
  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode;
  }
  async stat(entry) {
    if (entry._stat === false) {
      const { fs, dir } = this;
      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
      if (!stat) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        );
      }
      let type2 = stat.isDirectory() ? "tree" : "blob";
      if (type2 === "blob" && !stat.isFile() && !stat.isSymbolicLink()) {
        type2 = "special";
      }
      entry._type = type2;
      stat = normalizeStats(stat);
      entry._mode = stat.mode;
      if (stat.size === -1 && entry._actualSize) {
        stat.size = entry._actualSize;
      }
      entry._stat = stat;
    }
    return entry._stat;
  }
  async content(entry) {
    if (entry._content === false) {
      const { fs, dir } = this;
      if (await entry.type() === "tree") {
        entry._content = void 0;
      } else {
        const content = await fs.read(`${dir}/${entry._fullpath}`);
        entry._actualSize = content.length;
        if (entry._stat && entry._stat.size === -1) {
          entry._stat.size = entry._actualSize;
        }
        entry._content = new Uint8Array(content);
      }
    }
    return entry._content;
  }
  async oid(entry) {
    if (entry._oid === false) {
      const { fs, gitdir, cache: cache2 } = this;
      let oid;
      await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
        const stage = index2.entriesMap.get(entry._fullpath);
        const stats = await entry.stat();
        if (!stage || compareStats(stats, stage)) {
          const content = await entry.content();
          if (content === void 0) {
            oid = void 0;
          } else {
            oid = await shasum(
              GitObject.wrap({ type: "blob", object: await entry.content() })
            );
            if (stage && oid === stage.oid && stats.mode === stage.mode && compareStats(stats, stage)) {
              index2.insert({
                filepath: entry._fullpath,
                stats,
                oid
              });
            }
          }
        } else {
          oid = stage.oid;
        }
      });
      entry._oid = oid;
    }
    return entry._oid;
  }
}
function WORKDIR$1() {
  const o = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, dir, gitdir, cache: cache2 }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache: cache2 });
    }
  });
  Object.freeze(o);
  return o;
}
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_, i) => start + i);
}
const flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x) => acc.concat(x), []) : (entries) => entries.flat();
class RunningMinimum {
  constructor() {
    this.value = null;
  }
  consider(value2) {
    if (value2 === null || value2 === void 0)
      return;
    if (this.value === null) {
      this.value = value2;
    } else if (value2 < this.value) {
      this.value = value2;
    }
  }
  reset() {
    this.value = null;
  }
}
function* unionOfIterators(sets) {
  const min = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i = 0; i < numsets; i++) {
    heads[i] = sets[i].next().value;
    if (heads[i] !== void 0) {
      min.consider(heads[i]);
    }
  }
  if (min.value === null)
    return;
  while (true) {
    const result = [];
    minimum = min.value;
    min.reset();
    for (let i = 0; i < numsets; i++) {
      if (heads[i] !== void 0 && heads[i] === minimum) {
        result[i] = heads[i];
        heads[i] = sets[i].next().value;
      } else {
        result[i] = null;
      }
      if (heads[i] !== void 0) {
        min.consider(heads[i]);
      }
    }
    yield result;
    if (min.value === null)
      return;
  }
}
async function _walk({
  fs,
  cache: cache2,
  dir,
  gitdir,
  trees: trees2,
  // @ts-ignore
  map: map2 = async (_, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== void 0)
      flatten.unshift(parent);
    return flatten;
  },
  // The default iterate function walks all children concurrently
  iterate = (walk2, children) => Promise.all([...children].map(walk2))
}) {
  const walkers = trees2.map(
    (proxy) => proxy[GitWalkSymbol]({ fs, dir, gitdir, cache: cache2 })
  );
  const root = new Array(walkers.length).fill(".");
  const range = arrayRange(0, walkers.length);
  const unionWalkerFromReaddir = async (entries) => {
    range.map((i) => {
      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);
    });
    const subdirs = await Promise.all(
      range.map((i) => entries[i] ? walkers[i].readdir(entries[i]) : [])
    );
    const iterators = subdirs.map((array2) => array2 === null ? [] : array2).map((array2) => array2[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators)
    };
  };
  const walk2 = async (root2) => {
    const { entries, children } = await unionWalkerFromReaddir(root2);
    const fullpath = entries.find((entry) => entry && entry._fullpath)._fullpath;
    const parent = await map2(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk2, children);
      walkedChildren = walkedChildren.filter((x) => x !== void 0);
      return reduce(parent, walkedChildren);
    }
  };
  return walk2(root);
}
async function rmRecursive(fs, filepath) {
  const entries = await fs.readdir(filepath);
  if (entries == null) {
    await fs.rm(filepath);
  } else if (entries.length) {
    await Promise.all(
      entries.map((entry) => {
        const subpath = join$2(filepath, entry);
        return fs.lstat(subpath).then((stat) => {
          if (!stat)
            return;
          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);
        });
      })
    ).then(() => fs.rmdir(filepath));
  } else {
    await fs.rmdir(filepath);
  }
}
function isPromiseLike(obj) {
  return isObject$6(obj) && isFunction$2(obj.then) && isFunction$2(obj.catch);
}
function isObject$6(obj) {
  return obj && typeof obj === "object";
}
function isFunction$2(obj) {
  return typeof obj === "function";
}
function isPromiseFs(fs) {
  const test = (targetFs) => {
    try {
      return targetFs.readFile().catch((e) => e);
    } catch (e) {
      return e;
    }
  };
  return isPromiseLike(test(fs));
}
const commands = [
  "readFile",
  "writeFile",
  "mkdir",
  "rmdir",
  "unlink",
  "stat",
  "lstat",
  "readdir",
  "readlink",
  "symlink"
];
function bindFs(target, fs) {
  if (isPromiseFs(fs)) {
    for (const command of commands) {
      target[`_${command}`] = fs[command].bind(fs);
    }
  } else {
    for (const command of commands) {
      target[`_${command}`] = pify$1(fs[command].bind(fs));
    }
  }
  if (isPromiseFs(fs)) {
    if (fs.rm)
      target._rm = fs.rm.bind(fs);
    else if (fs.rmdir.length > 1)
      target._rm = fs.rmdir.bind(fs);
    else
      target._rm = rmRecursive.bind(null, target);
  } else {
    if (fs.rm)
      target._rm = pify$1(fs.rm.bind(fs));
    else if (fs.rmdir.length > 2)
      target._rm = pify$1(fs.rmdir.bind(fs));
    else
      target._rm = rmRecursive.bind(null, target);
  }
}
class FileSystem {
  constructor(fs) {
    if (typeof fs._original_unwrapped_fs !== "undefined")
      return fs;
    const promises = Object.getOwnPropertyDescriptor(fs, "promises");
    if (promises && promises.enumerable) {
      bindFs(this, fs.promises);
    } else {
      bindFs(this, fs);
    }
    this._original_unwrapped_fs = fs;
  }
  /**
   * Return true if a file exists, false if it doesn't exist.
   * Rethrows errors that aren't related to file existence.
   */
  async exists(filepath, options = {}) {
    try {
      await this._stat(filepath);
      return true;
    } catch (err2) {
      if (err2.code === "ENOENT" || err2.code === "ENOTDIR") {
        return false;
      } else {
        console.log('Unhandled error in "FileSystem.exists()" function', err2);
        throw err2;
      }
    }
  }
  /**
   * Return the contents of a file if it exists, otherwise returns null.
   *
   * @param {string} filepath
   * @param {object} [options]
   *
   * @returns {Promise<Buffer|string|null>}
   */
  async read(filepath, options = {}) {
    try {
      let buffer = await this._readFile(filepath, options);
      if (typeof buffer !== "string") {
        buffer = Buffer.from(buffer);
      }
      return buffer;
    } catch (err2) {
      return null;
    }
  }
  /**
   * Write a file (creating missing directories if need be) without throwing errors.
   *
   * @param {string} filepath
   * @param {Buffer|Uint8Array|string} contents
   * @param {object|string} [options]
   */
  async write(filepath, contents, options = {}) {
    try {
      await this._writeFile(filepath, contents, options);
      return;
    } catch (err2) {
      await this.mkdir(dirname(filepath));
      await this._writeFile(filepath, contents, options);
    }
  }
  /**
   * Make a directory (or series of nested directories) without throwing an error if it already exists.
   */
  async mkdir(filepath, _selfCall = false) {
    try {
      await this._mkdir(filepath);
      return;
    } catch (err2) {
      if (err2 === null)
        return;
      if (err2.code === "EEXIST")
        return;
      if (_selfCall)
        throw err2;
      if (err2.code === "ENOENT") {
        const parent = dirname(filepath);
        if (parent === "." || parent === "/" || parent === filepath)
          throw err2;
        await this.mkdir(parent);
        await this.mkdir(filepath, true);
      }
    }
  }
  /**
   * Delete a file without throwing an error if it is already deleted.
   */
  async rm(filepath) {
    try {
      await this._unlink(filepath);
    } catch (err2) {
      if (err2.code !== "ENOENT")
        throw err2;
    }
  }
  /**
   * Delete a directory without throwing an error if it is already deleted.
   */
  async rmdir(filepath, opts) {
    try {
      if (opts && opts.recursive) {
        await this._rm(filepath, opts);
      } else {
        await this._rmdir(filepath);
      }
    } catch (err2) {
      if (err2.code !== "ENOENT")
        throw err2;
    }
  }
  /**
   * Read a directory without throwing an error is the directory doesn't exist
   */
  async readdir(filepath) {
    try {
      const names = await this._readdir(filepath);
      names.sort(compareStrings);
      return names;
    } catch (err2) {
      if (err2.code === "ENOTDIR")
        return null;
      return [];
    }
  }
  /**
   * Return a flast list of all the files nested inside a directory
   *
   * Based on an elegant concurrent recursive solution from SO
   * https://stackoverflow.com/a/45130990/2168416
   */
  async readdirDeep(dir) {
    const subdirs = await this._readdir(dir);
    const files = await Promise.all(
      subdirs.map(async (subdir) => {
        const res2 = dir + "/" + subdir;
        return (await this._stat(res2)).isDirectory() ? this.readdirDeep(res2) : res2;
      })
    );
    return files.reduce((a, f) => a.concat(f), []);
  }
  /**
   * Return the Stats of a file/symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existence.
   */
  async lstat(filename) {
    try {
      const stats = await this._lstat(filename);
      return stats;
    } catch (err2) {
      if (err2.code === "ENOENT") {
        return null;
      }
      throw err2;
    }
  }
  /**
   * Reads the contents of a symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existence.
   */
  async readlink(filename, opts = { encoding: "buffer" }) {
    try {
      const link = await this._readlink(filename, opts);
      return Buffer.isBuffer(link) ? link : Buffer.from(link);
    } catch (err2) {
      if (err2.code === "ENOENT") {
        return null;
      }
      throw err2;
    }
  }
  /**
   * Write the contents of buffer to a symlink.
   */
  async writelink(filename, buffer) {
    return this._symlink(buffer.toString("utf8"), filename);
  }
}
function assertParameter(name, value2) {
  if (value2 === void 0) {
    throw new MissingParameterError(name);
  }
}
async function modified(entry, base) {
  if (!entry && !base)
    return false;
  if (entry && !base)
    return true;
  if (!entry && base)
    return true;
  if (await entry.type() === "tree" && await base.type() === "tree") {
    return false;
  }
  if (await entry.type() === await base.type() && await entry.mode() === await base.mode() && await entry.oid() === await base.oid()) {
    return false;
  }
  return true;
}
async function abortMerge({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  commit: commit2 = "HEAD",
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const trees2 = [TREE$1({ ref: commit2 }), WORKDIR$1(), STAGE$1()];
    let unmergedPaths = [];
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      unmergedPaths = index2.unmergedPaths;
    });
    const results2 = await _walk({
      fs,
      cache: cache2,
      dir,
      gitdir,
      trees: trees2,
      map: async function(path, [head, workdir, index2]) {
        const staged = !await modified(workdir, index2);
        const unmerged = unmergedPaths.includes(path);
        const unmodified = !await modified(index2, head);
        if (staged || unmerged) {
          return head ? {
            path,
            mode: await head.mode(),
            oid: await head.oid(),
            type: await head.type(),
            content: await head.content()
          } : void 0;
        }
        if (unmodified)
          return false;
        else
          throw new IndexResetError(path);
      }
    });
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      for (const entry of results2) {
        if (entry === false)
          continue;
        if (!entry) {
          await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });
          index2.delete({ filepath: entry.path });
          continue;
        }
        if (entry.type === "blob") {
          const content = new TextDecoder().decode(entry.content);
          await fs.write(`${dir}/${entry.path}`, content, { mode: entry.mode });
          index2.insert({
            filepath: entry.path,
            oid: entry.oid,
            stage: 0
          });
        }
      }
    });
  } catch (err2) {
    err2.caller = "git.abortMerge";
    throw err2;
  }
}
class GitIgnoreManager {
  static async isIgnored({ fs, dir, gitdir = join$2(dir, ".git"), filepath }) {
    if (basename(filepath) === ".git")
      return true;
    if (filepath === ".")
      return false;
    let excludes = "";
    const excludesFile = join$2(gitdir, "info", "exclude");
    if (await fs.exists(excludesFile)) {
      excludes = await fs.read(excludesFile, "utf8");
    }
    const pairs2 = [
      {
        gitignore: join$2(dir, ".gitignore"),
        filepath
      }
    ];
    const pieces = filepath.split("/").filter(Boolean);
    for (let i = 1; i < pieces.length; i++) {
      const folder = pieces.slice(0, i).join("/");
      const file = pieces.slice(i).join("/");
      pairs2.push({
        gitignore: join$2(dir, folder, ".gitignore"),
        filepath: file
      });
    }
    let ignoredStatus = false;
    for (const p of pairs2) {
      let file;
      try {
        file = await fs.read(p.gitignore, "utf8");
      } catch (err2) {
        if (err2.code === "NOENT")
          continue;
      }
      const ign = ignore$1().add(excludes);
      ign.add(file);
      const parentdir = dirname(p.filepath);
      if (parentdir !== "." && ign.ignores(parentdir))
        return true;
      if (ignoredStatus) {
        ignoredStatus = !ign.test(p.filepath).unignored;
      } else {
        ignoredStatus = ign.test(p.filepath).ignored;
      }
    }
    return ignoredStatus;
  }
}
async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== "deflated") {
    throw new InternalError(
      "GitObjectStoreLoose expects objects to write to be in deflated format"
    );
  }
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const filepath = `${gitdir}/${source}`;
  if (!await fs.exists(filepath))
    await fs.write(filepath, object);
}
let supportsCompressionStream = null;
async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream ? browserDeflate(buffer) : pako$1.deflate(buffer);
}
async function browserDeflate(buffer) {
  const cs = new CompressionStream("deflate");
  const c2 = new Blob([buffer]).stream().pipeThrough(cs);
  return new Uint8Array(await new Response(c2).arrayBuffer());
}
function testCompressionStream() {
  try {
    const cs = new CompressionStream("deflate");
    cs.writable.close();
    const stream = new Blob([]).stream();
    stream.cancel();
    return true;
  } catch (_) {
    return false;
  }
}
async function _writeObject({
  fs,
  gitdir,
  type: type2,
  object,
  format = "content",
  oid = void 0,
  dryRun = false
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type: type2, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: "deflated", oid });
  }
  return oid;
}
function posixifyPathBuffer(buffer) {
  let idx;
  while (~(idx = buffer.indexOf(92)))
    buffer[idx] = 47;
  return buffer;
}
async function add$4({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  cache: cache2 = {},
  force = false,
  parallel = true
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async (index2) => {
      return addToIndex({
        dir,
        gitdir,
        fs,
        filepath,
        index: index2,
        force,
        parallel
      });
    });
  } catch (err2) {
    err2.caller = "git.add";
    throw err2;
  }
}
async function addToIndex({
  dir,
  gitdir,
  fs,
  filepath,
  index: index2,
  force,
  parallel
}) {
  filepath = Array.isArray(filepath) ? filepath : [filepath];
  const promises = filepath.map(async (currentFilepath) => {
    if (!force) {
      const ignored = await GitIgnoreManager.isIgnored({
        fs,
        dir,
        gitdir,
        filepath: currentFilepath
      });
      if (ignored)
        return;
    }
    const stats = await fs.lstat(join$2(dir, currentFilepath));
    if (!stats)
      throw new NotFoundError(currentFilepath);
    if (stats.isDirectory()) {
      const children = await fs.readdir(join$2(dir, currentFilepath));
      if (parallel) {
        const promises2 = children.map(
          (child) => addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join$2(currentFilepath, child)],
            index: index2,
            force,
            parallel
          })
        );
        await Promise.all(promises2);
      } else {
        for (const child of children) {
          await addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join$2(currentFilepath, child)],
            index: index2,
            force,
            parallel
          });
        }
      }
    } else {
      const object = stats.isSymbolicLink() ? await fs.readlink(join$2(dir, currentFilepath)).then(posixifyPathBuffer) : await fs.read(join$2(dir, currentFilepath));
      if (object === null)
        throw new NotFoundError(currentFilepath);
      const oid = await _writeObject({ fs, gitdir, type: "blob", object });
      index2.insert({ filepath: currentFilepath, stats, oid });
    }
  });
  const settledPromises = await Promise.allSettled(promises);
  const rejectedPromises = settledPromises.filter((settle) => settle.status === "rejected").map((settle) => settle.reason);
  if (rejectedPromises.length > 1) {
    throw new MultipleGitError(rejectedPromises);
  }
  if (rejectedPromises.length === 1) {
    throw rejectedPromises[0];
  }
  const fulfilledPromises = settledPromises.filter((settle) => settle.status === "fulfilled" && settle.value).map((settle) => settle.value);
  return fulfilledPromises;
}
async function _commit({
  fs,
  cache: cache2,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: "HEAD",
      depth: 2
    });
  }
  return GitIndexManager.acquire(
    { fs, gitdir, cache: cache2, allowUnmerged: false },
    async function(index2) {
      const inodes = flatFileListToDirectoryStructure(index2.entries);
      const inode = inodes.get(".");
      if (!tree) {
        tree = await constructTree({ fs, gitdir, inode, dryRun });
      }
      if (!parent) {
        try {
          parent = [
            await GitRefManager.resolve({
              fs,
              gitdir,
              ref
            })
          ];
        } catch (err2) {
          parent = [];
        }
      } else {
        parent = await Promise.all(
          parent.map((p) => {
            return GitRefManager.resolve({ fs, gitdir, ref: p });
          })
        );
      }
      let comm = GitCommit.from({
        tree,
        parent,
        author,
        committer,
        message
      });
      if (signingKey) {
        comm = await GitCommit.sign(comm, onSign, signingKey);
      }
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "commit",
        object: comm.toObject(),
        dryRun
      });
      if (!noUpdateBranch && !dryRun) {
        await GitRefManager.writeRef({
          fs,
          gitdir,
          ref,
          value: oid
        });
      }
      return oid;
    }
  );
}
async function constructTree({ fs, gitdir, inode, dryRun }) {
  const children = inode.children;
  for (const inode2 of children) {
    if (inode2.type === "tree") {
      inode2.metadata.mode = "040000";
      inode2.metadata.oid = await constructTree({ fs, gitdir, inode: inode2, dryRun });
    }
  }
  const entries = children.map((inode2) => ({
    mode: inode2.metadata.mode,
    path: inode2.basename,
    oid: inode2.metadata.oid,
    type: inode2.type
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object: tree.toObject(),
    dryRun
  });
  return oid;
}
async function resolveFilepath({ fs, cache: cache2, gitdir, oid, filepath }) {
  if (filepath.startsWith("/")) {
    throw new InvalidFilepathError("leading-slash");
  } else if (filepath.endsWith("/")) {
    throw new InvalidFilepathError("trailing-slash");
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache: cache2, gitdir, oid });
  const tree = result.tree;
  if (filepath === "") {
    oid = result.oid;
  } else {
    const pathArray = filepath.split("/");
    oid = await _resolveFilepath({
      fs,
      cache: cache2,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath
    });
  }
  return oid;
}
async function _resolveFilepath({
  fs,
  cache: cache2,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === 0) {
        return entry.oid;
      } else {
        const { type: type2, object } = await _readObject({
          fs,
          cache: cache2,
          gitdir,
          oid: entry.oid
        });
        if (type2 !== "tree") {
          throw new ObjectTypeError(oid, type2, "tree", filepath);
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache: cache2,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath
        });
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
}
async function _readTree({
  fs,
  cache: cache2,
  gitdir,
  oid,
  filepath = void 0
}) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache: cache2, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache: cache2, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries()
  };
  return result;
}
async function _writeTree({ fs, gitdir, tree }) {
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object,
    format: "content"
  });
  return oid;
}
async function _addNote({
  fs,
  cache: cache2,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err2) {
    if (!(err2 instanceof NotFoundError)) {
      throw err2;
    }
  }
  const result = await _readTree({
    fs,
    cache: cache2,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  });
  let tree = result.tree;
  if (force) {
    tree = tree.filter((entry) => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError("note", oid);
      }
    }
  }
  if (typeof note === "string") {
    note = Buffer.from(note, "utf8");
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: note,
    format: "content"
  });
  tree.push({ mode: "100644", path: oid, oid: noteOid, type: "blob" });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache: cache2,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function _getConfig({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path);
}
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp: timestamp2, timezoneOffset } = author;
  name = name || await _getConfig({ fs, gitdir, path: "user.name" });
  email = email || await _getConfig({ fs, gitdir, path: "user.email" }) || "";
  if (name === void 0) {
    return void 0;
  }
  timestamp2 = timestamp2 != null ? timestamp2 : Math.floor(Date.now() / 1e3);
  timezoneOffset = timezoneOffset != null ? timezoneOffset : new Date(timestamp2 * 1e3).getTimezoneOffset();
  return { name, email, timestamp: timestamp2, timezoneOffset };
}
async function normalizeCommitterObject({
  fs,
  gitdir,
  author,
  committer
}) {
  committer = Object.assign({}, committer || author);
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer;
}
async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join$2(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("note", note);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _addNote({
      fs: new FileSystem(fs),
      cache: cache2,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey
    });
  } catch (err2) {
    err2.caller = "git.addNote";
    throw err2;
  }
}
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== cleanGitRef.clean(remote)) {
    throw new InvalidRefNameError(remote, cleanGitRef.clean(remote));
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    const remoteNames = await config.getSubsections("remote");
    if (remoteNames.includes(remote)) {
      if (url !== await config.get(`remote.${remote}.url`)) {
        throw new AlreadyExistsError("remote", remote);
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/*:refs/remotes/${remote}/*`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}
async function addRemote({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  remote,
  url,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("remote", remote);
    assertParameter("url", url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force
    });
  } catch (err2) {
    err2.caller = "git.addRemote";
    throw err2;
  }
}
async function _annotatedTag({
  fs,
  cache: cache2,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false
}) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
    throw new AlreadyExistsError("tag", ref);
  }
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || "HEAD"
  });
  const { type: type2 } = await _readObject({ fs, cache: cache2, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type: type2,
    tag: ref.replace("refs/tags/", ""),
    tagger,
    message,
    gpgsig
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value2 = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object: tagObject.toObject()
  });
  await GitRefManager.writeRef({ fs, gitdir, ref, value: value2 });
}
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger)
      throw new MissingNameError("tagger");
    return await _annotatedTag({
      fs,
      cache: cache2,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force
    });
  } catch (err2) {
    err2.caller = "git.annotatedTag";
    throw err2;
  }
}
async function _branch({
  fs,
  gitdir,
  ref,
  object,
  checkout: checkout2 = false,
  force = false
}) {
  if (ref !== cleanGitRef.clean(ref)) {
    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
  }
  const fullref = `refs/heads/${ref}`;
  if (!force) {
    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
    if (exist) {
      throw new AlreadyExistsError("branch", ref, false);
    }
  }
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || "HEAD" });
  } catch (e) {
  }
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }
  if (checkout2) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullref
    });
  }
}
async function branch({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  object,
  checkout: checkout2 = false,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      object,
      checkout: checkout2,
      force
    });
  } catch (err2) {
    err2.caller = "git.branch";
    throw err2;
  }
}
const worthWalking = (filepath, root) => {
  if (filepath === "." || root == null || root.length === 0 || root === "." || root === filepath) {
    return true;
  }
  if (root.length > filepath.length) {
    return root.startsWith(filepath + "/");
  } else {
    return filepath.startsWith(root + "/");
  }
};
async function _checkout$1({
  fs,
  cache: cache2,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
  track = true
}) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
  } catch (err2) {
    if (ref === "HEAD")
      throw err2;
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef
    });
    if (track) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid
    });
  }
  if (!noCheckout) {
    let ops;
    try {
      ops = await analyze$1({
        fs,
        cache: cache2,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths
      });
    } catch (err2) {
      if (err2 instanceof NotFoundError && err2.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid);
      } else {
        throw err2;
      }
    }
    const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new CheckoutConflictError(conflicts);
    }
    const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new InternalError(errors.join(", "));
    }
    if (dryRun) {
      return;
    }
    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "delete" || method === "delete-index"
        ).map(async function([method, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          if (method === "delete") {
            await fs.rm(filepath);
          }
          index2.delete({ filepath: fullpath });
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: ++count,
              total
            });
          }
        })
      );
    });
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      for (const [method, fullpath] of ops) {
        if (method === "rmdir" || method === "rmdir-index") {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === "rmdir-index") {
              index2.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            if (e.code === "ENOTEMPTY") {
              console.log(
                `Did not delete ${fullpath} because directory is not empty`
              );
            } else {
              throw e;
            }
          }
        }
      }
    });
    await Promise.all(
      ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_, fullpath]) {
        const filepath = `${dir}/${fullpath}`;
        await fs.mkdir(filepath);
        if (onProgress) {
          await onProgress({
            phase: "Updating workdir",
            loaded: ++count,
            total
          });
        }
      })
    );
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
        ).map(async function([method, fullpath, oid2, mode, chmod]) {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method !== "create-index" && method !== "mkdir-index") {
              const { object } = await _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
              if (chmod) {
                await fs.rm(filepath);
              }
              if (mode === 33188) {
                await fs.write(filepath, object);
              } else if (mode === 33261) {
                await fs.write(filepath, object, { mode: 511 });
              } else if (mode === 40960) {
                await fs.writelink(filepath, object);
              } else {
                throw new InternalError(
                  `Invalid mode 0o${mode.toString(8)} detected in blob ${oid2}`
                );
              }
            }
            const stats = await fs.lstat(filepath);
            if (mode === 33261) {
              stats.mode = 493;
            }
            if (method === "mkdir-index") {
              stats.mode = 57344;
            }
            index2.insert({
              filepath: fullpath,
              stats,
              oid: oid2
            });
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            console.log(e);
          }
        })
      );
    });
  }
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith("refs/heads")) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: "HEAD",
        value: fullRef
      });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
    }
  }
}
async function analyze$1({
  fs,
  cache: cache2,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths
}) {
  let count = 0;
  return _walk({
    fs,
    cache: cache2,
    dir,
    gitdir,
    trees: [TREE$1({ ref }), WORKDIR$1(), STAGE$1()],
    map: async function(fullpath, [commit2, workdir, stage]) {
      if (fullpath === ".")
        return;
      if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
        return null;
      }
      if (onProgress) {
        await onProgress({ phase: "Analyzing workdir", loaded: ++count });
      }
      const key = [!!stage, !!commit2, !!workdir].map(Number).join("");
      switch (key) {
        case "000":
          return;
        case "001":
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ["delete", fullpath];
          }
          return;
        case "010": {
          switch (await commit2.type()) {
            case "tree": {
              return ["mkdir", fullpath];
            }
            case "blob": {
              return [
                "create",
                fullpath,
                await commit2.oid(),
                await commit2.mode()
              ];
            }
            case "commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit2.oid(),
                await commit2.mode()
              ];
            }
            default: {
              return [
                "error",
                `new entry Unhandled type ${await commit2.type()}`
              ];
            }
          }
        }
        case "011": {
          switch (`${await commit2.type()}-${await workdir.type()}`) {
            case "tree-tree": {
              return;
            }
            case "tree-blob":
            case "blob-tree": {
              return ["conflict", fullpath];
            }
            case "blob-blob": {
              if (await commit2.oid() !== await workdir.oid()) {
                if (force) {
                  return [
                    "update",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode(),
                    await commit2.mode() !== await workdir.mode()
                  ];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                if (await commit2.mode() !== await workdir.mode()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      true
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                } else {
                  return [
                    "create-index",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
              }
            }
            case "commit-tree": {
              return;
            }
            case "commit-blob": {
              return ["conflict", fullpath];
            }
            default: {
              return ["error", `new entry Unhandled type ${commit2.type}`];
            }
          }
        }
        case "100": {
          return ["delete-index", fullpath];
        }
        case "101": {
          switch (await stage.type()) {
            case "tree": {
              return ["rmdir", fullpath];
            }
            case "blob": {
              if (await stage.oid() !== await workdir.oid()) {
                if (force) {
                  return ["delete", fullpath];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                return ["delete", fullpath];
              }
            }
            case "commit": {
              return ["rmdir-index", fullpath];
            }
            default: {
              return [
                "error",
                `delete entry Unhandled type ${await stage.type()}`
              ];
            }
          }
        }
        case "110":
        case "111": {
          switch (`${await stage.type()}-${await commit2.type()}`) {
            case "tree-tree": {
              return;
            }
            case "blob-blob": {
              if (await stage.oid() === await commit2.oid() && await stage.mode() === await commit2.mode() && !force) {
                return;
              }
              if (workdir) {
                if (await workdir.oid() !== await stage.oid() && await workdir.oid() !== await commit2.oid()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      await commit2.mode() !== await workdir.mode()
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                }
              } else if (force) {
                return [
                  "update",
                  fullpath,
                  await commit2.oid(),
                  await commit2.mode(),
                  await commit2.mode() !== await stage.mode()
                ];
              }
              if (await commit2.mode() !== await stage.mode()) {
                return [
                  "update",
                  fullpath,
                  await commit2.oid(),
                  await commit2.mode(),
                  true
                ];
              }
              if (await commit2.oid() !== await stage.oid()) {
                return [
                  "update",
                  fullpath,
                  await commit2.oid(),
                  await commit2.mode(),
                  false
                ];
              } else {
                return;
              }
            }
            case "tree-blob": {
              return ["update-dir-to-blob", fullpath, await commit2.oid()];
            }
            case "blob-tree": {
              return ["update-blob-to-tree", fullpath];
            }
            case "commit-commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit2.oid(),
                await commit2.mode()
              ];
            }
            default: {
              return [
                "error",
                `update entry Unhandled type ${await stage.type()}-${await commit2.type()}`
              ];
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children;
      } else if (parent && parent[0] === "rmdir") {
        children.push(parent);
        return children;
      } else {
        children.unshift(parent);
        return children;
      }
    }
  });
}
async function checkout$1({
  fs,
  onProgress,
  dir,
  gitdir = join$2(dir, ".git"),
  remote = "origin",
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === void 0,
  dryRun = false,
  force = false,
  track = true,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const ref = _ref || "HEAD";
    return await _checkout$1({
      fs: new FileSystem(fs),
      cache: cache2,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track
    });
  } catch (err2) {
    err2.caller = "git.checkout";
    throw err2;
  }
}
const abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[1] === "remotes/" && ref.endsWith("/HEAD")) {
      return match[2].slice(0, -5);
    } else {
      return match[2];
    }
  }
  return ref;
}
async function _currentBranch({
  fs,
  gitdir,
  fullname = false,
  test = false
}) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: "HEAD",
    depth: 2
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_) {
      return;
    }
  }
  if (!ref.startsWith("refs/"))
    return;
  return fullname ? ref : abbreviateRef(ref);
}
function translateSSHtoHTTP(url) {
  url = url.replace(/^git@([^:]+):/, "https://$1/");
  url = url.replace(/^ssh:\/\//, "https://");
  return url;
}
function calculateBasicAuthHeader({ username = "", password = "" }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
}
async function forAwait$1(iterable, cb) {
  const iter = getIterator$1(iterable);
  while (true) {
    const { value: value2, done } = await iter.next();
    if (value2)
      await cb(value2);
    if (done)
      break;
  }
  if (iter.return)
    iter.return();
}
async function collect$1(iterable) {
  let size = 0;
  const buffers = [];
  await forAwait$1(iterable, (value2) => {
    buffers.push(value2);
    size += value2.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
function extractAuthFromUrl(url) {
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  if (userpass == null)
    return { url, auth: {} };
  userpass = userpass[1];
  const [username, password] = userpass.split(":");
  url = url.replace(`${userpass}@`, "");
  return { url, auth: { username, password } };
}
function padHex$1(b, n) {
  const s = n.toString(16);
  return "0".repeat(b - s.length) + s;
}
class GitPktLine {
  static flush() {
    return Buffer.from("0000", "utf8");
  }
  static delim() {
    return Buffer.from("0001", "utf8");
  }
  static encode(line) {
    if (typeof line === "string") {
      line = Buffer.from(line);
    }
    const length = line.length + 4;
    const hexlength = padHex$1(4, length);
    return Buffer.concat([Buffer.from(hexlength, "utf8"), line]);
  }
  static streamReader(stream) {
    const reader = new StreamReader(stream);
    return async function read() {
      try {
        let length = await reader.read(4);
        if (length == null)
          return true;
        length = parseInt(length.toString("utf8"), 16);
        if (length === 0)
          return null;
        if (length === 1)
          return null;
        const buffer = await reader.read(length - 4);
        if (buffer == null)
          return true;
        return buffer;
      } catch (err2) {
        stream.error = err2;
        return true;
      }
    };
  }
}
async function parseCapabilitiesV2(read) {
  const capabilities2 = {};
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const i = line.indexOf("=");
    if (i > -1) {
      const key = line.slice(0, i);
      const value2 = line.slice(i + 1);
      capabilities2[key] = value2;
    } else {
      capabilities2[line] = true;
    }
  }
  return { protocolVersion: 2, capabilities2 };
}
async function parseRefsAdResponse(stream, { service }) {
  const capabilities = /* @__PURE__ */ new Set();
  const refs = /* @__PURE__ */ new Map();
  const symrefs = /* @__PURE__ */ new Map();
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  while (lineOne === null)
    lineOne = await read();
  if (lineOne === true)
    throw new EmptyServerResponseError();
  if (lineOne.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  if (lineOne.toString("utf8").replace(/\n$/, "") !== `# service=${service}`) {
    throw new ParseError(`# service=${service}\\n`, lineOne.toString("utf8"));
  }
  let lineTwo = await read();
  while (lineTwo === null)
    lineTwo = await read();
  if (lineTwo === true)
    return { capabilities, refs, symrefs };
  lineTwo = lineTwo.toString("utf8");
  if (lineTwo.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\0", "\\x00");
  capabilitiesLine.split(" ").map((x) => capabilities.add(x));
  const [ref, name] = splitAndAssert(firstRef, " ", " ");
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true)
      break;
    if (line !== null) {
      const [ref2, name2] = splitAndAssert(line.toString("utf8"), " ", " ");
      refs.set(name2, ref2);
    }
  }
  for (const cap of capabilities) {
    if (cap.startsWith("symref=")) {
      const m = cap.match(/symref=([^:]+):(.*)/);
      if (m.length === 3) {
        symrefs.set(m[1], m[2]);
      }
    }
  }
  return { protocolVersion: 1, capabilities, refs, symrefs };
}
function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== 2) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString("utf8")
    );
  }
  return split;
}
const corsProxify = (corsProxy, url) => corsProxy.endsWith("?") ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`;
const updateHeaders = (headers, auth2) => {
  if (auth2.username || auth2.password) {
    headers.Authorization = calculateBasicAuthHeader(auth2);
  }
  if (auth2.headers) {
    Object.assign(headers, auth2.headers);
  }
};
const stringifyBody = async (res2) => {
  try {
    const data = Buffer.from(await collect$1(res2.body));
    const response = data.toString("utf8");
    const preview = response.length < 256 ? response : response.slice(0, 256) + "...";
    return { preview, response, data };
  } catch (e) {
    return {};
  }
};
class GitRemoteHTTP {
  static async capabilities() {
    return ["discover", "connect"];
  }
  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {AuthCallback} [args.onAuth]
   * @param {AuthFailureCallback} [args.onAuthFailure]
   * @param {AuthSuccessCallback} [args.onAuthSuccess]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} args.headers
   * @param {1 | 2} args.protocolVersion - Git Protocol Version
   */
  static async discover({
    http,
    onProgress,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service,
    url: _origUrl,
    headers,
    protocolVersion
  }) {
    let { url, auth: auth2 } = extractAuthFromUrl(_origUrl);
    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
    if (auth2.username || auth2.password) {
      headers.Authorization = calculateBasicAuthHeader(auth2);
    }
    if (protocolVersion === 2) {
      headers["Git-Protocol"] = "version=2";
    }
    let res2;
    let tryAgain;
    let providedAuthBefore = false;
    do {
      res2 = await http.request({
        onProgress,
        method: "GET",
        url: `${proxifiedURL}/info/refs?service=${service}`,
        headers
      });
      tryAgain = false;
      if (res2.statusCode === 401 || res2.statusCode === 203) {
        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
        if (getAuth) {
          auth2 = await getAuth(url, {
            ...auth2,
            headers: { ...headers }
          });
          if (auth2 && auth2.cancel) {
            throw new UserCanceledError();
          } else if (auth2) {
            updateHeaders(headers, auth2);
            providedAuthBefore = true;
            tryAgain = true;
          }
        }
      } else if (res2.statusCode === 200 && providedAuthBefore && onAuthSuccess) {
        await onAuthSuccess(url, auth2);
      }
    } while (tryAgain);
    if (res2.statusCode !== 200) {
      const { response } = await stringifyBody(res2);
      throw new HttpError(res2.statusCode, res2.statusMessage, response);
    }
    if (res2.headers["content-type"] === `application/x-${service}-advertisement`) {
      const remoteHTTP = await parseRefsAdResponse(res2.body, { service });
      remoteHTTP.auth = auth2;
      return remoteHTTP;
    } else {
      const { preview, response, data } = await stringifyBody(res2);
      try {
        const remoteHTTP = await parseRefsAdResponse([data], { service });
        remoteHTTP.auth = auth2;
        return remoteHTTP;
      } catch (e) {
        throw new SmartHttpError(preview, response);
      }
    }
  }
  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} [args.headers]
   * @param {any} args.body
   * @param {any} args.auth
   */
  static async connect({
    http,
    onProgress,
    corsProxy,
    service,
    url,
    auth: auth2,
    body,
    headers
  }) {
    const urlAuth = extractAuthFromUrl(url);
    if (urlAuth)
      url = urlAuth.url;
    if (corsProxy)
      url = corsProxify(corsProxy, url);
    headers["content-type"] = `application/x-${service}-request`;
    headers.accept = `application/x-${service}-result`;
    updateHeaders(headers, auth2);
    const res2 = await http.request({
      onProgress,
      method: "POST",
      url: `${url}/${service}`,
      body,
      headers
    });
    if (res2.statusCode !== 200) {
      const { response } = stringifyBody(res2);
      throw new HttpError(res2.statusCode, res2.statusMessage, response);
    }
    return res2;
  }
}
function parseRemoteUrl({ url }) {
  if (url.startsWith("git@")) {
    return {
      transport: "ssh",
      address: url
    };
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
  if (matches === null)
    return;
  if (matches[2] === "://") {
    return {
      transport: matches[1],
      address: matches[0]
    };
  }
  if (matches[2] === "::") {
    return {
      transport: matches[1],
      address: matches[3]
    };
  }
}
class GitRemoteManager {
  static getRemoteHelperFor({ url }) {
    const remoteHelpers = /* @__PURE__ */ new Map();
    remoteHelpers.set("http", GitRemoteHTTP);
    remoteHelpers.set("https", GitRemoteHTTP);
    const parts = parseRemoteUrl({ url });
    if (!parts) {
      throw new UrlParseError(url);
    }
    if (remoteHelpers.has(parts.transport)) {
      return remoteHelpers.get(parts.transport);
    }
    throw new UnknownTransportError(
      url,
      parts.transport,
      parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 0
    );
  }
}
let lock$2 = null;
class GitShallowManager {
  static async read({ fs, gitdir }) {
    if (lock$2 === null)
      lock$2 = new AsyncLock();
    const filepath = join$2(gitdir, "shallow");
    const oids = /* @__PURE__ */ new Set();
    await lock$2.acquire(filepath, async function() {
      const text = await fs.read(filepath, { encoding: "utf8" });
      if (text === null)
        return oids;
      if (text.trim() === "")
        return oids;
      text.trim().split("\n").map((oid) => oids.add(oid));
    });
    return oids;
  }
  static async write({ fs, gitdir, oids }) {
    if (lock$2 === null)
      lock$2 = new AsyncLock();
    const filepath = join$2(gitdir, "shallow");
    if (oids.size > 0) {
      const text = [...oids].join("\n") + "\n";
      await lock$2.acquire(filepath, async function() {
        await fs.write(filepath, text, {
          encoding: "utf8"
        });
      });
    } else {
      await lock$2.acquire(filepath, async function() {
        await fs.rm(filepath);
      });
    }
  }
}
async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  return fs.exists(`${gitdir}/${source}`);
}
async function hasObjectPacked({
  fs,
  cache: cache2,
  gitdir,
  oid,
  getExternalRefDelta
}) {
  let list = await fs.readdir(join$2(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache: cache2,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    if (p.offsets.has(oid)) {
      return true;
    }
  }
  return false;
}
async function hasObject({
  fs,
  cache: cache2,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid2) => _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
  let result = await hasObjectLoose({ fs, gitdir, oid });
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache: cache2,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  return result;
}
function emptyPackfile(pack) {
  const pheader = "5041434b";
  const version2 = "00000002";
  const obCount = "00000000";
  const header = pheader + version2 + obCount;
  return pack.slice(0, 12).toString("hex") === header;
}
function filterCapabilities(server, client) {
  const serverNames = server.map((cap) => cap.split("=", 1)[0]);
  return client.filter((cap) => {
    const name = cap.split("=", 1)[0];
    return serverNames.includes(name);
  });
}
const pkg = {
  name: "isomorphic-git",
  version: "0.0.0-development",
  agent: "git/isomorphic-git@0.0.0-development"
};
class FIFO {
  constructor() {
    this._queue = [];
  }
  write(chunk) {
    if (this._ended) {
      throw Error("You cannot write to a FIFO that has already been ended!");
    }
    if (this._waiting) {
      const resolve2 = this._waiting;
      this._waiting = null;
      resolve2({ value: chunk });
    } else {
      this._queue.push(chunk);
    }
  }
  end() {
    this._ended = true;
    if (this._waiting) {
      const resolve2 = this._waiting;
      this._waiting = null;
      resolve2({ done: true });
    }
  }
  destroy(err2) {
    this.error = err2;
    this.end();
  }
  async next() {
    if (this._queue.length > 0) {
      return { value: this._queue.shift() };
    }
    if (this._ended) {
      return { done: true };
    }
    if (this._waiting) {
      throw Error(
        "You cannot call read until the previous call to read has returned!"
      );
    }
    return new Promise((resolve2) => {
      this._waiting = resolve2;
    });
  }
}
function findSplit(str2) {
  const r = str2.indexOf("\r");
  const n = str2.indexOf("\n");
  if (r === -1 && n === -1)
    return -1;
  if (r === -1)
    return n + 1;
  if (n === -1)
    return r + 1;
  if (n === r + 1)
    return n + 1;
  return Math.min(r, n) + 1;
}
function splitLines(input) {
  const output = new FIFO();
  let tmp = "";
  (async () => {
    await forAwait$1(input, (chunk) => {
      chunk = chunk.toString("utf8");
      tmp += chunk;
      while (true) {
        const i = findSplit(tmp);
        if (i === -1)
          break;
        output.write(tmp.slice(0, i));
        tmp = tmp.slice(i);
      }
    });
    if (tmp.length > 0) {
      output.write(tmp);
    }
    output.end();
  })();
  return output;
}
class GitSideBand {
  static demux(input) {
    const read = GitPktLine.streamReader(input);
    const packetlines = new FIFO();
    const packfile = new FIFO();
    const progress = new FIFO();
    const nextBit = async function() {
      const line = await read();
      if (line === null)
        return nextBit();
      if (line === true) {
        packetlines.end();
        progress.end();
        input.error ? packfile.destroy(input.error) : packfile.end();
        return;
      }
      switch (line[0]) {
        case 1: {
          packfile.write(line.slice(1));
          break;
        }
        case 2: {
          progress.write(line.slice(1));
          break;
        }
        case 3: {
          const error = line.slice(1);
          progress.write(error);
          packetlines.end();
          progress.end();
          packfile.destroy(new Error(error.toString("utf8")));
          return;
        }
        default: {
          packetlines.write(line);
        }
      }
      nextBit();
    };
    nextBit();
    return {
      packetlines,
      packfile,
      progress
    };
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}
async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve2, reject) => {
    forAwait$1(packetlines, (data) => {
      const line = data.toString("utf8").trim();
      if (line.startsWith("shallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith("unshallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith("ACK")) {
        const [, oid, status2] = line.split(" ");
        acks.push({ oid, status: status2 });
        if (!status2)
          done = true;
      } else if (line.startsWith("NAK")) {
        nak = true;
        done = true;
      } else {
        done = true;
        nak = true;
      }
      if (done) {
        stream.error ? reject(stream.error) : resolve2({ shallows, unshallows, acks, nak, packfile, progress });
      }
    }).finally(() => {
      if (!done) {
        stream.error ? reject(stream.error) : resolve2({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  });
}
function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = []
}) {
  const packstream = [];
  wants = [...new Set(wants)];
  let firstLineCapabilities = ` ${capabilities.join(" ")}`;
  for (const oid of wants) {
    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`));
    firstLineCapabilities = "";
  }
  for (const oid of shallows) {
    packstream.push(GitPktLine.encode(`shallow ${oid}
`));
  }
  if (depth !== null) {
    packstream.push(GitPktLine.encode(`deepen ${depth}
`));
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1e3)}
`)
    );
  }
  for (const oid of exclude) {
    packstream.push(GitPktLine.encode(`deepen-not ${oid}
`));
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(GitPktLine.encode(`have ${oid}
`));
  }
  packstream.push(GitPktLine.encode(`done
`));
  return packstream;
}
async function _fetch({
  fs,
  cache: cache2,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir, test: true });
  const config = await GitConfigManager.get({ fs, gitdir });
  const remote = _remote || ref && await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || ref && await config.get(`branch.${ref}.merge`) || _ref || "HEAD";
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-upload-pack",
    url,
    headers,
    protocolVersion: 1
  });
  const auth2 = remoteHTTP.auth;
  const remoteRefs = remoteHTTP.refs;
  if (remoteRefs.size === 0) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null
    };
  }
  if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
    throw new RemoteCapabilityError("shallow", "depth");
  }
  if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
    throw new RemoteCapabilityError("deepen-since", "since");
  }
  if (exclude.length > 0 && !remoteHTTP.capabilities.has("deepen-not")) {
    throw new RemoteCapabilityError("deepen-not", "exclude");
  }
  if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
    throw new RemoteCapabilityError("deepen-relative", "relative");
  }
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs
  });
  for (const remoteRef2 of remoteRefs.keys()) {
    if (remoteRef2 === fullref || remoteRef2 === "HEAD" || remoteRef2.startsWith("refs/heads/") || tags && remoteRef2.startsWith("refs/tags/")) {
      continue;
    }
    remoteRefs.delete(remoteRef2);
  }
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      "multi_ack_detailed",
      "no-done",
      "side-band-64k",
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      "ofs-delta",
      `agent=${pkg.agent}`
    ]
  );
  if (relative)
    capabilities.push("deepen-relative");
  const wants = singleBranch ? [oid] : remoteRefs.values();
  const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({
    fs,
    gitdir,
    filepath: `refs`
  });
  let haves = [];
  for (let ref2 of haveRefs) {
    try {
      ref2 = await GitRefManager.expand({ fs, gitdir, ref: ref2 });
      const oid2 = await GitRefManager.resolve({ fs, gitdir, ref: ref2 });
      if (await hasObject({ fs, cache: cache2, gitdir, oid: oid2 })) {
        haves.push(oid2);
      }
    } catch (err2) {
    }
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude
  });
  const packbuffer = Buffer.from(await collect$1(packstream));
  const raw = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-upload-pack",
    url,
    auth: auth2,
    body: [packbuffer],
    headers
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  for (const oid2 of response.shallows) {
    if (!oids.has(oid2)) {
      try {
        const { object } = await _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
        const commit2 = new GitCommit(object);
        const hasParents = await Promise.all(
          commit2.headers().parent.map((oid3) => hasObject({ fs, cache: cache2, gitdir, oid: oid3 }))
        );
        const haveAllParents = hasParents.length === 0 || hasParents.every((has) => has);
        if (!haveAllParents) {
          oids.add(oid2);
        }
      } catch (err2) {
        oids.add(oid2);
      }
    }
  }
  for (const oid2 of response.unshallows) {
    oids.delete(oid2);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  if (singleBranch) {
    const refs = /* @__PURE__ */ new Map([[fullref, oid]]);
    const symrefs = /* @__PURE__ */ new Map();
    let bail = 10;
    let key = fullref;
    while (bail--) {
      const value2 = remoteHTTP.symrefs.get(key);
      if (value2 === void 0)
        break;
      symrefs.set(key, value2);
      key = value2;
    }
    const realRef = remoteRefs.get(key);
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  response.HEAD = remoteHTTP.symrefs.get("HEAD");
  if (response.HEAD === void 0) {
    const { oid: oid2 } = GitRefManager.resolveAgainstMap({
      ref: "HEAD",
      map: remoteRefs
    });
    for (const [key, value2] of remoteRefs.entries()) {
      if (key !== "HEAD" && value2 === oid2) {
        response.HEAD = key;
        break;
      }
    }
  }
  const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`
  };
  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait$1(lines, async (line) => {
      if (onMessage)
        await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[1].trim(),
            loaded: parseInt(matches[2], 10),
            total: parseInt(matches[3], 10)
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect$1(response.packfile));
  if (raw.body.error)
    throw raw.body.error;
  const packfileSha = packfile.slice(-20).toString("hex");
  const res2 = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description
  };
  if (response.headers) {
    res2.headers = response.headers;
  }
  if (prune) {
    res2.pruned = response.pruned;
  }
  if (packfileSha !== "" && !emptyPackfile(packfile)) {
    res2.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join$2(gitdir, res2.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = (oid2) => _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
  }
  return res2;
}
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join$2(dir, ".git"),
  defaultBranch = "master"
}) {
  if (await fs.exists(gitdir + "/config"))
    return;
  let folders = [
    "hooks",
    "info",
    "objects/info",
    "objects/pack",
    "refs/heads",
    "refs/tags"
  ];
  folders = folders.map((dir2) => gitdir + "/" + dir2);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }
  await fs.write(
    gitdir + "/config",
    `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${bare}
` + (bare ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"
  );
  await fs.write(gitdir + "/HEAD", `ref: refs/heads/${defaultBranch}
`);
}
async function _clone({
  fs,
  cache: cache2,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers
}) {
  try {
    await _init({ fs, gitdir });
    await _addRemote({ fs, gitdir, remote, url, force: false });
    if (corsProxy) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`http.corsProxy`, corsProxy);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    const { defaultBranch, fetchHead } = await _fetch({
      fs,
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      headers,
      tags: !noTags
    });
    if (fetchHead === null)
      return;
    ref = ref || defaultBranch;
    ref = ref.replace("refs/heads/", "");
    await _checkout$1({
      fs,
      cache: cache2,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout
    });
  } catch (err2) {
    await fs.rmdir(gitdir, { recursive: true, maxRetries: 10 }).catch(() => void 0);
    throw err2;
  }
}
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join$2(dir, ".git"),
  url,
  corsProxy = void 0,
  ref = void 0,
  remote = "origin",
  depth = void 0,
  since = void 0,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    if (!noCheckout) {
      assertParameter("dir", dir);
    }
    assertParameter("url", url);
    return await _clone({
      fs: new FileSystem(fs),
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers
    });
  } catch (err2) {
    err2.caller = "git.clone";
    throw err2;
  }
}
async function commit$1({
  fs: _fs,
  onSign,
  dir,
  gitdir = join$2(dir, ".git"),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("message", message);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _commit({
      fs,
      cache: cache2,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree
    });
  } catch (err2) {
    err2.caller = "git.commit";
    throw err2;
  }
}
async function currentBranch({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  fullname = false,
  test = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test
    });
  } catch (err2) {
    err2.caller = "git.currentBranch";
    throw err2;
  }
}
async function _deleteBranch({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/heads/") ? ref : `refs/heads/${ref}`;
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref);
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    const value2 = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: value2 });
  }
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}
async function deleteBranch({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err2) {
    err2.caller = "git.deleteBranch";
    throw err2;
  }
}
async function deleteRef({ fs, dir, gitdir = join$2(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err2) {
    err2.caller = "git.deleteRef";
    throw err2;
  }
}
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection("remote", remote);
  await GitConfigManager.save({ fs, gitdir, config });
}
async function deleteRemote({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("remote", remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err2) {
    err2.caller = "git.deleteRemote";
    throw err2;
  }
}
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}
async function deleteTag({ fs, dir, gitdir = join$2(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err2) {
    err2.caller = "git.deleteTag";
    throw err2;
  }
}
async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(0, 2);
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes.map((suffix) => `${prefix}${suffix}`).filter((_oid) => _oid.startsWith(short));
}
async function expandOidPacked({
  fs,
  cache: cache2,
  gitdir,
  oid: short,
  getExternalRefDelta
}) {
  const results2 = [];
  let list = await fs.readdir(join$2(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache: cache2,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    for (const oid of p.offsets.keys()) {
      if (oid.startsWith(short))
        results2.push(oid);
    }
  }
  return results2;
}
async function _expandOid({ fs, cache: cache2, gitdir, oid: short }) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache: cache2, gitdir, oid });
  const results2 = await expandOidLoose({ fs, gitdir, oid: short });
  const packedOids = await expandOidPacked({
    fs,
    cache: cache2,
    gitdir,
    oid: short,
    getExternalRefDelta
  });
  for (const packedOid of packedOids) {
    if (results2.indexOf(packedOid) === -1) {
      results2.push(packedOid);
    }
  }
  if (results2.length === 1) {
    return results2[0];
  }
  if (results2.length > 1) {
    throw new AmbiguousError("oids", short, results2);
  }
  throw new NotFoundError(`an object matching "${short}"`);
}
async function expandOid({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid
    });
  } catch (err2) {
    err2.caller = "git.expandOid";
    throw err2;
  }
}
async function expandRef({ fs, dir, gitdir = join$2(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err2) {
    err2.caller = "git.expandRef";
    throw err2;
  }
}
async function _findMergeBase({ fs, cache: cache2, gitdir, oids }) {
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index2) => ({ index: index2, oid }));
  while (heads.length) {
    const result = /* @__PURE__ */ new Set();
    for (const { oid, index: index2 } of heads) {
      if (!visits[oid])
        visits[oid] = /* @__PURE__ */ new Set();
      visits[oid].add(index2);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > 0) {
      return [...result];
    }
    const newheads = /* @__PURE__ */ new Map();
    for (const { oid, index: index2 } of heads) {
      try {
        const { object } = await _readObject({ fs, cache: cache2, gitdir, oid });
        const commit2 = GitCommit.from(object);
        const { parent } = commit2.parseHeaders();
        for (const oid2 of parent) {
          if (!visits[oid2] || !visits[oid2].has(index2)) {
            newheads.set(oid2 + ":" + index2, { oid: oid2, index: index2 });
          }
        }
      } catch (err2) {
      }
    }
    heads = Array.from(newheads.values());
  }
  return [];
}
const LINEBREAKS = /^.*(\r?\n|$)/gm;
function mergeFile({ branches, contents }) {
  const ourName = branches[1];
  const theirName = branches[2];
  const baseContent = contents[0];
  const ourContent = contents[1];
  const theirContent = contents[2];
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);
  const result = diff3Merge(ours, base, theirs);
  const markerSize = 7;
  let mergedText = "";
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join("");
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
      mergedText += item.conflict.a.join("");
      mergedText += `${"=".repeat(markerSize)}
`;
      mergedText += item.conflict.b.join("");
      mergedText += `${">".repeat(markerSize)} ${theirName}
`;
    }
  }
  return { cleanMerge, mergedText };
}
async function mergeTree({
  fs,
  cache: cache2,
  dir,
  gitdir = join$2(dir, ".git"),
  index: index2,
  ourOid,
  baseOid,
  theirOid,
  ourName = "ours",
  baseName = "base",
  theirName = "theirs",
  dryRun = false,
  abortOnConflict = true,
  mergeDriver
}) {
  const ourTree = TREE$1({ ref: ourOid });
  const baseTree = TREE$1({ ref: baseOid });
  const theirTree = TREE$1({ ref: theirOid });
  const unmergedFiles = [];
  const bothModified = [];
  const deleteByUs = [];
  const deleteByTheirs = [];
  const results2 = await _walk({
    fs,
    cache: cache2,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function(filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case "false-false": {
          return {
            mode: await base.mode(),
            path,
            oid: await base.oid(),
            type: await base.type()
          };
        }
        case "false-true": {
          return theirs ? {
            mode: await theirs.mode(),
            path,
            oid: await theirs.oid(),
            type: await theirs.type()
          } : void 0;
        }
        case "true-false": {
          return ours ? {
            mode: await ours.mode(),
            path,
            oid: await ours.oid(),
            type: await ours.type()
          } : void 0;
        }
        case "true-true": {
          if (ours && base && theirs && await ours.type() === "blob" && await base.type() === "blob" && await theirs.type() === "blob") {
            return mergeBlobs({
              fs,
              gitdir,
              path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
              mergeDriver
            }).then(async (r) => {
              if (!r.cleanMerge) {
                unmergedFiles.push(filepath);
                bothModified.push(filepath);
                if (!abortOnConflict) {
                  const baseOid2 = await base.oid();
                  const ourOid2 = await ours.oid();
                  const theirOid2 = await theirs.oid();
                  index2.delete({ filepath });
                  index2.insert({ filepath, oid: baseOid2, stage: 1 });
                  index2.insert({ filepath, oid: ourOid2, stage: 2 });
                  index2.insert({ filepath, oid: theirOid2, stage: 3 });
                }
              } else if (!abortOnConflict) {
                index2.insert({ filepath, oid: r.mergeResult.oid, stage: 0 });
              }
              return r.mergeResult;
            });
          }
          if (base && !ours && theirs && await base.type() === "blob" && await theirs.type() === "blob") {
            unmergedFiles.push(filepath);
            deleteByUs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const theirOid2 = await theirs.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: theirOid2, stage: 3 });
            }
            return {
              mode: await theirs.mode(),
              oid: await theirs.oid(),
              type: "blob",
              path
            };
          }
          if (base && ours && !theirs && await base.type() === "blob" && await ours.type() === "blob") {
            unmergedFiles.push(filepath);
            deleteByTheirs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const ourOid2 = await ours.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: ourOid2, stage: 2 });
            }
            return {
              mode: await ours.mode(),
              oid: await ours.oid(),
              type: "blob",
              path
            };
          }
          if (base && !ours && !theirs && await base.type() === "blob") {
            return void 0;
          }
          throw new MergeNotSupportedError();
        }
      }
    },
    /**
     * @param {TreeEntry} [parent]
     * @param {Array<TreeEntry>} children
     */
    reduce: unmergedFiles.length !== 0 && (!dir || abortOnConflict) ? void 0 : async (parent, children) => {
      const entries = children.filter(Boolean);
      if (!parent)
        return;
      if (parent && parent.type === "tree" && entries.length === 0)
        return;
      if (entries.length > 0) {
        const tree = new GitTree(entries);
        const object = tree.toObject();
        const oid = await _writeObject({
          fs,
          gitdir,
          type: "tree",
          object,
          dryRun
        });
        parent.oid = oid;
      }
      return parent;
    }
  });
  if (unmergedFiles.length !== 0) {
    if (dir && !abortOnConflict) {
      await _walk({
        fs,
        cache: cache2,
        dir,
        gitdir,
        trees: [TREE$1({ ref: results2.oid })],
        map: async function(filepath, [entry]) {
          const path = `${dir}/${filepath}`;
          if (await entry.type() === "blob") {
            const mode = await entry.mode();
            const content = new TextDecoder().decode(await entry.content());
            await fs.write(path, content, { mode });
          }
          return true;
        }
      });
    }
    return new MergeConflictError(
      unmergedFiles,
      bothModified,
      deleteByUs,
      deleteByTheirs
    );
  }
  return results2.oid;
}
async function mergeBlobs({
  fs,
  gitdir,
  path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  dryRun,
  mergeDriver = mergeFile
}) {
  const type2 = "blob";
  const mode = await base.mode() === await ours.mode() ? await theirs.mode() : await ours.mode();
  if (await ours.oid() === await theirs.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type: type2 }
    };
  }
  if (await ours.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await theirs.oid(), type: type2 }
    };
  }
  if (await theirs.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type: type2 }
    };
  }
  const ourContent = Buffer.from(await ours.content()).toString("utf8");
  const baseContent = Buffer.from(await base.content()).toString("utf8");
  const theirContent = Buffer.from(await theirs.content()).toString("utf8");
  const { mergedText, cleanMerge } = await mergeDriver({
    branches: [baseName, ourName, theirName],
    contents: [baseContent, ourContent, theirContent],
    path
  });
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: Buffer.from(mergedText, "utf8"),
    dryRun
  });
  return { cleanMerge, mergeResult: { mode, path, oid, type: type2 } };
}
async function _merge({
  fs,
  cache: cache2,
  dir,
  gitdir,
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author,
  committer,
  signingKey,
  onSign,
  mergeDriver
}) {
  if (ours === void 0) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs
  });
  const baseOids = await _findMergeBase({
    fs,
    cache: cache2,
    gitdir,
    oids: [ourOid, theirOid]
  });
  if (baseOids.length !== 1) {
    throw new MergeNotSupportedError();
  }
  const baseOid = baseOids[0];
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true
    };
  }
  if (fastForward2 && baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true
    };
  } else {
    if (fastForwardOnly) {
      throw new FastForwardError();
    }
    const tree = await GitIndexManager.acquire(
      { fs, gitdir, cache: cache2, allowUnmerged: false },
      async (index2) => {
        return mergeTree({
          fs,
          cache: cache2,
          dir,
          gitdir,
          index: index2,
          ourOid,
          theirOid,
          baseOid,
          ourName: abbreviateRef(ours),
          baseName: "base",
          theirName: abbreviateRef(theirs),
          dryRun,
          abortOnConflict,
          mergeDriver
        });
      }
    );
    if (tree instanceof MergeConflictError)
      throw tree;
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache: cache2,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      onSign,
      dryRun,
      noUpdateBranch
    });
    return {
      oid,
      tree,
      mergeCommit: true
    };
  }
}
async function _pull({
  fs,
  cache: cache2,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  prune,
  pruneTags,
  fastForward: fastForward2,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey
}) {
  try {
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      if (!head) {
        throw new MissingParameterError("ref");
      }
      ref = head;
    }
    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
    await _merge({
      fs,
      cache: cache2,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForward: fastForward2,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false
    });
    await _checkout$1({
      fs,
      cache: cache2,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false
    });
  } catch (err2) {
    err2.caller = "git.pull";
    throw err2;
  }
}
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    const thisWillNotBeUsed = {
      name: "",
      email: "",
      timestamp: Date.now(),
      timezoneOffset: 0
    };
    return await _pull({
      fs: new FileSystem(fs),
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed
    });
  } catch (err2) {
    err2.caller = "git.fastForward";
    throw err2;
  }
}
async function fetch$1({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _fetch({
      fs: new FileSystem(fs),
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
  } catch (err2) {
    err2.caller = "git.fetch";
    throw err2;
  }
}
async function findMergeBase({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oids,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oids
    });
  } catch (err2) {
    err2.caller = "git.findMergeBase";
    throw err2;
  }
}
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join$2(filepath, ".git"))) {
    return filepath;
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`);
    }
    return _findRoot({ fs, filepath: parent });
  }
}
async function findRoot({ fs, filepath }) {
  try {
    assertParameter("fs", fs);
    assertParameter("filepath", filepath);
    return await _findRoot({ fs: new FileSystem(fs), filepath });
  } catch (err2) {
    err2.caller = "git.findRoot";
    throw err2;
  }
}
async function getConfig({ fs, dir, gitdir = join$2(dir, ".git"), path }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path
    });
  } catch (err2) {
    err2.caller = "git.getConfig";
    throw err2;
  }
}
async function _getConfigAll({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path);
}
async function getConfigAll({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  path
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path
    });
  } catch (err2) {
    err2.caller = "git.getConfigAll";
    throw err2;
  }
}
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion: 1
    });
    const result = {
      capabilities: [...remote.capabilities]
    };
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split("/");
      const last2 = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last2] = oid;
    }
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split("/");
      const last2 = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last2] = ref;
    }
    return result;
  } catch (err2) {
    err2.caller = "git.getRemoteInfo";
    throw err2;
  }
}
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value2] of remote.refs) {
    if (prefix && !key.startsWith(prefix))
      continue;
    if (key.endsWith("^{}")) {
      if (peelTags) {
        const _key = key.replace("^{}", "");
        const last2 = refs[refs.length - 1];
        const r = last2.ref === _key ? last2 : refs.find((x) => x.ref === _key);
        if (r === void 0) {
          throw new Error("I did not expect this to happen");
        }
        r.peeled = value2;
      }
      continue;
    }
    const ref = { ref: key, oid: value2 };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs;
}
async function getRemoteInfo2({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === 2) {
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities2
      };
    }
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value2] = cap.split("=");
      if (value2) {
        capabilities[key] = value2;
      } else {
        capabilities[key] = true;
      }
    }
    return {
      protocolVersion: 1,
      capabilities,
      refs: formatInfoRefs(remote, void 0, true, true)
    };
  } catch (err2) {
    err2.caller = "git.getRemoteInfo2";
    throw err2;
  }
}
async function hashObject({
  type: type2,
  object,
  format = "content",
  oid = void 0
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type: type2, object });
    }
    oid = await shasum(object);
  }
  return { oid, object };
}
async function hashBlob({ object }) {
  try {
    assertParameter("object", object);
    if (typeof object === "string") {
      object = Buffer.from(object, "utf8");
    } else {
      object = Buffer.from(object);
    }
    const type2 = "blob";
    const { oid, object: _object } = await hashObject({
      type: "blob",
      format: "content",
      object
    });
    return { oid, type: type2, object: new Uint8Array(_object), format: "wrapped" };
  } catch (err2) {
    err2.caller = "git.hashBlob";
    throw err2;
  }
}
async function _indexPack({
  fs,
  cache: cache2,
  onProgress,
  dir,
  gitdir,
  filepath
}) {
  try {
    filepath = join$2(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = (oid) => _readObject({ fs, cache: cache2, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
    return {
      oids: [...idx.hashes]
    };
  } catch (err2) {
    err2.caller = "git.indexPack";
    throw err2;
  }
}
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", dir);
    assertParameter("filepath", filepath);
    return await _indexPack({
      fs: new FileSystem(fs),
      cache: cache2,
      onProgress,
      dir,
      gitdir,
      filepath
    });
  } catch (err2) {
    err2.caller = "git.indexPack";
    throw err2;
  }
}
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join$2(dir, ".git"),
  defaultBranch = "master"
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    if (!bare) {
      assertParameter("dir", dir);
    }
    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch
    });
  } catch (err2) {
    err2.caller = "git.init";
    throw err2;
  }
}
async function _isDescendent({
  fs,
  cache: cache2,
  gitdir,
  oid,
  ancestor,
  depth
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError("oid");
  }
  if (!ancestor) {
    throw new MissingParameterError("ancestor");
  }
  if (oid === ancestor)
    return false;
  const queue = [oid];
  const visited = /* @__PURE__ */ new Set();
  let searchdepth = 0;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth);
    }
    const oid2 = queue.shift();
    const { type: type2, object } = await _readObject({
      fs,
      cache: cache2,
      gitdir,
      oid: oid2
    });
    if (type2 !== "commit") {
      throw new ObjectTypeError(oid2, type2, "commit");
    }
    const commit2 = GitCommit.from(object).parse();
    for (const parent of commit2.parent) {
      if (parent === ancestor)
        return true;
    }
    if (!shallows.has(oid2)) {
      for (const parent of commit2.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
  }
  return false;
}
async function isDescendent({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  ancestor,
  depth = -1,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("ancestor", ancestor);
    return await _isDescendent({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid,
      ancestor,
      depth
    });
  } catch (err2) {
    err2.caller = "git.isDescendent";
    throw err2;
  }
}
async function isIgnored$1({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    return GitIgnoreManager.isIgnored({
      fs: new FileSystem(fs),
      dir,
      gitdir,
      filepath
    });
  } catch (err2) {
    err2.caller = "git.isIgnored";
    throw err2;
  }
}
async function listBranches({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err2) {
    err2.caller = "git.listBranches";
    throw err2;
  }
}
async function _listFiles({ fs, gitdir, ref, cache: cache2 }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache: cache2,
      gitdir,
      oid,
      filenames,
      prefix: ""
    });
    return filenames;
  } else {
    return GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      return index2.entries.map((x) => x.path);
    });
  }
}
async function accumulateFilesFromOid({
  fs,
  cache: cache2,
  gitdir,
  oid,
  filenames,
  prefix
}) {
  const { tree } = await _readTree({ fs, cache: cache2, gitdir, oid });
  for (const entry of tree) {
    if (entry.type === "tree") {
      await accumulateFilesFromOid({
        fs,
        cache: cache2,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join$2(prefix, entry.path)
      });
    } else {
      filenames.push(join$2(prefix, entry.path));
    }
  }
}
async function listFiles({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listFiles({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      ref
    });
  } catch (err2) {
    err2.caller = "git.listFiles";
    throw err2;
  }
}
async function _listNotes({ fs, cache: cache2, gitdir, ref }) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err2) {
    if (err2 instanceof NotFoundError) {
      return [];
    }
  }
  const result = await _readTree({
    fs,
    cache: cache2,
    gitdir,
    oid: parent
  });
  const notes = result.tree.map((entry) => ({
    target: entry.path,
    note: entry.oid
  }));
  return notes;
}
async function listNotes({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref = "refs/notes/commits",
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _listNotes({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      ref
    });
  } catch (err2) {
    err2.caller = "git.listNotes";
    throw err2;
  }
}
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections("remote");
  const remotes = Promise.all(
    remoteNames.map(async (remote) => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url };
    })
  );
  return remotes;
}
async function listRemotes$1({ fs, dir, gitdir = join$2(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir
    });
  } catch (err2) {
    err2.caller = "git.listRemotes";
    throw err2;
  }
}
async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);
  const refs = [];
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const [oid, ref, ...attrs] = line.split(" ");
    const r = { ref, oid };
    for (const attr of attrs) {
      const [name, value2] = attr.split(":");
      if (name === "symref-target") {
        r.target = value2;
      } else if (name === "peeled") {
        r.peeled = value2;
      }
    }
    refs.push(r);
  }
  return refs;
}
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  packstream.push(GitPktLine.encode("command=ls-refs\n"));
  packstream.push(GitPktLine.encode(`agent=${pkg.agent}
`));
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags)
    packstream.push(GitPktLine.encode("peel"));
  if (symrefs)
    packstream.push(GitPktLine.encode("symrefs"));
  if (prefix)
    packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
  prefix,
  symrefs,
  peelTags
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === 1) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags);
    }
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
    const res2 = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      body
    });
    return parseListRefsResponse(res2.body);
  } catch (err2) {
    err2.caller = "git.listServerRefs";
    throw err2;
  }
}
async function listTags({ fs, dir, gitdir = join$2(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir });
  } catch (err2) {
    err2.caller = "git.listTags";
    throw err2;
  }
}
async function resolveCommit({ fs, cache: cache2, gitdir, oid }) {
  const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
  if (type2 === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache: cache2, gitdir, oid });
  }
  if (type2 !== "commit") {
    throw new ObjectTypeError(oid, type2, "commit");
  }
  return { commit: GitCommit.from(object), oid };
}
async function _readCommit({ fs, cache: cache2, gitdir, oid }) {
  const { commit: commit2, oid: commitOid } = await resolveCommit({
    fs,
    cache: cache2,
    gitdir,
    oid
  });
  const result = {
    oid: commitOid,
    commit: commit2.parse(),
    payload: commit2.withoutSignature()
  };
  return result;
}
function compareAge(a, b) {
  return a.committer.timestamp - b.committer.timestamp;
}
const EMPTY_OID = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
async function resolveFileIdInTree({ fs, cache: cache2, gitdir, oid, fileId }) {
  if (fileId === EMPTY_OID)
    return;
  const _oid = oid;
  let filepath;
  const result = await resolveTree({ fs, cache: cache2, gitdir, oid });
  const tree = result.tree;
  if (fileId === result.oid) {
    filepath = result.path;
  } else {
    filepath = await _resolveFileId({
      fs,
      cache: cache2,
      gitdir,
      tree,
      fileId,
      oid: _oid
    });
    if (Array.isArray(filepath)) {
      if (filepath.length === 0)
        filepath = void 0;
      else if (filepath.length === 1)
        filepath = filepath[0];
    }
  }
  return filepath;
}
async function _resolveFileId({
  fs,
  cache: cache2,
  gitdir,
  tree,
  fileId,
  oid,
  filepaths = [],
  parentPath = ""
}) {
  const walks = tree.entries().map(function(entry) {
    let result;
    if (entry.oid === fileId) {
      result = join$2(parentPath, entry.path);
      filepaths.push(result);
    } else if (entry.type === "tree") {
      result = _readObject({
        fs,
        cache: cache2,
        gitdir,
        oid: entry.oid
      }).then(function({ object }) {
        return _resolveFileId({
          fs,
          cache: cache2,
          gitdir,
          tree: GitTree.from(object),
          fileId,
          oid,
          filepaths,
          parentPath: join$2(parentPath, entry.path)
        });
      });
    }
    return result;
  });
  await Promise.all(walks);
  return filepaths;
}
async function _log({
  fs,
  cache: cache2,
  gitdir,
  filepath,
  ref,
  depth,
  since,
  force,
  follow
}) {
  const sinceTimestamp = typeof since === "undefined" ? void 0 : Math.floor(since.valueOf() / 1e3);
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache: cache2, gitdir, oid })];
  let lastFileOid;
  let lastCommit;
  let isOk;
  function endCommit(commit2) {
    if (isOk && filepath)
      commits.push(commit2);
  }
  while (tips.length > 0) {
    const commit2 = tips.pop();
    if (sinceTimestamp !== void 0 && commit2.commit.committer.timestamp <= sinceTimestamp) {
      break;
    }
    if (filepath) {
      let vFileOid;
      try {
        vFileOid = await resolveFilepath({
          fs,
          cache: cache2,
          gitdir,
          oid: commit2.commit.tree,
          filepath
        });
        if (lastCommit && lastFileOid !== vFileOid) {
          commits.push(lastCommit);
        }
        lastFileOid = vFileOid;
        lastCommit = commit2;
        isOk = true;
      } catch (e) {
        if (e instanceof NotFoundError) {
          let found = follow && lastFileOid;
          if (found) {
            found = await resolveFileIdInTree({
              fs,
              cache: cache2,
              gitdir,
              oid: commit2.commit.tree,
              fileId: lastFileOid
            });
            if (found) {
              if (Array.isArray(found)) {
                if (lastCommit) {
                  const lastFound = await resolveFileIdInTree({
                    fs,
                    cache: cache2,
                    gitdir,
                    oid: lastCommit.commit.tree,
                    fileId: lastFileOid
                  });
                  if (Array.isArray(lastFound)) {
                    found = found.filter((p) => lastFound.indexOf(p) === -1);
                    if (found.length === 1) {
                      found = found[0];
                      filepath = found;
                      if (lastCommit)
                        commits.push(lastCommit);
                    } else {
                      found = false;
                      if (lastCommit)
                        commits.push(lastCommit);
                      break;
                    }
                  }
                }
              } else {
                filepath = found;
                if (lastCommit)
                  commits.push(lastCommit);
              }
            }
          }
          if (!found) {
            if (isOk && lastFileOid) {
              commits.push(lastCommit);
              if (!force)
                break;
            }
            if (!force && !follow)
              throw e;
          }
          lastCommit = commit2;
          isOk = false;
        } else
          throw e;
      }
    } else {
      commits.push(commit2);
    }
    if (depth !== void 0 && commits.length === depth) {
      endCommit(commit2);
      break;
    }
    if (!shallowCommits.has(commit2.oid)) {
      for (const oid2 of commit2.commit.parent) {
        const commit3 = await _readCommit({ fs, cache: cache2, gitdir, oid: oid2 });
        if (!tips.map((commit4) => commit4.oid).includes(commit3.oid)) {
          tips.push(commit3);
        }
      }
    }
    if (tips.length === 0) {
      endCommit(commit2);
    }
    tips.sort((a, b) => compareAge(a.commit, b.commit));
  }
  return commits;
}
async function log$1({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  ref = "HEAD",
  depth,
  since,
  // Date
  force,
  follow,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _log({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow
    });
  } catch (err2) {
    err2.caller = "git.log";
    throw err2;
  }
}
async function merge$2({
  fs: _fs,
  onSign,
  dir,
  gitdir = join$2(dir, ".git"),
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache: cache2 = {},
  mergeDriver
}) {
  try {
    assertParameter("fs", _fs);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("author");
    }
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("committer");
    }
    return await _merge({
      fs,
      cache: cache2,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward2,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      abortOnConflict,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver
    });
  } catch (err2) {
    err2.caller = "git.merge";
    throw err2;
  }
}
const types = {
  commit: 16,
  tree: 32,
  blob: 48,
  tag: 64,
  ofs_delta: 96,
  ref_delta: 112
};
async function _pack({
  fs,
  cache: cache2,
  dir,
  gitdir = join$2(dir, ".git"),
  oids
}) {
  const hash2 = new Hash$1();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash2.update(buff);
  }
  async function writeObject2({ stype, object }) {
    const type2 = types[stype];
    let length = object.length;
    let multibyte = length > 15 ? 128 : 0;
    const lastFour = length & 15;
    length = length >>> 4;
    let byte = (multibyte | type2 | lastFour).toString(16);
    write(byte, "hex");
    while (multibyte) {
      multibyte = length > 127 ? 128 : 0;
      byte = multibyte | length & 127;
      write(padHex$1(2, byte), "hex");
      length = length >>> 7;
    }
    write(Buffer.from(await deflate(object)));
  }
  write("PACK");
  write("00000002", "hex");
  write(padHex$1(8, oids.length), "hex");
  for (const oid of oids) {
    const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
    await writeObject2({ write, object, stype: type2 });
  }
  const digest = hash2.digest();
  outputStream.push(digest);
  return outputStream;
}
async function _packObjects({ fs, cache: cache2, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache: cache2, gitdir, oids });
  const packfile = Buffer.from(await collect$1(buffers));
  const packfileSha = packfile.slice(-20).toString("hex");
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join$2(gitdir, `objects/pack/${filename}`), packfile);
    return { filename };
  }
  return {
    filename,
    packfile: new Uint8Array(packfile)
  };
}
async function packObjects({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oids,
  write = false,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _packObjects({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oids,
      write
    });
  } catch (err2) {
    err2.caller = "git.packObjects";
    throw err2;
  }
}
async function pull$1({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  prune = false,
  pruneTags = false,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _pull({
      fs,
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForward: fastForward2,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
      prune,
      pruneTags
    });
  } catch (err2) {
    err2.caller = "git.pull";
    throw err2;
  }
}
async function listCommitsAndTags({
  fs,
  cache: cache2,
  dir,
  gitdir = join$2(dir, ".git"),
  start,
  finish
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = /* @__PURE__ */ new Set();
  const finishingSet = /* @__PURE__ */ new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err2) {
    }
  }
  const visited = /* @__PURE__ */ new Set();
  async function walk2(oid) {
    visited.add(oid);
    const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
    if (type2 === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const commit2 = tag2.headers().object;
      return walk2(commit2);
    }
    if (type2 !== "commit") {
      throw new ObjectTypeError(oid, type2, "commit");
    }
    if (!shallows.has(oid)) {
      const commit2 = GitCommit.from(object);
      const parents = commit2.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk2(oid);
        }
      }
    }
  }
  for (const oid of startingSet) {
    await walk2(oid);
  }
  return visited;
}
async function listObjects({
  fs,
  cache: cache2,
  dir,
  gitdir = join$2(dir, ".git"),
  oids
}) {
  const visited = /* @__PURE__ */ new Set();
  async function walk2(oid) {
    if (visited.has(oid))
      return;
    visited.add(oid);
    const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
    if (type2 === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const obj = tag2.headers().object;
      await walk2(obj);
    } else if (type2 === "commit") {
      const commit2 = GitCommit.from(object);
      const tree = commit2.headers().tree;
      await walk2(tree);
    } else if (type2 === "tree") {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        if (entry.type === "blob") {
          visited.add(entry.oid);
        }
        if (entry.type === "tree") {
          await walk2(entry.oid);
        }
      }
    }
  }
  for (const oid of oids) {
    await walk2(oid);
  }
  return visited;
}
async function parseReceivePackResponse(packfile) {
  const result = {};
  let response = "";
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null)
      response += line.toString("utf8") + "\n";
    line = await read();
  }
  const lines = response.toString("utf8").split("\n");
  line = lines.shift();
  if (!line.startsWith("unpack ")) {
    throw new ParseError('unpack ok" or "unpack [error message]', line);
  }
  result.ok = line === "unpack ok";
  if (!result.ok) {
    result.error = line.slice("unpack ".length);
  }
  result.refs = {};
  for (const line2 of lines) {
    if (line2.trim() === "")
      continue;
    const status2 = line2.slice(0, 2);
    const refAndMessage = line2.slice(3);
    let space = refAndMessage.indexOf(" ");
    if (space === -1)
      space = refAndMessage.length;
    const ref = refAndMessage.slice(0, space);
    const error = refAndMessage.slice(space + 1);
    result.refs[ref] = {
      ok: status2 === "ok",
      error
    };
  }
  return result;
}
async function writeReceivePackRequest({
  capabilities = [],
  triplets = []
}) {
  const packstream = [];
  let capsFirstLine = `\0 ${capabilities.join(" ")}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
      )
    );
    capsFirstLine = "";
  }
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function _push({
  fs,
  cache: cache2,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {}
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir });
  if (typeof ref === "undefined") {
    throw new MissingParameterError("ref");
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  remote = remote || await config.get(`branch.${ref}.pushRemote`) || await config.get("remote.pushDefault") || await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.pushurl`) || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || await config.get(`branch.${ref}.merge`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remoteRef");
  }
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete ? "0000000000000000000000000000000000000000" : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-receive-pack",
    url,
    headers,
    protocolVersion: 1
  });
  const auth2 = httpRemote.auth;
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs
      });
    } catch (err2) {
      if (err2 instanceof NotFoundError) {
        fullRemoteRef = remoteRef.startsWith("refs/") ? remoteRef : `refs/heads/${remoteRef}`;
      } else {
        throw err2;
      }
    }
  }
  const oldoid = httpRemote.refs.get(fullRemoteRef) || "0000000000000000000000000000000000000000";
  const thinPack = !httpRemote.capabilities.has("no-thin");
  let objects = /* @__PURE__ */ new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = /* @__PURE__ */ new Set();
    if (oldoid !== "0000000000000000000000000000000000000000") {
      const mergebase = await _findMergeBase({
        fs,
        cache: cache2,
        gitdir,
        oids: [oid, oldoid]
      });
      for (const oid2 of mergebase)
        finish.push(oid2);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache: cache2, gitdir, oids: mergebase });
      }
    }
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache: cache2,
        gitdir,
        start: [oid],
        finish
      });
      objects = await listObjects({ fs, cache: cache2, gitdir, oids: commits });
    }
    if (thinPack) {
      try {
        const ref2 = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 2
        });
        const { oid: oid2 } = await GitRefManager.resolveAgainstMap({
          ref: ref2.replace(`refs/remotes/${remote}/`, ""),
          fullref: ref2,
          map: httpRemote.refs
        });
        const oids = [oid2];
        for (const oid3 of await listObjects({ fs, cache: cache2, gitdir, oids })) {
          skipObjects.add(oid3);
        }
      } catch (e) {
      }
      for (const oid2 of skipObjects) {
        objects.delete(oid2);
      }
    }
    if (oid === oldoid)
      force = true;
    if (!force) {
      if (fullRef.startsWith("refs/tags") && oldoid !== "0000000000000000000000000000000000000000") {
        throw new PushRejectedError("tag-exists");
      }
      if (oid !== "0000000000000000000000000000000000000000" && oldoid !== "0000000000000000000000000000000000000000" && !await _isDescendent({
        fs,
        cache: cache2,
        gitdir,
        oid,
        ancestor: oldoid,
        depth: -1
      })) {
        throw new PushRejectedError("not-fast-forward");
      }
    }
  }
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ["report-status", "side-band-64k", `agent=${pkg.agent}`]
  );
  const packstream1 = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }]
  });
  const packstream2 = _delete ? [] : await _pack({
    fs,
    cache: cache2,
    gitdir,
    oids: [...objects]
  });
  const res2 = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-receive-pack",
    url,
    auth: auth2,
    headers,
    body: [...packstream1, ...packstream2]
  });
  const { packfile, progress } = await GitSideBand.demux(res2.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait$1(lines, async (line) => {
      await onMessage(line);
    });
  }
  const result = await parseReceivePackResponse(packfile);
  if (res2.headers) {
    result.headers = res2.headers;
  }
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    const ref2 = `refs/remotes/${remote}/${fullRemoteRef.replace(
      "refs/heads",
      ""
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref: ref2 });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: ref2, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every((result2) => result2.ok)) {
    return result;
  } else {
    const prettyDetails = Object.entries(result.refs).filter(([k, v]) => !v.ok).map(([k, v]) => `
  - ${k}: ${v.error}`).join("");
    throw new GitPushError(prettyDetails, result);
  }
}
async function push$1({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  remoteRef,
  remote = "origin",
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _push({
      fs: new FileSystem(fs),
      cache: cache2,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers
    });
  } catch (err2) {
    err2.caller = "git.push";
    throw err2;
  }
}
async function resolveBlob({ fs, cache: cache2, gitdir, oid }) {
  const { type: type2, object } = await _readObject({ fs, cache: cache2, gitdir, oid });
  if (type2 === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache: cache2, gitdir, oid });
  }
  if (type2 !== "blob") {
    throw new ObjectTypeError(oid, type2, "blob");
  }
  return { oid, blob: new Uint8Array(object) };
}
async function _readBlob({
  fs,
  cache: cache2,
  gitdir,
  oid,
  filepath = void 0
}) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache: cache2, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache: cache2,
    gitdir,
    oid
  });
  return blob;
}
async function readBlob({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  filepath,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readBlob({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid,
      filepath
    });
  } catch (err2) {
    err2.caller = "git.readBlob";
    throw err2;
  }
}
async function readCommit({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readCommit({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid
    });
  } catch (err2) {
    err2.caller = "git.readCommit";
    throw err2;
  }
}
async function _readNote({
  fs,
  cache: cache2,
  gitdir,
  ref = "refs/notes/commits",
  oid
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache: cache2,
    gitdir,
    oid: parent,
    filepath: oid
  });
  return blob;
}
async function readNote({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oid", oid);
    return await _readNote({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      ref,
      oid
    });
  } catch (err2) {
    err2.caller = "git.readNote";
    throw err2;
  }
}
async function readObject({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  format = "parsed",
  filepath = void 0,
  encoding = void 0,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    if (filepath !== void 0) {
      oid = await resolveFilepath({
        fs,
        cache: cache2,
        gitdir,
        oid,
        filepath
      });
    }
    const _format = format === "parsed" ? "content" : format;
    const result = await _readObject({
      fs,
      cache: cache2,
      gitdir,
      oid,
      format: _format
    });
    result.oid = oid;
    if (format === "parsed") {
      result.format = "parsed";
      switch (result.type) {
        case "commit":
          result.object = GitCommit.from(result.object).parse();
          break;
        case "tree":
          result.object = GitTree.from(result.object).entries();
          break;
        case "blob":
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new Uint8Array(result.object);
            result.format = "content";
          }
          break;
        case "tag":
          result.object = GitAnnotatedTag.from(result.object).parse();
          break;
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            "blob|commit|tag|tree"
          );
      }
    } else if (result.format === "deflated" || result.format === "wrapped") {
      result.type = result.format;
    }
    return result;
  } catch (err2) {
    err2.caller = "git.readObject";
    throw err2;
  }
}
async function _readTag({ fs, cache: cache2, gitdir, oid }) {
  const { type: type2, object } = await _readObject({
    fs,
    cache: cache2,
    gitdir,
    oid,
    format: "content"
  });
  if (type2 !== "tag") {
    throw new ObjectTypeError(oid, type2, "tag");
  }
  const tag2 = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag2.parse(),
    payload: tag2.payload()
  };
  return result;
}
async function readTag({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTag({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid
    });
  } catch (err2) {
    err2.caller = "git.readTag";
    throw err2;
  }
}
async function readTree({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  oid,
  filepath = void 0,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTree({
      fs: new FileSystem(fs),
      cache: cache2,
      gitdir,
      oid,
      filepath
    });
  } catch (err2) {
    err2.caller = "git.readTree";
    throw err2;
  }
}
async function remove$2({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache: cache2 },
      async function(index2) {
        index2.delete({ filepath });
      }
    );
  } catch (err2) {
    err2.caller = "git.remove";
    throw err2;
  }
}
async function _removeNote({
  fs,
  cache: cache2,
  onSign,
  gitdir,
  ref = "refs/notes/commits",
  oid,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err2) {
    if (!(err2 instanceof NotFoundError)) {
      throw err2;
    }
  }
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  });
  let tree = result.tree;
  tree = tree.filter((entry) => entry.path !== oid);
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache: cache2,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join$2(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _removeNote({
      fs,
      cache: cache2,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey
    });
  } catch (err2) {
    err2.caller = "git.removeNote";
    throw err2;
  }
}
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout: checkout2 = false
}) {
  if (ref !== cleanGitRef.clean(ref)) {
    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
  }
  if (oldref !== cleanGitRef.clean(oldref)) {
    throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref));
  }
  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;
  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });
  if (newexist) {
    throw new AlreadyExistsError("branch", ref, false);
  }
  const value2 = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 1
  });
  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value: value2 });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });
  const fullCurrentBranchRef = await _currentBranch({
    fs,
    gitdir,
    fullname: true
  });
  const isCurrentBranch = fullCurrentBranchRef === fulloldref;
  if (checkout2 || isCurrentBranch) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullnewref
    });
  }
}
async function renameBranch({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  oldref,
  checkout: checkout2 = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oldref", oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout: checkout2
    });
  } catch (err2) {
    err2.caller = "git.renameBranch";
    throw err2;
  }
}
async function hashObject$1({ gitdir, type: type2, object }) {
  return shasum(GitObject.wrap({ type: type2, object }));
}
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  ref,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    let oid;
    let workdirOid;
    try {
      oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || "HEAD" });
    } catch (e) {
      if (ref) {
        throw e;
      }
    }
    if (oid) {
      try {
        oid = await resolveFilepath({
          fs,
          cache: cache2,
          gitdir,
          oid,
          filepath
        });
      } catch (e) {
        oid = null;
      }
    }
    let stats = {
      ctime: /* @__PURE__ */ new Date(0),
      mtime: /* @__PURE__ */ new Date(0),
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0
    };
    const object = dir && await fs.read(join$2(dir, filepath));
    if (object) {
      workdirOid = await hashObject$1({
        gitdir,
        type: "blob",
        object
      });
      if (oid === workdirOid) {
        stats = await fs.lstat(join$2(dir, filepath));
      }
    }
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      index2.delete({ filepath });
      if (oid) {
        index2.insert({ filepath, stats, oid });
      }
    });
  } catch (err2) {
    err2.caller = "git.reset";
    throw err2;
  }
}
async function resolveRef({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  depth
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth
    });
    return oid;
  } catch (err2) {
    err2.caller = "git.resolveRef";
    throw err2;
  }
}
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  path,
  value: value2,
  append = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value2);
    } else {
      await config.set(path, value2);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err2) {
    err2.caller = "git.setConfig";
    throw err2;
  }
}
async function status$1({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  filepath,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath
    });
    if (ignored) {
      return "ignored";
    }
    const headTree = await getHeadTree({ fs, cache: cache2, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache: cache2,
      gitdir,
      tree: headTree,
      path: filepath
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache: cache2 },
      async function(index2) {
        for (const entry of index2) {
          if (entry.path === filepath)
            return entry;
        }
        return null;
      }
    );
    const stats = await fs.lstat(join$2(dir, filepath));
    const H = treeOid !== null;
    const I = indexEntry !== null;
    const W2 = stats !== null;
    const getWorkdirOid = async () => {
      if (I && !compareStats(indexEntry, stats)) {
        return indexEntry.oid;
      } else {
        const object = await fs.read(join$2(dir, filepath));
        const workdirOid = await hashObject$1({
          gitdir,
          type: "blob",
          object
        });
        if (I && indexEntry.oid === workdirOid) {
          if (stats.size !== -1) {
            GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
              index2.insert({ filepath, stats, oid: workdirOid });
            });
          }
        }
        return workdirOid;
      }
    };
    if (!H && !W2 && !I)
      return "absent";
    if (!H && !W2 && I)
      return "*absent";
    if (!H && W2 && !I)
      return "*added";
    if (!H && W2 && I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === indexEntry.oid ? "added" : "*added";
    }
    if (H && !W2 && !I)
      return "deleted";
    if (H && !W2 && I) {
      return treeOid === indexEntry.oid ? "*deleted" : "*deleted";
    }
    if (H && W2 && !I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? "*undeleted" : "*undeletemodified";
    }
    if (H && W2 && I) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        return workdirOid === indexEntry.oid ? "unmodified" : "*unmodified";
      } else {
        return workdirOid === indexEntry.oid ? "modified" : "*modified";
      }
    }
  } catch (err2) {
    err2.caller = "git.status";
    throw err2;
  }
}
async function getOidAtPath({ fs, cache: cache2, gitdir, tree, path }) {
  if (typeof path === "string")
    path = path.split("/");
  const dirname2 = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname2) {
      if (path.length === 0) {
        return entry.oid;
      }
      const { type: type2, object } = await _readObject({
        fs,
        cache: cache2,
        gitdir,
        oid: entry.oid
      });
      if (type2 === "tree") {
        const tree2 = GitTree.from(object);
        return getOidAtPath({ fs, cache: cache2, gitdir, tree: tree2, path });
      }
      if (type2 === "blob") {
        throw new ObjectTypeError(entry.oid, type2, "blob", path.join("/"));
      }
    }
  }
  return null;
}
async function getHeadTree({ fs, cache: cache2, gitdir }) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
  } catch (e) {
    if (e instanceof NotFoundError) {
      return [];
    }
  }
  const { tree } = await _readTree({ fs, cache: cache2, gitdir, oid });
  return tree;
}
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref = "HEAD",
  filepaths = ["."],
  filter,
  cache: cache2 = {},
  ignored: shouldIgnore = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache: cache2,
      dir,
      gitdir,
      trees: [TREE$1({ ref }), WORKDIR$1(), STAGE$1()],
      map: async function(filepath, [head, workdir, stage]) {
        if (!head && !stage && workdir) {
          if (!shouldIgnore) {
            const isIgnored2 = await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath
            });
            if (isIgnored2) {
              return null;
            }
          }
        }
        if (!filepaths.some((base) => worthWalking(filepath, base))) {
          return null;
        }
        if (filter) {
          if (!filter(filepath))
            return;
        }
        const [headType, workdirType, stageType] = await Promise.all([
          head && head.type(),
          workdir && workdir.type(),
          stage && stage.type()
        ]);
        const isBlob = [headType, workdirType, stageType].includes("blob");
        if ((headType === "tree" || headType === "special") && !isBlob)
          return;
        if (headType === "commit")
          return null;
        if ((workdirType === "tree" || workdirType === "special") && !isBlob)
          return;
        if (stageType === "commit")
          return null;
        if ((stageType === "tree" || stageType === "special") && !isBlob)
          return;
        const headOid = headType === "blob" ? await head.oid() : void 0;
        const stageOid = stageType === "blob" ? await stage.oid() : void 0;
        let workdirOid;
        if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
          workdirOid = "42";
        } else if (workdirType === "blob") {
          workdirOid = await workdir.oid();
        }
        const entry = [void 0, headOid, workdirOid, stageOid];
        const result = entry.map((value2) => entry.indexOf(value2));
        result.shift();
        return [filepath, ...result];
      }
    });
  } catch (err2) {
    err2.caller = "git.statusMatrix";
    throw err2;
  }
}
async function tag({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  object,
  force = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    if (ref === void 0) {
      throw new MissingParameterError("ref");
    }
    ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
    const value2 = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || "HEAD"
    });
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("tag", ref);
    }
    await GitRefManager.writeRef({ fs, gitdir, ref, value: value2 });
  } catch (err2) {
    err2.caller = "git.tag";
    throw err2;
  }
}
async function updateIndex({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  cache: cache2 = {},
  filepath,
  oid,
  mode,
  add: add2,
  remove: remove2,
  force
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    if (remove2) {
      return await GitIndexManager.acquire(
        { fs, gitdir, cache: cache2 },
        async function(index2) {
          let fileStats2;
          if (!force) {
            fileStats2 = await fs.lstat(join$2(dir, filepath));
            if (fileStats2) {
              if (fileStats2.isDirectory()) {
                throw new InvalidFilepathError("directory");
              }
              return;
            }
          }
          if (index2.has({ filepath })) {
            index2.delete({
              filepath
            });
          }
        }
      );
    }
    let fileStats;
    if (!oid) {
      fileStats = await fs.lstat(join$2(dir, filepath));
      if (!fileStats) {
        throw new NotFoundError(
          `file at "${filepath}" on disk and "remove" not set`
        );
      }
      if (fileStats.isDirectory()) {
        throw new InvalidFilepathError("directory");
      }
    }
    return await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      if (!add2 && !index2.has({ filepath })) {
        throw new NotFoundError(
          `file at "${filepath}" in index and "add" not set`
        );
      }
      let stats = {
        ctime: /* @__PURE__ */ new Date(0),
        mtime: /* @__PURE__ */ new Date(0),
        dev: 0,
        ino: 0,
        mode,
        uid: 0,
        gid: 0,
        size: 0
      };
      if (!oid) {
        stats = fileStats;
        const object = stats.isSymbolicLink() ? await fs.readlink(join$2(dir, filepath)) : await fs.read(join$2(dir, filepath));
        oid = await _writeObject({
          fs,
          gitdir,
          type: "blob",
          format: "content",
          object
        });
      }
      index2.insert({
        filepath,
        oid,
        stats
      });
      return oid;
    });
  } catch (err2) {
    err2.caller = "git.updateIndex";
    throw err2;
  }
}
function version() {
  try {
    return pkg.version;
  } catch (err2) {
    err2.caller = "git.version";
    throw err2;
  }
}
async function walk$2({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  trees: trees2,
  map: map2,
  reduce,
  iterate,
  cache: cache2 = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("trees", trees2);
    return await _walk({
      fs: new FileSystem(fs),
      cache: cache2,
      dir,
      gitdir,
      trees: trees2,
      map: map2,
      reduce,
      iterate
    });
  } catch (err2) {
    err2.caller = "git.walk";
    throw err2;
  }
}
async function writeBlob({ fs, dir, gitdir = join$2(dir, ".git"), blob }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("blob", blob);
    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: "blob",
      object: blob,
      format: "content"
    });
  } catch (err2) {
    err2.caller = "git.writeBlob";
    throw err2;
  }
}
async function _writeCommit({ fs, gitdir, commit: commit2 }) {
  const object = GitCommit.from(commit2).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "commit",
    object,
    format: "content"
  });
  return oid;
}
async function writeCommit({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  commit: commit2
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("commit", commit2);
    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit: commit2
    });
  } catch (err2) {
    err2.caller = "git.writeCommit";
    throw err2;
  }
}
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  type: type2,
  object,
  format = "parsed",
  oid,
  encoding = void 0
}) {
  try {
    const fs = new FileSystem(_fs);
    if (format === "parsed") {
      switch (type2) {
        case "commit":
          object = GitCommit.from(object).toObject();
          break;
        case "tree":
          object = GitTree.from(object).toObject();
          break;
        case "blob":
          object = Buffer.from(object, encoding);
          break;
        case "tag":
          object = GitAnnotatedTag.from(object).toObject();
          break;
        default:
          throw new ObjectTypeError(oid || "", type2, "blob|commit|tag|tree");
      }
      format = "content";
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type: type2,
      object,
      oid,
      format
    });
    return oid;
  } catch (err2) {
    err2.caller = "git.writeObject";
    throw err2;
  }
}
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join$2(dir, ".git"),
  ref,
  value: value2,
  force = false,
  symbolic = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("value", value2);
    const fs = new FileSystem(_fs);
    if (ref !== cleanGitRef.clean(ref)) {
      throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
    }
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("ref", ref);
    }
    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value: value2
      });
    } else {
      value2 = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value2
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value: value2
      });
    }
  } catch (err2) {
    err2.caller = "git.writeRef";
    throw err2;
  }
}
async function _writeTag({ fs, gitdir, tag: tag2 }) {
  const object = GitAnnotatedTag.from(tag2).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object,
    format: "content"
  });
  return oid;
}
async function writeTag({ fs, dir, gitdir = join$2(dir, ".git"), tag: tag2 }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tag", tag2);
    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag: tag2
    });
  } catch (err2) {
    err2.caller = "git.writeTag";
    throw err2;
  }
}
async function writeTree({ fs, dir, gitdir = join$2(dir, ".git"), tree }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tree", tree);
    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree
    });
  } catch (err2) {
    err2.caller = "git.writeTree";
    throw err2;
  }
}
async function writeRefsAdResponse({ capabilities, refs, symrefs }) {
  const stream = [];
  let syms = "";
  for (const [key, value2] of Object.entries(symrefs)) {
    syms += `symref=${key}:${value2} `;
  }
  let caps = `\0${[...capabilities].join(" ")} ${syms}agent=${pkg.agent}`;
  for (const [key, value2] of Object.entries(refs)) {
    stream.push(GitPktLine.encode(`${value2} ${key}${caps}
`));
    caps = "";
  }
  stream.push(GitPktLine.flush());
  return stream;
}
async function uploadPack({
  fs,
  dir,
  gitdir = join$2(dir, ".git"),
  advertiseRefs = false
}) {
  try {
    if (advertiseRefs) {
      const capabilities = [
        "thin-pack",
        "side-band",
        "side-band-64k",
        "shallow",
        "deepen-since",
        "deepen-not",
        "allow-tip-sha1-in-want",
        "allow-reachable-sha1-in-want"
      ];
      let keys = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: "refs"
      });
      keys = keys.map((ref) => `refs/${ref}`);
      const refs = {};
      keys.unshift("HEAD");
      for (const key of keys) {
        refs[key] = await GitRefManager.resolve({ fs, gitdir, ref: key });
      }
      const symrefs = {};
      symrefs.HEAD = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: "HEAD",
        depth: 2
      });
      return writeRefsAdResponse({
        capabilities,
        refs,
        symrefs
      });
    }
  } catch (err2) {
    err2.caller = "git.uploadPack";
    throw err2;
  }
}
const deepget = (keys, map2) => {
  for (const key of keys) {
    if (!map2.has(key))
      map2.set(key, /* @__PURE__ */ new Map());
    map2 = map2.get(key);
  }
  return map2;
};
class DeepMap {
  constructor() {
    this._root = /* @__PURE__ */ new Map();
  }
  set(keys, value2) {
    const lastKey = keys.pop();
    const lastMap = deepget(keys, this._root);
    lastMap.set(lastKey, value2);
  }
  get(keys) {
    const lastKey = keys.pop();
    const lastMap = deepget(keys, this._root);
    return lastMap.get(lastKey);
  }
  has(keys) {
    const lastKey = keys.pop();
    const lastMap = deepget(keys, this._root);
    return lastMap.has(lastKey);
  }
}
function fromEntries(map2) {
  const o = {};
  for (const [key, value2] of map2) {
    o[key] = value2;
  }
  return o;
}
function fromNodeStream(stream) {
  const asyncIterator = Object.getOwnPropertyDescriptor(
    stream,
    Symbol.asyncIterator
  );
  if (asyncIterator && asyncIterator.enumerable) {
    return stream;
  }
  let ended = false;
  const queue = [];
  let defer = {};
  stream.on("data", (chunk) => {
    queue.push(chunk);
    if (defer.resolve) {
      defer.resolve({ value: queue.shift(), done: false });
      defer = {};
    }
  });
  stream.on("error", (err2) => {
    if (defer.reject) {
      defer.reject(err2);
      defer = {};
    }
  });
  stream.on("end", () => {
    ended = true;
    if (defer.resolve) {
      defer.resolve({ done: true });
      defer = {};
    }
  });
  return {
    next() {
      return new Promise((resolve2, reject) => {
        if (queue.length === 0 && ended) {
          return resolve2({ done: true });
        } else if (queue.length > 0) {
          return resolve2({ value: queue.shift(), done: false });
        } else if (queue.length === 0 && !ended) {
          defer = { resolve: resolve2, reject };
        }
      });
    },
    return() {
      stream.removeAllListeners();
      if (stream.destroy)
        stream.destroy();
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function fromStream(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    next() {
      return reader.read();
    },
    return() {
      reader.releaseLock();
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function isBinary$1(buffer) {
  const MAX_XDIFF_SIZE = 1024 * 1024 * 1023;
  if (buffer.length > MAX_XDIFF_SIZE)
    return true;
  return buffer.slice(0, 8e3).some((value2) => value2 === 0);
}
async function sleep(ms) {
  return new Promise((resolve2, reject) => setTimeout(resolve2, ms));
}
async function parseUploadPackRequest(stream) {
  const read = GitPktLine.streamReader(stream);
  let done = false;
  let capabilities = null;
  const wants = [];
  const haves = [];
  const shallows = [];
  let depth;
  let since;
  const exclude = [];
  let relative = false;
  while (!done) {
    const line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    const [key, value2, ...rest] = line.toString("utf8").trim().split(" ");
    if (!capabilities)
      capabilities = rest;
    switch (key) {
      case "want":
        wants.push(value2);
        break;
      case "have":
        haves.push(value2);
        break;
      case "shallow":
        shallows.push(value2);
        break;
      case "deepen":
        depth = parseInt(value2);
        break;
      case "deepen-since":
        since = parseInt(value2);
        break;
      case "deepen-not":
        exclude.push(value2);
        break;
      case "deepen-relative":
        relative = true;
        break;
      case "done":
        done = true;
        break;
    }
  }
  return {
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
    relative,
    done
  };
}
var index$1 = {
  Errors,
  STAGE: STAGE$1,
  TREE: TREE$1,
  WORKDIR: WORKDIR$1,
  add: add$4,
  abortMerge,
  addNote,
  addRemote,
  annotatedTag,
  branch,
  checkout: checkout$1,
  clone,
  commit: commit$1,
  getConfig,
  getConfigAll,
  setConfig,
  currentBranch,
  deleteBranch,
  deleteRef,
  deleteRemote,
  deleteTag,
  expandOid,
  expandRef,
  fastForward,
  fetch: fetch$1,
  findMergeBase,
  findRoot,
  getRemoteInfo,
  getRemoteInfo2,
  hashBlob,
  indexPack,
  init,
  isDescendent,
  isIgnored: isIgnored$1,
  listBranches,
  listFiles,
  listNotes,
  listRemotes: listRemotes$1,
  listServerRefs,
  listTags,
  log: log$1,
  merge: merge$2,
  packObjects,
  pull: pull$1,
  push: push$1,
  readBlob,
  readCommit,
  readNote,
  readObject,
  readTag,
  readTree,
  remove: remove$2,
  removeNote,
  renameBranch,
  resetIndex,
  updateIndex,
  resolveRef,
  status: status$1,
  statusMatrix,
  tag,
  version,
  walk: walk$2,
  _walk,
  writeBlob,
  writeCommit,
  writeObject,
  writeRef,
  writeTag,
  writeTree,
  _listObjects: listObjects,
  _pack,
  _uploadPack: uploadPack,
  _GitConfigManager: GitConfigManager,
  _GitIgnoreManager: GitIgnoreManager,
  _GitIndexManager: GitIndexManager,
  _GitRefManager: GitRefManager,
  _GitRemoteHTTP: GitRemoteHTTP,
  _GitRemoteManager: GitRemoteManager,
  _GitShallowManager: GitShallowManager,
  _FileSystem: FileSystem,
  _GitAnnotatedTag: GitAnnotatedTag,
  _GitCommit: GitCommit,
  _GitConfig: GitConfig,
  _GitIndex: GitIndex,
  _GitObject: GitObject,
  _GitPackIndex: GitPackIndex,
  _GitPktLine: GitPktLine,
  _GitRefSpec: GitRefSpec,
  _GitRefSpecSet: GitRefSpecSet,
  _GitSideBand: GitSideBand,
  _GitTree: GitTree,
  _GitWalkerFs: GitWalkerFs,
  _GitWalkerIndex: GitWalkerIndex,
  _GitWalkerRepo: GitWalkerRepo,
  _RunningMinimum: RunningMinimum,
  _expandOid,
  _expandOidLoose: expandOidLoose,
  _expandOidPacked: expandOidPacked,
  _hasObject: hasObject,
  _hasObjectLoose: hasObjectLoose,
  _hasObjectPacked: hasObjectPacked,
  _hashObject: hashObject,
  _readObject,
  _readObjectLoose: readObjectLoose,
  _readObjectPacked: readObjectPacked,
  _readPackIndex: readPackIndex,
  _writeObject,
  _writeObjectLoose: writeObjectLoose,
  _BufferCursor: BufferCursor,
  _DeepMap: DeepMap,
  _FIFO: FIFO,
  _StreamReader: StreamReader,
  _abbreviateRef: abbreviateRef,
  _applyDelta: applyDelta,
  _arrayRange: arrayRange,
  _assertParameter: assertParameter,
  // _asyncIteratorToStream,
  _basename: basename,
  _calculateBasicAuthHeader: calculateBasicAuthHeader,
  _collect: collect$1,
  _compareAge: compareAge,
  _comparePath: comparePath,
  _compareRefNames: compareRefNames,
  _compareStats: compareStats,
  _compareStrings: compareStrings,
  _compareTreeEntryPath: compareTreeEntryPath,
  _deflate: deflate,
  _dirname: dirname,
  _emptyPackfile: emptyPackfile,
  _extractAuthFromUrl: extractAuthFromUrl,
  _filterCapabilities: filterCapabilities,
  _flat: flat,
  _flatFileListToDirectoryStructure: flatFileListToDirectoryStructure,
  _forAwait: forAwait$1,
  _formatAuthor: formatAuthor,
  _formatInfoRefs: formatInfoRefs,
  _fromEntries: fromEntries,
  _fromNodeStream: fromNodeStream,
  _fromStream: fromStream,
  _fromValue: fromValue$1,
  _getIterator: getIterator$1,
  _listpack: listpack,
  _utils_hashObject: hashObject$1,
  _indent: indent$1,
  _inflate: inflate,
  _isBinary: isBinary$1,
  _join: join$2,
  _mergeFile: mergeFile,
  _mergeTree: mergeTree,
  _mode2type: mode2type,
  _modified: modified,
  _normalizeAuthorObject: normalizeAuthorObject,
  _normalizeCommitterObject: normalizeCommitterObject,
  _normalizeMode: normalizeMode,
  _normalizeNewlines: normalizeNewlines,
  _normalizePath: normalizePath,
  _normalizeStats: normalizeStats,
  _outdent: outdent,
  _padHex: padHex$1,
  _parseAuthor: parseAuthor,
  _pkg: pkg,
  _posixifyPathBuffer: posixifyPathBuffer,
  _resolveBlob: resolveBlob,
  _resolveCommit: resolveCommit,
  _resolveFileIdInTree: resolveFileIdInTree,
  _resolveFilepath: resolveFilepath,
  _resolveTree: resolveTree,
  _rmRecursive: rmRecursive,
  _shasum: shasum,
  _sleep: sleep,
  _splitLines: splitLines,
  // _symbols,
  _toHex: toHex,
  _translateSSHtoHTTP: translateSSHtoHTTP,
  _unionOfIterators: unionOfIterators,
  _worthWalking: worthWalking,
  _parseCapabilitiesV2: parseCapabilitiesV2,
  _parseListRefsResponse: parseListRefsResponse,
  _parseReceivePackResponse: parseReceivePackResponse,
  _parseRefsAdResponse: parseRefsAdResponse,
  _parseUploadPackRequest: parseUploadPackRequest,
  _parseUploadPackResponse: parseUploadPackResponse,
  _writeListRefsRequest: writeListRefsRequest,
  _writeReceivePackRequest: writeReceivePackRequest,
  _writeRefsAdResponse: writeRefsAdResponse,
  _writeUploadPackRequest: writeUploadPackRequest
};
async function add$3(ctx, state, filepath) {
  await state.ensureFirstBatch();
  return await index$1.add({
    fs: ctx.rawFs,
    parallel: true,
    dir: ctx.dir,
    cache: ctx.cache,
    filepath
  });
}
async function remove$1(ctx, state, filepath) {
  await state.ensureFirstBatch();
  return await index$1.remove({
    fs: ctx.rawFs,
    dir: ctx.dir,
    cache: ctx.cache,
    filepath
  });
}
const isoCommit = (ctx, { author, message }) => commit$1({
  fs: ctx.rawFs,
  dir: ctx.dir,
  cache: ctx.cache,
  author: author || ctx.author,
  message
});
async function commit(ctx, state, { author: overrideAuthor, message, include }) {
  if (include) {
    const additions = [];
    const deletions = [];
    for (const entry of include) {
      if (await ctx.rawFs.lstat(entry).catch(() => void 0)) {
        additions.push(entry);
      } else {
        deletions.push(entry);
      }
    }
    additions.length && await add$3(ctx, state, additions);
    deletions.length && await Promise.all(deletions.map((del) => remove$1(ctx, state, del)));
  }
  const commitArgs = {
    fs: state.nodeishFs,
    dir: ctx.dir,
    cache: ctx.cache,
    author: overrideAuthor || ctx.author,
    message
  };
  if (ctx.experimentalFeatures.lixCommit) {
    console.warn("using experimental commit for this repo.");
    return doCommit(commitArgs);
  } else {
    return commit$1(commitArgs);
  }
}
async function doCommit({ cache: cache2, fs, dir, ref, author, message }) {
  const fileStates = {};
  async function createTree(currentFolder, fileStates2) {
    const entries = [];
    const currentFolderStates = fileStates2[currentFolder];
    if (!currentFolderStates) {
      throw new Error("couldn't find folder " + currentFolder + " in file states");
    }
    for (const entry of currentFolderStates) {
      if (entry.type === "tree") {
        entries.push({
          mode: "040000",
          path: entry.path,
          type: entry.type,
          oid: await createTree(currentFolder + entry.path + "/", fileStates2)
        });
      } else {
        if (!entry.oid) {
          throw new Error("OID should be set for types except tree");
        }
        entries.push({
          mode: entry.mode,
          path: entry.path,
          type: entry.type,
          oid: entry.oid
        });
      }
    }
    return await writeTree({ fs, dir, tree: entries });
  }
  await walk$2({
    fs,
    dir,
    cache: cache2,
    // gitdir,
    trees: [TREE$1({ ref }), STAGE$1()],
    // @ts-ignore FIXME
    map: async function(filepath, [refState, stagingState]) {
      var _a2, _b2, _c;
      if (!refState && !stagingState) {
        throw new Error("At least one of the trees should contain an entry");
      }
      const refStateType = refState ? await refState.type() : void 0;
      const stagingStateType = stagingState ? await stagingState.type() : void 0;
      if (refStateType === "commit" || stagingStateType === "commit") {
        throw new Error("Submodule found in " + filepath + " currently not supported");
      }
      if (refStateType === "special" || stagingStateType === "special") {
        throw new Error("type special should not occure in ref or staging");
      }
      if (filepath === ".") {
        return;
      }
      const fileDir = getDirname(filepath);
      if (fileStates[fileDir] === void 0) {
        fileStates[fileDir] = [];
      }
      if (!stagingState && refState) {
        if (refStateType === "tree" || fs._isPlaceholder && fs._isPlaceholder(filepath)) {
          (_a2 = fileStates[fileDir]) == null ? void 0 : _a2.push({
            mode: (await refState.mode()).toString(8),
            path: getBasename(filepath),
            type: refStateType,
            oid: await refState.oid()
          });
          return;
        }
        return;
      }
      if (stagingState && !refState) {
        const stMode = await stagingState.mode();
        (_b2 = fileStates[fileDir]) == null ? void 0 : _b2.push({
          mode: stMode == null ? void 0 : stMode.toString(8),
          path: getBasename(filepath),
          type: stagingStateType,
          oid: await stagingState.oid()
        });
        return;
      }
      if (stagingState && refState) {
        const stagingMode = await stagingState.mode();
        const stagingType = await stagingState.type();
        (_c = fileStates[fileDir]) == null ? void 0 : _c.push({
          mode: stagingType === "tree" ? "040000" : stagingMode.toString(8),
          path: getBasename(filepath),
          type: stagingStateType,
          oid: await stagingState.oid()
        });
        return;
      }
    }
    // TODO: use reduce to build datastructure? reduce: async function (parent, children) {},
  });
  const tree = await createTree("/", fileStates);
  return commit$1({
    cache: cache2,
    fs,
    dir,
    author,
    message,
    tree
  });
}
const fileModeTypeMapping = {
  "40": "folder",
  "10": "file",
  "12": "symlink"
};
function modeToFileType(mode) {
  const fileMode = mode.toString(8).slice(0, 2);
  return fileModeTypeMapping[fileMode] || "unknown";
}
const {
  walk: walk$1,
  // _walk expects cache to always exist.
  TREE,
  WORKDIR,
  STAGE,
  isIgnored
} = index$1;
function isoNormalizePath(path) {
  return path.replace(/\/\.\//g, "/").replace(/\/{2,}/g, "/").replace(/^\/\.$/, "/").replace(/^\.\/$/, ".").replace(/^\.\//, "").replace(/\/\.$/, "").replace(/(.+)\/$/, "$1").replace(/^$/, ".");
}
function join$1(...parts) {
  return isoNormalizePath(parts.map(isoNormalizePath).join("/"));
}
async function statusList(ctx, state, statusArg) {
  return await _statusList({
    fs: ctx.rawFs,
    ensureFirstBatch: state.ensureFirstBatch,
    dir: ctx.dir,
    cache: ctx.cache,
    sparseFilter: state.sparseFilter,
    filter: statusArg == null ? void 0 : statusArg.filter,
    filepaths: statusArg == null ? void 0 : statusArg.filepaths,
    includeStatus: statusArg == null ? void 0 : statusArg.includeStatus
  });
}
async function _statusList({
  fs,
  ensureFirstBatch,
  dir = "/",
  gitdir = join$1(dir, ".git"),
  ref = "HEAD",
  filepaths = ["."],
  filter,
  sparseFilter,
  // experimental, not yet exposed as lix api!
  cache: cache2,
  includeStatus = [],
  addHashes = false
}) {
  try {
    await ensureFirstBatch();
    const ignoredRes = [];
    const walkRes = await walk$1({
      fs,
      cache: cache2,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      /**
       * Taken from the isomorphic-git documentation of walk's map function:
       *
       * This is the function that is called once per entry BEFORE visiting the children of that node.
       * (1) If you return null for a tree entry, then none of the children of that tree entry will be walked - but the tree entry is still part of the results.
       * (2) If you do not return a value (or return undefined) that entry will be filtered from the results.
       */
      map: async function(filepath, [head, workdir, stage]) {
        var _a2;
        if (!head && !stage && workdir) {
          const ignored = await isIgnored({ fs, dir, filepath });
          if (ignored) {
            if (includeStatus.includes("ignored") || filepaths.includes(filepath)) {
              ignoredRes.push([
                filepath,
                "ignored",
                { headOid: void 0, workdirOid: "ignored", stageOid: void 0 }
              ]);
            }
            return null;
          }
        }
        if (!filepaths.some((base) => worthWalking(filepath, base))) {
          return null;
        }
        if (filter && !filter(filepath)) {
          return void 0;
        }
        if (fs._isPlaceholder && fs._isPlaceholder(filepath)) {
          if (includeStatus.includes("unmodified") || filepaths.includes(filepath)) {
            const headType2 = head && await head.type();
            if (headType2 !== "blob") {
              throw new Error("Placeholder file is not a blob in head: " + filepath);
            }
            const headOid2 = await (head == null ? void 0 : head.oid());
            return [
              filepath,
              "unmodified",
              { headOid: headOid2, workdirOid: headOid2, stageOid: headOid2, placeholder: true }
            ];
          }
          return null;
        }
        let types2;
        try {
          types2 = await Promise.all([
            head && head.type(),
            workdir && workdir.type(),
            stage && stage.type()
          ]);
        } catch (error) {
          return null;
        }
        const [headType, workdirType, stageType] = types2;
        const isBlob = [headType, workdirType, stageType].includes("blob");
        if (sparseFilter) {
          const fileMode = await ((_a2 = head || workdir) == null ? void 0 : _a2.mode());
          const fileType = modeToFileType(fileMode);
          if (!sparseFilter({
            filename: filepath,
            type: fileType
          })) {
            return null;
          }
        }
        if ((headType === "tree" || headType === "special") && !isBlob) {
          return void 0;
        }
        if (headType === "commit") {
          return null;
        }
        if ((workdirType === "tree" || workdirType === "special") && !isBlob) {
          return void 0;
        }
        if (stageType === "commit") {
          return null;
        }
        if ((stageType === "tree" || stageType === "special") && !isBlob) {
          return void 0;
        }
        const headOid = headType === "blob" ? await (head == null ? void 0 : head.oid()) : void 0;
        const stageOid = stageType === "blob" ? await (stage == null ? void 0 : stage.oid()) : void 0;
        let workdirOid;
        if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
          workdirOid = addHashes ? await (workdir == null ? void 0 : workdir.oid()) : "42";
        } else if (workdirType === "blob") {
          workdirOid = await (workdir == null ? void 0 : workdir.oid());
        }
        const entry = { headOid, workdirOid, stageOid };
        if (entry.headOid === entry.workdirOid && entry.workdirOid === entry.stageOid) {
          if (includeStatus.includes("unmodified") || filepaths.includes(filepath) || includeStatus.includes("materialized")) {
            return [filepath, "unmodified", entry];
          } else {
            return void 0;
          }
        }
        if (!entry.headOid && !entry.stageOid && entry.workdirOid) {
          return [filepath, "*untracked", entry];
        }
        if (!entry.headOid && entry.workdirOid && entry.workdirOid === entry.stageOid) {
          return [filepath, "added", entry];
        }
        if (!entry.headOid && entry.stageOid && entry.workdirOid && entry.workdirOid !== entry.stageOid) {
          return [filepath, "*added2", entry];
        }
        if (entry.headOid && entry.workdirOid && entry.headOid === entry.stageOid && entry.headOid !== entry.workdirOid) {
          return [filepath, "*modified", entry];
        }
        if (entry.headOid && entry.workdirOid && entry.stageOid && entry.stageOid !== entry.headOid && entry.stageOid !== entry.workdirOid && entry.headOid !== entry.workdirOid) {
          return [filepath, "*modified2", entry];
        }
        if (entry.headOid && entry.workdirOid && entry.headOid !== entry.stageOid && entry.stageOid === entry.workdirOid) {
          return [filepath, "modified", entry];
        }
        if (entry.headOid && !entry.workdirOid && entry.headOid === entry.stageOid) {
          return [filepath, "*deleted", entry];
        }
        if (entry.headOid && !entry.workdirOid && !entry.stageOid) {
          return [filepath, "deleted", entry];
        }
        if (!entry.headOid && !entry.workdirOid && entry.stageOid) {
          return [filepath, "*absent", entry];
        }
        if (entry.headOid && entry.workdirOid && !entry.stageOid && entry.headOid !== entry.workdirOid) {
          return [filepath, "*undeletemodified", entry];
        }
        if (entry.headOid && entry.workdirOid && entry.stageOid && entry.stageOid !== entry.headOid && entry.headOid === entry.workdirOid) {
          return [filepath, "*unmodified", entry];
        }
        if (entry.headOid && entry.workdirOid && !entry.stageOid && entry.headOid === entry.workdirOid) {
          return [filepath, "*undeleted", entry];
        }
        return [filepath, "unknown", entry];
      }
    });
    return [...walkRes, ...ignoredRes];
  } catch (err2) {
    err2.caller = "lix.status";
    throw err2;
  }
}
async function status(ctx, state, filepath) {
  if (typeof filepath !== "string") {
    throw new Error("parameter must be a string");
  }
  const statusList$1 = await statusList(ctx, state, {
    filepaths: [filepath]
  });
  const maybeStatusEntry = statusList$1[0] || [filepath, "unknown"];
  return maybeStatusEntry == null ? void 0 : maybeStatusEntry[1];
}
function fromValue(value2) {
  let queue = [value2];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value: value2, done } = await iter.next();
    if (value2)
      await cb(value2);
    if (done)
      break;
  }
  if (iter.return)
    iter.return();
}
async function collect(iterable) {
  let size = 0;
  const buffers = [];
  await forAwait(iterable, (value2) => {
    buffers.push(value2);
    size += value2.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
let cache$1 = /* @__PURE__ */ new Map();
let cacheDisabler;
function makeHttpClient({ noCache, debug, description, onReq, onRes }) {
  async function request2({ url, method = "GET", headers = {}, body: rawBody }) {
    let body = rawBody ? await collect(rawBody) : void 0;
    const origUrl = url;
    const origMethod = method;
    if (!noCache && cache$1 && origMethod === "GET" && cache$1.has(origUrl)) {
      const { resHeaders: resHeaders2, resBody: resBody2 } = cache$1.get(origUrl);
      return {
        url: origUrl,
        method: origMethod,
        statusCode: 200,
        statusMessage: "OK",
        body: resBody2,
        headers: resHeaders2
      };
    }
    if (onReq) {
      const rewritten = await onReq({ body, url, method });
      method = (rewritten == null ? void 0 : rewritten.method) || method;
      headers = (rewritten == null ? void 0 : rewritten.headers) || headers;
      body = (rewritten == null ? void 0 : rewritten.body) || body;
      url = (rewritten == null ? void 0 : rewritten.url) || url;
    }
    const res2 = await fetch(url, { method, headers, body, credentials: "include" });
    let resHeaders = {};
    for (const [key, value2] of res2.headers.entries()) {
      resHeaders[key] = value2;
    }
    if (debug) {
      console.warn(`${description} git req:`, origUrl);
    }
    const statusCode = res2.status;
    let resBody;
    const uint8Array = res2.body && new Uint8Array(await res2.arrayBuffer());
    if (debug && statusCode === 200 && uint8Array) {
      const { inflatePackResponse } = await import("../packfile-8529df01.js");
      console.info(await inflatePackResponse(uint8Array).catch((err2) => err2));
    }
    if (onRes) {
      const rewritten = await onRes({
        origUrl,
        usedUrl: url,
        resBody: uint8Array,
        statusCode,
        resHeaders
      });
      resHeaders = (rewritten == null ? void 0 : rewritten.resHeaders) || resHeaders;
      resBody = (rewritten == null ? void 0 : rewritten.resBody) || [uint8Array];
    }
    if (!resBody) {
      resBody = [uint8Array];
    }
    if (!noCache && cache$1 && statusCode === 200 && origMethod === "GET") {
      if (!cacheDisabler) {
        cacheDisabler = setTimeout(() => {
          cache$1 == null ? void 0 : cache$1.clear();
          cache$1 = void 0;
        }, 15e3);
      }
      cache$1.set(origUrl, { resHeaders, resBody });
    }
    return {
      url: origUrl,
      method: origMethod,
      statusCode,
      statusMessage: res2.statusText,
      body: resBody,
      headers: resHeaders
    };
  }
  return { request: request2 };
}
const push = async (ctx) => {
  if (!ctx.gitUrl) {
    throw new Error("Could not find repo url, only github supported for push at the moment");
  }
  return await index$1.push({
    fs: ctx.rawFs,
    url: ctx.gitUrl,
    cache: ctx.cache,
    corsProxy: ctx.gitProxyUrl,
    http: makeHttpClient({ debug: ctx.debug, description: "push" }),
    dir: ctx.dir
  });
};
async function __checkout({ fs, cache: cache2, onProgress, dir, gitdir, remote, ref, filepaths, noCheckout, noUpdateHead, dryRun, force, track = true }) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
  } catch (err2) {
    if (ref === "HEAD") {
      throw err2;
    }
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef
    });
    if (track) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid
    });
  }
  if (!noCheckout) {
    let ops;
    try {
      ops = await analyze({
        fs,
        cache: cache2,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths
      });
    } catch (err2) {
      if (err2 instanceof Errors.NotFoundError && err2.data.what === oid) {
        throw new Errors.CommitNotFetchedError(ref, oid);
      } else {
        throw err2;
      }
    }
    const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new Errors.CheckoutConflictError(conflicts);
    }
    const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new Errors.InternalError(errors.join(", "));
    }
    if (dryRun) {
      return;
    }
    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      await Promise.all(
        // @ts-ignore
        ops.filter(([method]) => method === "delete" || method === "delete-index").map(async function([method, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          if (method === "delete") {
            await fs.rm(filepath);
          }
          index2.delete({ filepath: fullpath });
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: ++count,
              total
            });
          }
        })
      );
    });
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      for (const [method, fullpath] of ops) {
        if (method === "rmdir" || method === "rmdir-index") {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === "rmdir-index") {
              index2.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            if (e.code === "ENOTEMPTY") {
              console.log(`Did not delete ${fullpath} because directory is not empty`);
            } else {
              throw e;
            }
          }
        }
      }
    });
    await Promise.all(ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_, fullpath]) {
      const filepath = `${dir}/${fullpath}`;
      await fs.mkdir(filepath);
      if (onProgress) {
        await onProgress({
          phase: "Updating workdir",
          loaded: ++count,
          total
        });
      }
    }));
    await GitIndexManager.acquire({ fs, gitdir, cache: cache2 }, async function(index2) {
      await Promise.all(
        // @ts-ignore
        ops.filter(
          // @ts-ignore
          ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
        ).map(async function([method, fullpath, oid2, mode, chmod]) {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method !== "create-index" && method !== "mkdir-index") {
              const { object } = await _readObject({ fs, cache: cache2, gitdir, oid: oid2 });
              if (chmod) {
                await fs.rm(filepath);
              }
              if (mode === 33188) {
                await fs.write(filepath, object);
              } else if (mode === 33261) {
                await fs.write(filepath, object, { mode: 511 });
              } else if (mode === 40960) {
                await fs.writelink(filepath, object);
              } else {
                throw new Errors.InternalError(`Invalid mode 0o${mode.toString(8)} detected in blob ${oid2}`);
              }
            }
            const stats = await fs.lstat(filepath);
            if (mode === 33261) {
              stats.mode = 493;
            }
            if (method === "mkdir-index") {
              stats.mode = 57344;
            }
            index2.insert({
              filepath: fullpath,
              stats,
              oid: oid2
            });
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            console.log(e);
          }
        })
      );
    });
  }
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith("refs/heads")) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: "HEAD",
        value: fullRef
      });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
    }
  }
}
async function analyze({ fs, cache: cache2, onProgress, dir, gitdir, ref, force, filepaths }) {
  let count = 0;
  return _walk({
    fs,
    cache: cache2,
    dir,
    gitdir,
    trees: [TREE$1({ ref }), WORKDIR$1(), STAGE$1()],
    // @ts-ignore
    map: async function(fullpath, [commit2, workdir, stage]) {
      if (fullpath === ".")
        return;
      if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
        return null;
      }
      if (onProgress) {
        await onProgress({ phase: "Analyzing workdir", loaded: ++count });
      }
      const key = [!!stage, !!commit2, !!workdir].map(Number).join("");
      switch (key) {
        case "000":
          return;
        case "001":
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ["delete", fullpath];
          }
          return;
        case "010": {
          switch (await commit2.type()) {
            case "tree": {
              return ["mkdir", fullpath];
            }
            case "blob": {
              return ["create", fullpath, await commit2.oid(), await commit2.mode()];
            }
            case "commit": {
              return ["mkdir-index", fullpath, await commit2.oid(), await commit2.mode()];
            }
            default: {
              return ["error", `new entry Unhandled type ${await commit2.type()}`];
            }
          }
        }
        case "011": {
          switch (`${await commit2.type()}-${await workdir.type()}`) {
            case "tree-tree": {
              return;
            }
            case "tree-blob":
            case "blob-tree": {
              return ["conflict", fullpath];
            }
            case "blob-blob": {
              if (await commit2.oid() !== await workdir.oid()) {
                if (force) {
                  return [
                    "update",
                    fullpath,
                    // @ts-ignore
                    await commit2.oid(),
                    // @ts-ignore
                    await commit2.mode(),
                    // @ts-ignore
                    await commit2.mode() !== await workdir.mode()
                  ];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                if (await commit2.mode() !== await workdir.mode()) {
                  if (force) {
                    return ["update", fullpath, await commit2.oid(), await commit2.mode(), true];
                  } else {
                    return ["conflict", fullpath];
                  }
                } else {
                  return ["create-index", fullpath, await commit2.oid(), await commit2.mode()];
                }
              }
            }
            case "commit-tree": {
              return;
            }
            case "commit-blob": {
              return ["conflict", fullpath];
            }
            default: {
              return ["error", `new entry Unhandled type ${commit2.type}`];
            }
          }
        }
        case "100": {
          return ["delete-index", fullpath];
        }
        case "101": {
          switch (await stage.type()) {
            case "tree": {
              return ["rmdir", fullpath];
            }
            case "blob": {
              if (await stage.oid() !== await workdir.oid()) {
                if (force) {
                  return ["delete", fullpath];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                return ["delete", fullpath];
              }
            }
            case "commit": {
              return ["rmdir-index", fullpath];
            }
            default: {
              return ["error", `delete entry Unhandled type ${await stage.type()}`];
            }
          }
        }
        case "110":
        case "111": {
          switch (`${await stage.type()}-${await commit2.type()}`) {
            case "tree-tree": {
              return;
            }
            case "blob-blob": {
              if (
                // @ts-ignore
                await stage.oid() === await commit2.oid() && // @ts-ignore
                await stage.mode() === await commit2.mode() && !force
              ) {
                return;
              }
              if (workdir) {
                if (
                  // @ts-ignore
                  await workdir.oid() !== await stage.oid() && // @ts-ignore
                  await workdir.oid() !== await commit2.oid()
                ) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      // @ts-ignore
                      await commit2.oid(),
                      // @ts-ignore
                      await commit2.mode(),
                      // @ts-ignore
                      await commit2.mode() !== await workdir.mode()
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                }
              } else if (force) {
                return [
                  "update",
                  fullpath,
                  // @ts-ignore
                  await commit2.oid(),
                  // @ts-ignore
                  await commit2.mode(),
                  // @ts-ignore
                  await commit2.mode() !== await stage.mode()
                ];
              }
              if (await commit2.mode() !== await stage.mode()) {
                return ["update", fullpath, await commit2.oid(), await commit2.mode(), true];
              }
              if (await commit2.oid() !== await stage.oid()) {
                return ["update", fullpath, await commit2.oid(), await commit2.mode(), false];
              } else {
                return;
              }
            }
            case "tree-blob": {
              return ["update-dir-to-blob", fullpath, await commit2.oid()];
            }
            case "blob-tree": {
              return ["update-blob-to-tree", fullpath];
            }
            case "commit-commit": {
              return ["mkdir-index", fullpath, await commit2.oid(), await commit2.mode()];
            }
            default: {
              return [
                "error",
                // @ts-ignore
                `update entry Unhandled type ${await stage.type()}-${await commit2.type()}`
              ];
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children;
      } else if (parent && parent[0] === "rmdir") {
        children.push(parent);
        return children;
      } else {
        children.unshift(parent);
        return children;
      }
    }
  });
}
async function checkout(ctx, state, { branch: branch2 }) {
  state.branchName = branch2;
  if (ctx.useLazyFS) {
    throw new Error("not implemented for lazy lix mode yet, use openRepo with different branch instead");
  }
  return await _checkout({
    fs: ctx.rawFs,
    cache: ctx.cache,
    dir: ctx.dir,
    ref: state.branchName
  });
}
async function _checkout({ fs, onProgress, dir, gitdir = join$2(dir, ".git"), remote = "origin", ref: _ref, filepaths, noCheckout = false, noUpdateHead = _ref === void 0, dryRun = false, force = false, track = true, cache: cache2 = {} }) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const ref = _ref || "HEAD";
    return await __checkout({
      fs: new FileSystem(fs),
      cache: cache2,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track
    });
  } catch (err2) {
    err2.caller = "git.checkout";
    throw err2;
  }
}
async function emptyWorkdir(ctx, state) {
  const { rawFs, cache: cache2 } = ctx;
  state.pending && await state.pending;
  const statusResult = await statusList(ctx, state, { includeStatus: ["materialized", "ignored"] });
  const ignored = [];
  const materialized = [];
  const dirty = [];
  for (const [path, status2] of statusResult) {
    if (status2 === "unmodified") {
      materialized.push(path);
    } else if (status2 === "ignored") {
      ignored.push("/" + path);
    } else {
      dirty.push(path);
    }
  }
  if (dirty.length > 0) {
    console.error(dirty);
    throw new Error("could not empty the workdir, uncommitted changes");
  }
  const listing = await allFiles(rawFs, ignored);
  await Promise.all(listing.map((entry) => rawFs.rm(entry).catch((err2) => {
    console.warn(err2);
  }).then(() => index$1.remove({
    fs: rawFs,
    dir: "/",
    cache: cache2,
    filepath: entry
  }))));
  return materialized;
}
async function allFiles(fs, ignored, root = "/") {
  const entries = await fs.readdir(root);
  const notIgnored = entries.filter((entry) => !ignored.includes(root + entry));
  const withMeta = await Promise.all(notIgnored.map(async (entry) => {
    var _a2, _b2;
    return {
      name: entry,
      isDir: (_b2 = (_a2 = await fs.lstat(root + entry).catch((err2) => {
        console.warn(err2);
      })) == null ? void 0 : _a2.isDirectory) == null ? void 0 : _b2.call(_a2)
    };
  }));
  const withChildren = await Promise.all(withMeta.map(async ({ name, isDir }) => isDir ? allFiles(fs, ignored, root + name + "/") : root + name));
  return withChildren.flat().map((entry) => entry.replace(/^\//, ""));
}
function padHex(pad, n) {
  const s = n.toString(16);
  return "0".repeat(pad - s.length) + s;
}
const WANT_PREFIX = "want ";
function overrideWants(lines, oids) {
  oids = [...new Set(oids)];
  const newLines = [];
  let wantsCount = 0;
  let lastLineWasAWants = false;
  for (const line of lines) {
    if (line.startsWith(WANT_PREFIX)) {
      lastLineWasAWants = true;
      if (oids.length > wantsCount) {
        const postOidCurrentLine = line.slice(Math.max(0, WANT_PREFIX.length + oids[wantsCount].length));
        newLines.push(`${WANT_PREFIX}${oids[wantsCount]}${postOidCurrentLine}`);
      }
      wantsCount += 1;
    }
    if (!line.startsWith(WANT_PREFIX)) {
      if (lastLineWasAWants && oids.length > wantsCount) {
        while (oids.length > wantsCount) {
          newLines.push(WANT_PREFIX + oids[wantsCount] + "\n");
          wantsCount += 1;
        }
        lastLineWasAWants = false;
      }
      newLines.push(line);
    }
  }
  return newLines;
}
function addWantsCapabilities(lines) {
  let capabilitiesAdded = false;
  const updatedLines = [];
  for (let line of lines) {
    if (line.startsWith(WANT_PREFIX) && !capabilitiesAdded) {
      line = line.slice(0, Math.max(0, line.length - 1)) + " allow-tip-sha1-in-want allow-reachable-sha1-in-want\n";
      line = line.replace("ofs-delta", "");
      capabilitiesAdded = true;
    }
    updatedLines.push(line);
  }
  return updatedLines;
}
function addNoProgress(lines) {
  let capabilitiesAdded = false;
  const updatedLines = [];
  for (let line of lines) {
    if (line.startsWith(WANT_PREFIX) && !capabilitiesAdded) {
      line = line.slice(0, Math.max(0, line.length - 1)) + " no-progress\n";
      capabilitiesAdded = true;
    }
    updatedLines.push(line);
  }
  return updatedLines;
}
function addBlobNoneFilter(lines) {
  let filterCapabilityAdded = false;
  let filterAdded = false;
  const updatedLines = [];
  const flushLine = "";
  for (let line of lines) {
    if (line.startsWith("want") && !filterCapabilityAdded) {
      line = line.slice(0, Math.max(0, line.length - 1)) + " filter\n";
      filterCapabilityAdded = true;
    }
    if (!filterAdded && (line.startsWith("deepen-since") || line.startsWith("deepen-not") || line === flushLine)) {
      updatedLines.push("filter blob:none\n");
      filterAdded = true;
    }
    updatedLines.push(line);
  }
  return updatedLines;
}
function overrideHaves(lines, oids) {
  oids = [...new Set(oids)];
  const linesWithoutHaves = [];
  const flushLine = "";
  for (const line of lines) {
    if (!line.startsWith("have ")) {
      linesWithoutHaves.push(line);
    }
  }
  const updatedLines = [];
  for (const line of linesWithoutHaves) {
    updatedLines.push(line);
    if (line === flushLine) {
      for (const oid of oids) {
        updatedLines.push("have " + oid + "\n");
      }
    }
  }
  return updatedLines;
}
async function blobExistsLocaly({ fs, oid, gitdir, cache: cache2 }) {
  try {
    return await hasObject({
      // fs must not be intercepted - we don't want to intercept calls of read Object  // TODO #1459 can we check this by type checking or an added flag property for better dx?
      fs: new FileSystem(fs),
      oid,
      gitdir,
      cache: cache2,
      // NOTE: we use deflated to stop early in _readObject no hashing etc is happening for format deflated
      format: "deflated"
    });
  } catch (err2) {
    if (err2.code !== "ENOENT" && err2.code !== "NotFoundError") {
      throw err2;
    }
  }
  return false;
}
function encodePackLine(line) {
  const flushLine = "";
  if (line === flushLine) {
    const paddedHex = padHex(4, 0);
    return paddedHex;
  }
  const length = line.length + 4;
  const hexLength = padHex(4, length);
  const lineWithLength = hexLength + line;
  return lineWithLength;
}
function decodeGitPackLines(concatenatedUint8Array) {
  const strings2 = [];
  let offset = 0;
  while (offset + 4 < concatenatedUint8Array.length) {
    const hexLength = new TextDecoder().decode(concatenatedUint8Array.subarray(offset, offset + 4));
    const packLineLength = parseInt(hexLength, 16);
    if (packLineLength === 0) {
      strings2.push("");
      offset += 4;
    } else if (packLineLength === 1) {
      throw new Error("decodeGitPackLines does not support delimiter yet");
    } else {
      const contentStart = offset + 4;
      const stringData = new TextDecoder().decode(concatenatedUint8Array.subarray(contentStart, offset + packLineLength));
      offset += packLineLength;
      strings2.push(stringData);
    }
  }
  return strings2;
}
async function optimizeReq(gitConfig = {}, { method, url, body }) {
  var _a2;
  if (url.endsWith("info/refs?service=git-upload-pack") && gitConfig.addRefs !== void 0) {
    const uploadPackUrl = url.replace("info/refs?service=git-upload-pack", "git-upload-pack");
    const lines = [];
    lines.push(encodePackLine("command=ls-refs"));
    lines.push(encodePackLine("agent=lix") + "0001");
    if (((_a2 = gitConfig.addRefs) == null ? void 0 : _a2.length) > 0) {
      for (let ref of gitConfig.addRefs) {
        if (!ref.startsWith("refs/")) {
          ref = "refs/heads/" + ref;
        }
        lines.push(encodePackLine("ref-prefix " + ref));
      }
    }
    lines.push(encodePackLine("ref-prefix HEAD"));
    lines.push(encodePackLine("symrefs"));
    lines.push(encodePackLine(""));
    return {
      url: uploadPackUrl,
      body: lines.join(""),
      method: "POST",
      headers: {
        accept: "application/x-git-upload-pack-result",
        "content-type": "application/x-git-upload-pack-request",
        "git-protocol": "version=2"
      }
    };
  }
  if (method === "POST") {
    let rawLines = decodeGitPackLines(body);
    if (gitConfig.noBlobs) {
      rawLines = addBlobNoneFilter(rawLines);
    }
    if (gitConfig.overrideHaves) {
      rawLines = overrideHaves(rawLines, gitConfig.overrideHaves);
    }
    rawLines = addNoProgress(rawLines);
    if (gitConfig.overrideWants) {
      rawLines = addWantsCapabilities(rawLines);
      rawLines = overrideWants(rawLines, gitConfig.overrideWants);
    }
    const newBody = rawLines.map((updatedRawLine) => encodePackLine(updatedRawLine)).join("");
    return {
      body: newBody
    };
  }
  return void 0;
}
async function optimizeRes({ origUrl, resBody, statusCode, resHeaders }) {
  if (!origUrl.endsWith("info/refs?service=git-upload-pack") || statusCode !== 200) {
    return void 0;
  }
  const capabilites = [
    "multi_ack",
    "thin-pack",
    "side-band",
    "side-band-64k",
    "ofs-delta",
    "shallow",
    "deepen-since",
    "deepen-not",
    "deepen-relative",
    "no-progress",
    "include-tag",
    "multi_ack_detailed",
    "allow-tip-sha1-in-want",
    "allow-reachable-sha1-in-want",
    "no-done",
    "filter",
    "object-format=sha1"
  ];
  const origLines = decodeGitPackLines(resBody);
  const rewrittenLines = ["# service=git-upload-pack\n", ""];
  let headSymref = "";
  for (const line of origLines) {
    if (line.includes("HEAD symref-target")) {
      headSymref = "refs" + line.slice(64).replace("\n", "");
      const headBlob = line.slice(0, 40);
      rewrittenLines.push(headBlob + " HEAD\0" + capabilites.join(" ") + " symref=HEAD:" + headSymref);
      rewrittenLines.push(headBlob + " " + headSymref);
    } else {
      rewrittenLines.push(line.replace("\n", ""));
    }
  }
  rewrittenLines.push("");
  resHeaders["content-type"] = "application/x-git-upload-pack-advertisement";
  const bodyString = rewrittenLines.map((updatedRawLine) => encodePackLine(updatedRawLine)).join("");
  return {
    resHeaders,
    resBody: [new TextEncoder().encode(bodyString)]
  };
}
async function checkOutPlaceholders(ctx, state, { materializeGitignores = true, preload = [] } = {}) {
  const { rawFs, cache: cache2, dir } = ctx;
  const { branchName, checkedOut, sparseFilter } = state;
  await _checkout({
    fs: ctx.rawFs,
    cache: cache2,
    dir,
    ref: branchName,
    filepaths: []
  });
  const fs = rawFs;
  const gitignoreFiles = [];
  let rootHash;
  await index$1.walk({
    fs,
    dir,
    cache: cache2,
    gitdir: ".git",
    trees: [index$1.TREE({ ref: branchName })],
    map: async function(fullpath, [commit2]) {
      if (!commit2) {
        return void 0;
      }
      if (fullpath.endsWith(".gitignore")) {
        gitignoreFiles.push(fullpath);
      }
      const fileMode = await commit2.mode();
      const oid = await commit2.oid();
      if (fullpath === ".") {
        rootHash = oid;
      }
      const fileType = modeToFileType(fileMode);
      if (sparseFilter && !sparseFilter({
        filename: fullpath,
        type: fileType
      })) {
        return void 0;
      }
      if (fileType === "folder" && !checkedOut.has(fullpath)) {
        return fullpath;
      }
      if (fileType === "file" && !checkedOut.has(fullpath)) {
        await fs._createPlaceholder(fullpath, { mode: fileMode, oid, rootHash });
        return fullpath;
      }
      if (fileType === "symlink" && !checkedOut.has(fullpath)) {
        await fs._createPlaceholder(fullpath, { mode: fileMode, oid, rootHash });
        return fullpath;
      }
      console.warn("ignored checkout palcholder path", fullpath, fileType);
      return void 0;
    }
  });
  if (gitignoreFiles.length && materializeGitignores) {
    preload = [...gitignoreFiles, ...preload];
  }
  await state.ensureFirstBatch({ preload });
  return { gitignoreFiles };
}
async function pull(ctx, state, cmdArgs) {
  if (!ctx.gitUrl) {
    throw new Error("Could not find repo url, only github supported for pull at the moment");
  }
  const branchName = state.branchName || await index$1.currentBranch({ fs: ctx.rawFs, dir: "/" }) || "HEAD";
  const oid = await index$1.resolveRef({
    fs: ctx.rawFs,
    dir: "/",
    ref: "refs/remotes/origin/" + branchName
  });
  const { commit: commit2 } = await index$1.readCommit({ fs: ctx.rawFs, dir: "/", oid });
  const since = new Date(commit2.committer.timestamp * 1e3);
  const { fetchHead, fetchHeadDescription } = await index$1.fetch({
    since,
    fs: ctx.rawFs,
    cache: ctx.cache,
    http: makeHttpClient({
      debug: ctx.debug,
      description: "pull",
      onReq: ctx.experimentalFeatures.lazyClone ? optimizeReq.bind(null, {
        noBlobs: true,
        addRefs: [branchName]
      }) : void 0,
      onRes: ctx.experimentalFeatures.lazyClone ? optimizeRes : void 0
    }),
    corsProxy: ctx.gitProxyUrl,
    ref: branchName,
    tags: false,
    dir: ctx.dir,
    url: ctx.gitUrl,
    // remote: "origin",
    // remoteRef,
    singleBranch: cmdArgs.singleBranch || true
  });
  if (!fetchHead) {
    throw new Error("could not fetch head");
  }
  let materialized = [];
  if (ctx.experimentalFeatures.lazyClone) {
    materialized = await emptyWorkdir(ctx, state);
    ctx.debug && console.info("experimental checkout after pull preload:", materialized);
    state.checkedOut.clear();
  }
  const mergeDriver = ({ branches, contents, path }) => {
    console.info("mergeDriver", branches, contents, path);
    ctx.rawFs.writeFile(path + `.${branches[2].slice(0, 4)}.conflict`, contents[2] || "");
    return { cleanMerge: true, mergedText: contents[1] || "" };
  };
  const mergeRes = await index$1.merge({
    fs: state.nodeishFs,
    cache: ctx.cache,
    dir: ctx.dir,
    ours: branchName,
    theirs: fetchHead,
    fastForward: cmdArgs.fastForward === false ? false : true,
    message: `Merge ${fetchHeadDescription}`,
    author: cmdArgs.author || ctx.author,
    dryRun: false,
    noUpdateBranch: false,
    abortOnConflict: true,
    mergeDriver: ctx.experimentalFeatures.lixMerge ? mergeDriver : void 0
    // different to native git this replaces the default 3 way merge
    // committer,
    // signingKey,
    // fastForwardOnly,
  }).catch((error) => ({ error }));
  console.info("mergeRes", { data: mergeRes.data, code: mergeRes.code, error: mergeRes.error });
  if (ctx.experimentalFeatures.lazyClone) {
    await checkOutPlaceholders(ctx, state, { preload: materialized });
  } else {
    await _checkout({
      fs: ctx.rawFs,
      cache: ctx.cache,
      dir: ctx.dir,
      ref: branchName,
      noCheckout: false
    });
  }
}
async function listRemotes(ctx, state) {
  try {
    const remotes = await index$1.listRemotes({
      fs: state.nodeishFs,
      dir: ctx.dir
    });
    return remotes;
  } catch (_err) {
    return void 0;
  }
}
async function log(ctx, cmdArgs) {
  return await index$1.log({
    fs: ctx.rawFs,
    depth: cmdArgs == null ? void 0 : cmdArgs.depth,
    filepath: cmdArgs == null ? void 0 : cmdArgs.filepath,
    dir: ctx.dir,
    ref: cmdArgs == null ? void 0 : cmdArgs.ref,
    cache: ctx.cache,
    since: cmdArgs == null ? void 0 : cmdArgs.since,
    force: cmdArgs == null ? void 0 : cmdArgs.force,
    follow: cmdArgs == null ? void 0 : cmdArgs.follow
  });
}
async function getOrigin(ctx, state) {
  const remotes = await listRemotes(ctx, state) || [];
  return await parseOrigin({ remotes });
}
async function getBranches(ctx) {
  if (!ctx.gitUrl) {
    throw new Error("Could not find repo url, only github supported for getBranches at the moment");
  }
  let serverRefs;
  try {
    serverRefs = await index$1.listServerRefs({
      url: ctx.gitUrl,
      corsProxy: ctx.gitProxyUrl,
      prefix: "refs/heads",
      http: makeHttpClient({ debug: ctx.debug, noCache: true, description: "getBranches" })
    });
  } catch (_error) {
    return void 0;
  }
  return serverRefs.filter((ref) => !ref.ref.startsWith("refs/heads/gh-readonly-queue/")).map((ref) => ref.ref.replace("refs/heads/", "")) || void 0;
}
async function getCurrentBranch(ctx, state) {
  return await index$1.currentBranch({
    fs: state.nodeishFs,
    dir: ctx.dir
  }) || void 0;
}
async function getMeta(ctx) {
  var _a2, _b2, _c;
  const { gitUrl, owner, repoName, githubClient } = ctx;
  if (!gitUrl) {
    throw new Error("Could not find repo url, only github supported for getMeta at the moment");
  }
  const res2 = await githubClient.getRepo({ repoName, owner });
  let isInstalled = false;
  const installResult = await githubClient.getInstallations();
  if (!("error" in installResult)) {
    const found = installResult.installations.find((i) => i.account.login === owner);
    if ((found == null ? void 0 : found.repository_selection) === "all") {
      isInstalled = true;
    } else if (found) {
      const repoResult = await githubClient.getAvailableRepos(found.id);
      if (!("error" in repoResult) && repoResult.repositories.find((r) => r.full_name === `${owner}/${repoName}`)) {
        isInstalled = true;
      }
    }
  }
  if ("error" in res2) {
    return { error: res2.error };
  } else {
    return {
      allowForking: res2.data.allow_forking,
      name: res2.data.name,
      isPrivate: res2.data.private,
      isFork: res2.data.fork,
      isInstalled,
      permissions: {
        admin: ((_a2 = res2.data.permissions) == null ? void 0 : _a2.admin) || false,
        push: ((_b2 = res2.data.permissions) == null ? void 0 : _b2.push) || false,
        pull: ((_c = res2.data.permissions) == null ? void 0 : _c.pull) || false
      },
      owner: {
        type: res2.data.owner.type.toLowerCase(),
        name: res2.data.owner.name || void 0,
        email: res2.data.owner.email || void 0,
        login: res2.data.owner.login
      },
      parent: res2.data.parent ? {
        url: transformRemote(res2.data.parent.git_url) || "unknown",
        fullName: res2.data.parent.full_name
      } : void 0
    };
  }
}
async function forkStatus(ctx) {
  const { gitUrl, debug, dir, cache: cache2, owner, repoName, githubClient, gitProxyUrl } = ctx;
  if (!gitUrl) {
    throw new Error("Could not find repo url, only github supported for forkStatus at the moment");
  }
  const { isFork, parent, error } = await getMeta(ctx);
  if (error) {
    return { error: "could check fork status of repo" };
  }
  if (!isFork) {
    return { error: "repo is not a fork" };
  }
  const useBranchName = await index$1.currentBranch({
    fs: ctx.rawFs,
    dir,
    fullname: false
  });
  if (!useBranchName) {
    return { error: "could not get fork status for detached head" };
  }
  await index$1.addRemote({
    dir,
    remote: "upstream",
    url: "https://" + parent.url,
    fs: ctx.rawFs
  });
  try {
    await index$1.fetch({
      depth: 1,
      singleBranch: true,
      dir,
      cache: cache2,
      ref: useBranchName,
      remote: "upstream",
      http: makeHttpClient({
        debug,
        description: "forkStatus",
        onReq: ctx.experimentalFeatures.lazyClone ? optimizeReq.bind(null, {
          noBlobs: true,
          addRefs: [useBranchName || "HEAD"]
        }) : void 0,
        onRes: ctx.experimentalFeatures.lazyClone ? optimizeRes : void 0
      }),
      tags: false,
      fs: ctx.rawFs
    });
  } catch (err2) {
    return { error: err2 };
  }
  const currentUpstreamCommit = await index$1.resolveRef({
    fs: ctx.rawFs,
    dir: "/",
    ref: "upstream/" + useBranchName
  });
  const currentOriginCommit = await index$1.resolveRef({
    fs: ctx.rawFs,
    dir: "/",
    ref: useBranchName
  });
  if (currentUpstreamCommit === currentOriginCommit) {
    return { ahead: 0, behind: 0, conflicts: void 0 };
  }
  const compare = await githubClient.compare({
    owner,
    repoName,
    base: currentUpstreamCommit,
    head: currentOriginCommit
  }).catch((newError) => {
    return { error: newError };
  });
  if ("error" in compare || !("data" in compare)) {
    return { error: compare.error || "could not diff repos on github" };
  }
  const ahead = compare.data.ahead_by;
  const behind = compare.data.behind_by;
  await index$1.fetch({
    depth: behind + 1,
    remote: "upstream",
    cache: cache2,
    singleBranch: true,
    dir,
    ref: useBranchName,
    http: makeHttpClient({ debug, description: "forkStatus" }),
    fs: ctx.rawFs
  });
  await index$1.fetch({
    depth: ahead + 1,
    cache: cache2,
    singleBranch: true,
    ref: useBranchName,
    dir,
    http: makeHttpClient({ debug, description: "forkStatus" }),
    corsProxy: gitProxyUrl,
    fs: ctx.rawFs
  });
  let conflicts;
  try {
    await index$1.merge({
      fs: ctx.rawFs,
      cache: cache2,
      author: { name: "lix" },
      dir,
      ours: useBranchName,
      dryRun: true,
      theirs: "upstream/" + useBranchName,
      noUpdateBranch: true,
      abortOnConflict: true
    });
  } catch (err2) {
    conflicts = {
      data: err2.data,
      code: err2.code
    };
    console.warn(conflicts);
  }
  return { ahead, behind, conflicts };
}
async function createFork(ctx) {
  return await ctx.githubClient.createFork({
    owner: ctx.owner,
    repo: ctx.repoName
  });
}
async function mergeUpstream(ctx, cmdArgs = {}) {
  if (!ctx.gitUrl) {
    throw new Error("Could not find repo url, only github supported for mergeUpstream at the moment");
  }
  const branch2 = (cmdArgs == null ? void 0 : cmdArgs.branch) || await index$1.currentBranch({
    fs: ctx.rawFs,
    dir: ctx.dir,
    fullname: false
  });
  if (typeof branch2 !== "string") {
    throw "could not get current branch";
  }
  let response;
  try {
    response = await ctx.githubClient.mergeUpstream({
      branch: branch2,
      owner: ctx.owner,
      repoName: ctx.repoName
    });
  } catch (error) {
    return { error };
  }
  return (response == null ? void 0 : response.data) || response.error;
}
async function getFirstCommitHash(ctx) {
  var _a2;
  const getFirstCommitFs = ctx.rawFs;
  const maybeShallow = !!await getFirstCommitFs.readFile(ctx.dir + "/.git/shallow", { encoding: "utf-8" }).catch(() => void 0);
  if (maybeShallow) {
    console.warn("shallow clone detected, not generating first commit hash.");
    return void 0;
  }
  if (ctx.useLazyFS) {
    try {
      await index$1.fetch({
        singleBranch: true,
        dir: ctx.dir,
        depth: 2147483647,
        http: makeHttpClient({ debug: ctx.debug, description: "getFirstCommitHash" }),
        corsProxy: ctx.gitProxyUrl,
        fs: getFirstCommitFs
      });
    } catch {
      return void 0;
    }
  }
  let firstCommitHash = "HEAD";
  for (; ; ) {
    const commits = await index$1.log({
      fs: getFirstCommitFs,
      depth: 550,
      dir: ctx.dir,
      ref: firstCommitHash
    }).catch((error) => {
      return { error };
    });
    if ("error" in commits) {
      firstCommitHash = void 0;
      break;
    }
    const lastHashInPage = (_a2 = commits.at(-1)) == null ? void 0 : _a2.oid;
    if (lastHashInPage) {
      firstCommitHash = lastHashInPage;
    }
    if (commits.length < 550) {
      break;
    }
  }
  return firstCommitHash;
}
const whitelistedExperimentalRepos = [
  "inlang/example",
  "opral/example",
  "inlang/ci-test-repo",
  "opral/ci-test-repo",
  "opral/monorepo",
  "inlang/example-test",
  "opral/example-test",
  "janfjohannes/inlang-example",
  "janfjohannes/cal.com",
  "niklasbuchfink/appflowy",
  "jldec/load-test"
];
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}
const distWeb$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getUserAgent
}, Symbol.toStringTag, { value: "Module" }));
var beforeAfterHook = { exports: {} };
var register_1 = register$1;
function register$1(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce(function(callback, name2) {
      return register$1.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(function() {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce(function(method2, registered) {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}
var add$2 = addHook$1;
function addHook$1(state, kind, name, hook2) {
  var orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = function(method, options) {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = function(method, options) {
      var result;
      return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
        result = result_;
        return orig(result, options);
      }).then(function() {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = function(method, options) {
      return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}
var remove = removeHook$1;
function removeHook$1(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  var index2 = state.registry[name].map(function(registered) {
    return registered.orig;
  }).indexOf(method);
  if (index2 === -1) {
    return;
  }
  state.registry[name].splice(index2, 1);
}
var register = register_1;
var addHook = add$2;
var removeHook = remove;
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach(function(kind) {
    var args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function HookSingular() {
  var singularHookName = "h";
  var singularHookState = {
    registry: {}
  };
  var singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function HookCollection() {
  var state = {
    registry: {}
  };
  var hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var collectionHookDeprecationMessageDisplayed = false;
function Hook() {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn(
      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
    );
    collectionHookDeprecationMessageDisplayed = true;
  }
  return HookCollection();
}
Hook.Singular = HookSingular.bind();
Hook.Collection = HookCollection.bind();
beforeAfterHook.exports = Hook;
beforeAfterHook.exports.Hook = Hook;
beforeAfterHook.exports.Singular = Hook.Singular;
var Collection = beforeAfterHook.exports.Collection = Hook.Collection;
const VERSION$d = "9.0.5";
const userAgent = `octokit-endpoint.js/${VERSION$d} ${getUserAgent()}`;
const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject$1(value2) {
  if (typeof value2 !== "object" || value2 === null)
    return false;
  if (Object.prototype.toString.call(value2) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value2);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value2);
}
function mergeDeep(defaults2, options) {
  const result = Object.assign({}, defaults2);
  Object.keys(options).forEach((key) => {
    if (isPlainObject$1(options[key])) {
      if (!(key in defaults2))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults2[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge$1(defaults2, route, options) {
  var _a2;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults2 || {}, options);
  if (options.url === "/graphql") {
    if (defaults2 && ((_a2 = defaults2.mediaType.previews) == null ? void 0 : _a2.length)) {
      mergedOptions.mediaType.previews = defaults2.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
const urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str2) {
  return str2.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str2) {
  return encodeURIComponent(str2).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value2, key) {
  value2 = operator === "+" || operator === "#" ? encodeReserved(value2) : encodeUnreserved(value2);
  if (key) {
    return encodeUnreserved(key) + "=" + value2;
  } else {
    return value2;
  }
}
function isDefined(value2) {
  return value2 !== void 0 && value2 !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value2 = context[key], result = [];
  if (isDefined(value2) && value2 !== "") {
    if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
      value2 = value2.toString();
      if (modifier && modifier !== "*") {
        value2 = value2.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value2)) {
          value2.filter(isDefined).forEach(function(value22) {
            result.push(
              encodeValue(operator, value22, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value2).forEach(function(k) {
            if (isDefined(value2[k])) {
              result.push(encodeValue(operator, value2[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value2)) {
          value2.filter(isDefined).forEach(function(value22) {
            tmp.push(encodeValue(operator, value22));
          });
        } else {
          Object.keys(value2).forEach(function(k) {
            if (isDefined(value2[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value2[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value2)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value2 === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value2 === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse$2(options) {
  var _a2;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a2 = options.mediaType.previews) == null ? void 0 : _a2.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults2, route, options) {
  return parse$2(merge$1(defaults2, route, options));
}
function withDefaults$2(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge$1(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults$2.bind(null, DEFAULTS2),
    merge: merge$1.bind(null, DEFAULTS2),
    parse: parse$2
  });
}
const endpoint = withDefaults$2(null, DEFAULTS);
const VERSION$c = "8.4.0";
function isPlainObject(value2) {
  if (typeof value2 !== "object" || value2 === null)
    return false;
  if (Object.prototype.toString.call(value2) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value2);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value2);
}
class Deprecation extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
}
var once$2 = { exports: {} };
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb)
    return wrappy$1(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var wrappy = wrappy_1;
once$2.exports = wrappy(once);
once$2.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once(fn) {
  var f = function() {
    if (f.called)
      return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
var onceExports = once$2.exports;
const once$1 = /* @__PURE__ */ getDefaultExportFromCjs(onceExports);
const logOnceCode = once$1((deprecation) => console.warn(deprecation));
const logOnceHeaders = once$1((deprecation) => console.warn(deprecation));
class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a2, _b2, _c, _d;
  const log2 = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a2 = requestOptions.request) == null ? void 0 : _a2.parseSuccessResponseBody) !== false;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status2;
  let url;
  let { fetch: fetch2 } = globalThis;
  if ((_b2 = requestOptions.request) == null ? void 0 : _b2.fetch) {
    fetch2 = requestOptions.request.fetch;
  }
  if (!fetch2) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch2(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
    headers: requestOptions.headers,
    signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status2 = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log2.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status2 === 204 || status2 === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status2 < 400) {
        return;
      }
      throw new RequestError(response.statusText, status2, {
        response: {
          url,
          status: status2,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status2 === 304) {
      throw new RequestError("Not modified", status2, {
        response: {
          url,
          status: status2,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status2 >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status2, {
        response: {
          url,
          status: status2,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status: status2,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults$1(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults$1.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults$1.bind(null, endpoint2)
  });
}
const request = withDefaults$1(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION$c} ${getUserAgent()}`
  }
});
var VERSION$b = "7.1.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
withDefaults(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION$b} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}
const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth$4(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook$4(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
const createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth$4.bind(null, token), {
    hook: hook$4.bind(null, token)
  });
};
var VERSION$a = "5.2.0";
var noop$1 = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION$a} ${getUserAgent()}`;
var Octokit$1 = (_a = class {
  static defaults(defaults2) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults2 === "function") {
          super(defaults2(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults2,
            options,
            options.userAgent && defaults2.userAgent ? {
              userAgent: `${options.userAgent} ${defaults2.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a2;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a2 = class extends this {
    }, _a2.plugins = currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    ), _a2);
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop$1,
        info: noop$1,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
}, _a.VERSION = VERSION$a, _a.plugins = [], _a);
const distWeb$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Octokit: Octokit$1
}, Symbol.toStringTag, { value: "Module" }));
var VERSION$9 = "9.2.1";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results2, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results2;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results2 = results2.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results2;
    }
    return gather(octokit, results2, iterator2, mapFn);
  });
}
Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION$9;
const generateMessage = (path, cursorValue) => `The cursor at "${path.join(
  ","
)}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`;
class MissingCursorChange extends Error {
  constructor(pageInfo, cursorValue) {
    super(generateMessage(pageInfo.pathInQuery, cursorValue));
    this.pageInfo = pageInfo;
    this.cursorValue = cursorValue;
    this.name = "MissingCursorChangeError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
class MissingPageInfo extends Error {
  constructor(response) {
    super(
      `No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(
        response,
        null,
        2
      )}`
    );
    this.response = response;
    this.name = "MissingPageInfo";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
const isObject$5 = (value2) => Object.prototype.toString.call(value2) === "[object Object]";
function findPaginatedResourcePath(responseData) {
  const paginatedResourcePath = deepFindPathToProperty(
    responseData,
    "pageInfo"
  );
  if (paginatedResourcePath.length === 0) {
    throw new MissingPageInfo(responseData);
  }
  return paginatedResourcePath;
}
const deepFindPathToProperty = (object, searchProp, path = []) => {
  for (const key of Object.keys(object)) {
    const currentPath = [...path, key];
    const currentValue = object[key];
    if (currentValue.hasOwnProperty(searchProp)) {
      return currentPath;
    }
    if (isObject$5(currentValue)) {
      const result = deepFindPathToProperty(
        currentValue,
        searchProp,
        currentPath
      );
      if (result.length > 0) {
        return result;
      }
    }
  }
  return [];
};
const get = (object, path) => {
  return path.reduce((current2, nextProperty) => current2[nextProperty], object);
};
const set$1 = (object, path, mutator) => {
  const lastProperty = path[path.length - 1];
  const parentPath = [...path].slice(0, -1);
  const parent = get(object, parentPath);
  if (typeof mutator === "function") {
    parent[lastProperty] = mutator(parent[lastProperty]);
  } else {
    parent[lastProperty] = mutator;
  }
};
const extractPageInfos = (responseData) => {
  const pageInfoPath = findPaginatedResourcePath(responseData);
  return {
    pathInQuery: pageInfoPath,
    pageInfo: get(responseData, [...pageInfoPath, "pageInfo"])
  };
};
const isForwardSearch = (givenPageInfo) => {
  return givenPageInfo.hasOwnProperty("hasNextPage");
};
const getCursorFrom = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;
const hasAnotherPage = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;
const createIterator = (octokit) => {
  return (query, initialParameters = {}) => {
    let nextPageExists = true;
    let parameters = { ...initialParameters };
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!nextPageExists)
            return { done: true, value: {} };
          const response = await octokit.graphql(
            query,
            parameters
          );
          const pageInfoContext = extractPageInfos(response);
          const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);
          nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);
          if (nextPageExists && nextCursorValue === parameters.cursor) {
            throw new MissingCursorChange(pageInfoContext, nextCursorValue);
          }
          parameters = {
            ...parameters,
            cursor: nextCursorValue
          };
          return { done: false, value: response };
        }
      })
    };
  };
};
const mergeResponses = (response1, response2) => {
  if (Object.keys(response1).length === 0) {
    return Object.assign(response1, response2);
  }
  const path = findPaginatedResourcePath(response1);
  const nodesPath = [...path, "nodes"];
  const newNodes = get(response2, nodesPath);
  if (newNodes) {
    set$1(response1, nodesPath, (values) => {
      return [...values, ...newNodes];
    });
  }
  const edgesPath = [...path, "edges"];
  const newEdges = get(response2, edgesPath);
  if (newEdges) {
    set$1(response1, edgesPath, (values) => {
      return [...values, ...newEdges];
    });
  }
  const pageInfoPath = [...path, "pageInfo"];
  set$1(response1, pageInfoPath, get(response2, pageInfoPath));
  return response1;
};
const createPaginate = (octokit) => {
  const iterator2 = createIterator(octokit);
  return async (query, initialParameters = {}) => {
    let mergedResponse = {};
    for await (const response of iterator2(
      query,
      initialParameters
    )) {
      mergedResponse = mergeResponses(mergedResponse, response);
    }
    return mergedResponse;
  };
};
function paginateGraphql(octokit) {
  octokit.graphql;
  return {
    graphql: Object.assign(octokit.graphql, {
      paginate: Object.assign(createPaginate(octokit), {
        iterator: createIterator(octokit)
      })
    })
  };
}
const VERSION$8 = "10.4.1";
const Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: [
      "DELETE /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
      }
    ],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: [
      "GET /repos/{owner}/{repo}/import/authors",
      {},
      {
        deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
      }
    ],
    getImportStatus: [
      "GET /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
      }
    ],
    getLargeFiles: [
      "GET /repos/{owner}/{repo}/import/large_files",
      {},
      {
        deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
      }
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: [
      "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
      {},
      {
        deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
      }
    ],
    setLfsPreference: [
      "PATCH /repos/{owner}/{repo}/import/lfs",
      {},
      {
        deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
      }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: [
      "PUT /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
      }
    ],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: [
      "PATCH /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
      }
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteCustomOrganizationRole: [
      "DELETE /orgs/{org}/organization-roles/{role_id}"
    ],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    patchCustomOrganizationRole: [
      "PATCH /orgs/{org}/organization-roles/{role_id}"
    ],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;
const endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults2, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults2
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
const handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value2) {
    return target.cache[methodName] = value2;
  },
  get({ octokit, scope, cache: cache2 }, methodName) {
    if (cache2[methodName]) {
      return cache2[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache2[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache2[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache2[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults2, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults2);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION$8;
async function errorRequest(state, octokit, error, options) {
  if (!error.request || !error.request.request) {
    throw error;
  }
  if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
    const retries = options.request.retries != null ? options.request.retries : state.retries;
    const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
    throw octokit.retry.retryRequest(error, retries, retryAfter);
  }
  throw error;
}
var light = { exports: {} };
(function(module, exports) {
  (function(global, factory2) {
    module.exports = factory2();
  })(commonjsGlobal, function() {
    var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : {};
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    var load2 = function(received, defaults2, onto = {}) {
      var k, ref, v;
      for (k in defaults2) {
        v = defaults2[k];
        onto[k] = (ref = received[k]) != null ? ref : v;
      }
      return onto;
    };
    var overwrite = function(received, defaults2, onto = {}) {
      var k, v;
      for (k in received) {
        v = received[k];
        if (defaults2[k] !== void 0) {
          onto[k] = v;
        }
      }
      return onto;
    };
    var parser = {
      load: load2,
      overwrite
    };
    var DLList;
    DLList = class DLList {
      constructor(incr, decr) {
        this.incr = incr;
        this.decr = decr;
        this._first = null;
        this._last = null;
        this.length = 0;
      }
      push(value2) {
        var node;
        this.length++;
        if (typeof this.incr === "function") {
          this.incr();
        }
        node = {
          value: value2,
          prev: this._last,
          next: null
        };
        if (this._last != null) {
          this._last.next = node;
          this._last = node;
        } else {
          this._first = this._last = node;
        }
        return void 0;
      }
      shift() {
        var value2;
        if (this._first == null) {
          return;
        } else {
          this.length--;
          if (typeof this.decr === "function") {
            this.decr();
          }
        }
        value2 = this._first.value;
        if ((this._first = this._first.next) != null) {
          this._first.prev = null;
        } else {
          this._last = null;
        }
        return value2;
      }
      first() {
        if (this._first != null) {
          return this._first.value;
        }
      }
      getArray() {
        var node, ref, results2;
        node = this._first;
        results2 = [];
        while (node != null) {
          results2.push((ref = node, node = node.next, ref.value));
        }
        return results2;
      }
      forEachShift(cb) {
        var node;
        node = this.shift();
        while (node != null) {
          cb(node), node = this.shift();
        }
        return void 0;
      }
      debug() {
        var node, ref, ref1, ref2, results2;
        node = this._first;
        results2 = [];
        while (node != null) {
          results2.push((ref = node, node = node.next, {
            value: ref.value,
            prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
            next: (ref2 = ref.next) != null ? ref2.value : void 0
          }));
        }
        return results2;
      }
    };
    var DLList_1 = DLList;
    var Events;
    Events = class Events {
      constructor(instance) {
        this.instance = instance;
        this._events = {};
        if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
          throw new Error("An Emitter already exists for this object");
        }
        this.instance.on = (name, cb) => {
          return this._addListener(name, "many", cb);
        };
        this.instance.once = (name, cb) => {
          return this._addListener(name, "once", cb);
        };
        this.instance.removeAllListeners = (name = null) => {
          if (name != null) {
            return delete this._events[name];
          } else {
            return this._events = {};
          }
        };
      }
      _addListener(name, status2, cb) {
        var base;
        if ((base = this._events)[name] == null) {
          base[name] = [];
        }
        this._events[name].push({ cb, status: status2 });
        return this.instance;
      }
      listenerCount(name) {
        if (this._events[name] != null) {
          return this._events[name].length;
        } else {
          return 0;
        }
      }
      async trigger(name, ...args) {
        var e, promises;
        try {
          if (name !== "debug") {
            this.trigger("debug", `Event triggered: ${name}`, args);
          }
          if (this._events[name] == null) {
            return;
          }
          this._events[name] = this._events[name].filter(function(listener) {
            return listener.status !== "none";
          });
          promises = this._events[name].map(async (listener) => {
            var e2, returned;
            if (listener.status === "none") {
              return;
            }
            if (listener.status === "once") {
              listener.status = "none";
            }
            try {
              returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
              if (typeof (returned != null ? returned.then : void 0) === "function") {
                return await returned;
              } else {
                return returned;
              }
            } catch (error) {
              e2 = error;
              {
                this.trigger("error", e2);
              }
              return null;
            }
          });
          return (await Promise.all(promises)).find(function(x) {
            return x != null;
          });
        } catch (error) {
          e = error;
          {
            this.trigger("error", e);
          }
          return null;
        }
      }
    };
    var Events_1 = Events;
    var DLList$1, Events$1, Queues;
    DLList$1 = DLList_1;
    Events$1 = Events_1;
    Queues = class Queues {
      constructor(num_priorities) {
        this.Events = new Events$1(this);
        this._length = 0;
        this._lists = function() {
          var j, ref, results2;
          results2 = [];
          for (j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? ++j : --j) {
            results2.push(new DLList$1(() => {
              return this.incr();
            }, () => {
              return this.decr();
            }));
          }
          return results2;
        }.call(this);
      }
      incr() {
        if (this._length++ === 0) {
          return this.Events.trigger("leftzero");
        }
      }
      decr() {
        if (--this._length === 0) {
          return this.Events.trigger("zero");
        }
      }
      push(job) {
        return this._lists[job.options.priority].push(job);
      }
      queued(priority) {
        if (priority != null) {
          return this._lists[priority].length;
        } else {
          return this._length;
        }
      }
      shiftAll(fn) {
        return this._lists.forEach(function(list) {
          return list.forEachShift(fn);
        });
      }
      getFirst(arr = this._lists) {
        var j, len, list;
        for (j = 0, len = arr.length; j < len; j++) {
          list = arr[j];
          if (list.length > 0) {
            return list;
          }
        }
        return [];
      }
      shiftLastFrom(priority) {
        return this.getFirst(this._lists.slice(priority).reverse()).shift();
      }
    };
    var Queues_1 = Queues;
    var BottleneckError;
    BottleneckError = class BottleneckError extends Error {
    };
    var BottleneckError_1 = BottleneckError;
    var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser$1 = parser;
    BottleneckError$1 = BottleneckError_1;
    Job = class Job {
      constructor(task, args, options, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
        this.task = task;
        this.args = args;
        this.rejectOnDrop = rejectOnDrop;
        this.Events = Events2;
        this._states = _states;
        this.Promise = Promise2;
        this.options = parser$1.load(options, jobDefaults);
        this.options.priority = this._sanitizePriority(this.options.priority);
        if (this.options.id === jobDefaults.id) {
          this.options.id = `${this.options.id}-${this._randomIndex()}`;
        }
        this.promise = new this.Promise((_resolve, _reject) => {
          this._resolve = _resolve;
          this._reject = _reject;
        });
        this.retryCount = 0;
      }
      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NUM_PRIORITIES - 1) {
          return NUM_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }
      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }
      doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
        if (this._states.remove(this.options.id)) {
          if (this.rejectOnDrop) {
            this._reject(error != null ? error : new BottleneckError$1(message));
          }
          this.Events.trigger("dropped", { args: this.args, options: this.options, task: this.task, promise: this.promise });
          return true;
        } else {
          return false;
        }
      }
      _assertStatus(expected) {
        var status2;
        status2 = this._states.jobStatus(this.options.id);
        if (!(status2 === expected || expected === "DONE" && status2 === null)) {
          throw new BottleneckError$1(`Invalid job status ${status2}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
        }
      }
      doReceive() {
        this._states.start(this.options.id);
        return this.Events.trigger("received", { args: this.args, options: this.options });
      }
      doQueue(reachedHWM, blocked) {
        this._assertStatus("RECEIVED");
        this._states.next(this.options.id);
        return this.Events.trigger("queued", { args: this.args, options: this.options, reachedHWM, blocked });
      }
      doRun() {
        if (this.retryCount === 0) {
          this._assertStatus("QUEUED");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        return this.Events.trigger("scheduled", { args: this.args, options: this.options });
      }
      async doExecute(chained, clearGlobalState, run, free2) {
        var error, eventInfo, passed;
        if (this.retryCount === 0) {
          this._assertStatus("RUNNING");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
        this.Events.trigger("executing", eventInfo);
        try {
          passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
          if (clearGlobalState()) {
            this.doDone(eventInfo);
            await free2(this.options, eventInfo);
            this._assertStatus("DONE");
            return this._resolve(passed);
          }
        } catch (error1) {
          error = error1;
          return this._onFailure(error, eventInfo, clearGlobalState, run, free2);
        }
      }
      doExpire(clearGlobalState, run, free2) {
        var error, eventInfo;
        if (this._states.jobStatus(this.options.id === "RUNNING")) {
          this._states.next(this.options.id);
        }
        this._assertStatus("EXECUTING");
        eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount };
        error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
        return this._onFailure(error, eventInfo, clearGlobalState, run, free2);
      }
      async _onFailure(error, eventInfo, clearGlobalState, run, free2) {
        var retry2, retryAfter;
        if (clearGlobalState()) {
          retry2 = await this.Events.trigger("failed", error, eventInfo);
          if (retry2 != null) {
            retryAfter = ~~retry2;
            this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
            this.retryCount++;
            return run(retryAfter);
          } else {
            this.doDone(eventInfo);
            await free2(this.options, eventInfo);
            this._assertStatus("DONE");
            return this._reject(error);
          }
        }
      }
      doDone(eventInfo) {
        this._assertStatus("EXECUTING");
        this._states.next(this.options.id);
        return this.Events.trigger("done", eventInfo);
      }
    };
    var Job_1 = Job;
    var BottleneckError$2, LocalDatastore, parser$2;
    parser$2 = parser;
    BottleneckError$2 = BottleneckError_1;
    LocalDatastore = class LocalDatastore {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.clientId = this.instance._randomIndex();
        parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
        this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
        this._running = 0;
        this._done = 0;
        this._unblockTime = 0;
        this.ready = this.Promise.resolve();
        this.clients = {};
        this._startHeartbeat();
      }
      _startHeartbeat() {
        var base;
        if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
          return typeof (base = this.heartbeat = setInterval(() => {
            var amount, incr, maximum, now, reservoir;
            now = Date.now();
            if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
              this._lastReservoirRefresh = now;
              this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
              this.instance._drainAll(this.computeCapacity());
            }
            if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
              ({
                reservoirIncreaseAmount: amount,
                reservoirIncreaseMaximum: maximum,
                reservoir
              } = this.storeOptions);
              this._lastReservoirIncrease = now;
              incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
              if (incr > 0) {
                this.storeOptions.reservoir += incr;
                return this.instance._drainAll(this.computeCapacity());
              }
            }
          }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
        } else {
          return clearInterval(this.heartbeat);
        }
      }
      async __publish__(message) {
        await this.yieldLoop();
        return this.instance.Events.trigger("message", message.toString());
      }
      async __disconnect__(flush) {
        await this.yieldLoop();
        clearInterval(this.heartbeat);
        return this.Promise.resolve();
      }
      yieldLoop(t = 0) {
        return new this.Promise(function(resolve2, reject) {
          return setTimeout(resolve2, t);
        });
      }
      computePenalty() {
        var ref;
        return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
      }
      async __updateSettings__(options) {
        await this.yieldLoop();
        parser$2.overwrite(options, options, this.storeOptions);
        this._startHeartbeat();
        this.instance._drainAll(this.computeCapacity());
        return true;
      }
      async __running__() {
        await this.yieldLoop();
        return this._running;
      }
      async __queued__() {
        await this.yieldLoop();
        return this.instance.queued();
      }
      async __done__() {
        await this.yieldLoop();
        return this._done;
      }
      async __groupCheck__(time) {
        await this.yieldLoop();
        return this._nextRequest + this.timeout < time;
      }
      computeCapacity() {
        var maxConcurrent, reservoir;
        ({ maxConcurrent, reservoir } = this.storeOptions);
        if (maxConcurrent != null && reservoir != null) {
          return Math.min(maxConcurrent - this._running, reservoir);
        } else if (maxConcurrent != null) {
          return maxConcurrent - this._running;
        } else if (reservoir != null) {
          return reservoir;
        } else {
          return null;
        }
      }
      conditionsCheck(weight) {
        var capacity;
        capacity = this.computeCapacity();
        return capacity == null || weight <= capacity;
      }
      async __incrementReservoir__(incr) {
        var reservoir;
        await this.yieldLoop();
        reservoir = this.storeOptions.reservoir += incr;
        this.instance._drainAll(this.computeCapacity());
        return reservoir;
      }
      async __currentReservoir__() {
        await this.yieldLoop();
        return this.storeOptions.reservoir;
      }
      isBlocked(now) {
        return this._unblockTime >= now;
      }
      check(weight, now) {
        return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
      }
      async __check__(weight) {
        var now;
        await this.yieldLoop();
        now = Date.now();
        return this.check(weight, now);
      }
      async __register__(index2, weight, expiration) {
        var now, wait2;
        await this.yieldLoop();
        now = Date.now();
        if (this.conditionsCheck(weight)) {
          this._running += weight;
          if (this.storeOptions.reservoir != null) {
            this.storeOptions.reservoir -= weight;
          }
          wait2 = Math.max(this._nextRequest - now, 0);
          this._nextRequest = now + wait2 + this.storeOptions.minTime;
          return {
            success: true,
            wait: wait2,
            reservoir: this.storeOptions.reservoir
          };
        } else {
          return {
            success: false
          };
        }
      }
      strategyIsBlock() {
        return this.storeOptions.strategy === 3;
      }
      async __submit__(queueLength, weight) {
        var blocked, now, reachedHWM;
        await this.yieldLoop();
        if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
          throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
        }
        now = Date.now();
        reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
        blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
        if (blocked) {
          this._unblockTime = now + this.computePenalty();
          this._nextRequest = this._unblockTime + this.storeOptions.minTime;
          this.instance._dropAllQueued();
        }
        return {
          reachedHWM,
          blocked,
          strategy: this.storeOptions.strategy
        };
      }
      async __free__(index2, weight) {
        await this.yieldLoop();
        this._running -= weight;
        this._done += weight;
        this.instance._drainAll(this.computeCapacity());
        return {
          running: this._running
        };
      }
    };
    var LocalDatastore_1 = LocalDatastore;
    var BottleneckError$3, States;
    BottleneckError$3 = BottleneckError_1;
    States = class States {
      constructor(status1) {
        this.status = status1;
        this._jobs = {};
        this.counts = this.status.map(function() {
          return 0;
        });
      }
      next(id) {
        var current2, next2;
        current2 = this._jobs[id];
        next2 = current2 + 1;
        if (current2 != null && next2 < this.status.length) {
          this.counts[current2]--;
          this.counts[next2]++;
          return this._jobs[id]++;
        } else if (current2 != null) {
          this.counts[current2]--;
          return delete this._jobs[id];
        }
      }
      start(id) {
        var initial;
        initial = 0;
        this._jobs[id] = initial;
        return this.counts[initial]++;
      }
      remove(id) {
        var current2;
        current2 = this._jobs[id];
        if (current2 != null) {
          this.counts[current2]--;
          delete this._jobs[id];
        }
        return current2 != null;
      }
      jobStatus(id) {
        var ref;
        return (ref = this.status[this._jobs[id]]) != null ? ref : null;
      }
      statusJobs(status2) {
        var k, pos, ref, results2, v;
        if (status2 != null) {
          pos = this.status.indexOf(status2);
          if (pos < 0) {
            throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
          }
          ref = this._jobs;
          results2 = [];
          for (k in ref) {
            v = ref[k];
            if (v === pos) {
              results2.push(k);
            }
          }
          return results2;
        } else {
          return Object.keys(this._jobs);
        }
      }
      statusCounts() {
        return this.counts.reduce((acc, v, i) => {
          acc[this.status[i]] = v;
          return acc;
        }, {});
      }
    };
    var States_1 = States;
    var DLList$2, Sync;
    DLList$2 = DLList_1;
    Sync = class Sync {
      constructor(name, Promise2) {
        this.schedule = this.schedule.bind(this);
        this.name = name;
        this.Promise = Promise2;
        this._running = 0;
        this._queue = new DLList$2();
      }
      isEmpty() {
        return this._queue.length === 0;
      }
      async _tryToRun() {
        var args, cb, error, reject, resolve2, returned, task;
        if (this._running < 1 && this._queue.length > 0) {
          this._running++;
          ({ task, args, resolve: resolve2, reject } = this._queue.shift());
          cb = await async function() {
            try {
              returned = await task(...args);
              return function() {
                return resolve2(returned);
              };
            } catch (error1) {
              error = error1;
              return function() {
                return reject(error);
              };
            }
          }();
          this._running--;
          this._tryToRun();
          return cb();
        }
      }
      schedule(task, ...args) {
        var promise, reject, resolve2;
        resolve2 = reject = null;
        promise = new this.Promise(function(_resolve, _reject) {
          resolve2 = _resolve;
          return reject = _reject;
        });
        this._queue.push({ task, args, resolve: resolve2, reject });
        this._tryToRun();
        return promise;
      }
    };
    var Sync_1 = Sync;
    var version2 = "2.19.5";
    var version$1 = {
      version: version2
    };
    var version$2 = /* @__PURE__ */ Object.freeze({
      version: version2,
      default: version$1
    });
    var require$$22 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$32 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$42 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
    parser$3 = parser;
    Events$2 = Events_1;
    RedisConnection$1 = require$$22;
    IORedisConnection$1 = require$$32;
    Scripts$1 = require$$42;
    Group = function() {
      class Group2 {
        constructor(limiterOptions = {}) {
          this.deleteKey = this.deleteKey.bind(this);
          this.limiterOptions = limiterOptions;
          parser$3.load(this.limiterOptions, this.defaults, this);
          this.Events = new Events$2(this);
          this.instances = {};
          this.Bottleneck = Bottleneck_1;
          this._startAutoCleanup();
          this.sharedConnection = this.connection != null;
          if (this.connection == null) {
            if (this.limiterOptions.datastore === "redis") {
              this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
            } else if (this.limiterOptions.datastore === "ioredis") {
              this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
            }
          }
        }
        key(key = "") {
          var ref;
          return (ref = this.instances[key]) != null ? ref : (() => {
            var limiter;
            limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
              id: `${this.id}-${key}`,
              timeout: this.timeout,
              connection: this.connection
            }));
            this.Events.trigger("created", limiter, key);
            return limiter;
          })();
        }
        async deleteKey(key = "") {
          var deleted, instance;
          instance = this.instances[key];
          if (this.connection) {
            deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key}`)]);
          }
          if (instance != null) {
            delete this.instances[key];
            await instance.disconnect();
          }
          return instance != null || deleted > 0;
        }
        limiters() {
          var k, ref, results2, v;
          ref = this.instances;
          results2 = [];
          for (k in ref) {
            v = ref[k];
            results2.push({
              key: k,
              limiter: v
            });
          }
          return results2;
        }
        keys() {
          return Object.keys(this.instances);
        }
        async clusterKeys() {
          var cursor, end, found, i, k, keys, len, next2, start;
          if (this.connection == null) {
            return this.Promise.resolve(this.keys());
          }
          keys = [];
          cursor = null;
          start = `b_${this.id}-`.length;
          end = "_settings".length;
          while (cursor !== 0) {
            [next2, found] = await this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 1e4]);
            cursor = ~~next2;
            for (i = 0, len = found.length; i < len; i++) {
              k = found[i];
              keys.push(k.slice(start, -end));
            }
          }
          return keys;
        }
        _startAutoCleanup() {
          var base;
          clearInterval(this.interval);
          return typeof (base = this.interval = setInterval(async () => {
            var e, k, ref, results2, time, v;
            time = Date.now();
            ref = this.instances;
            results2 = [];
            for (k in ref) {
              v = ref[k];
              try {
                if (await v._store.__groupCheck__(time)) {
                  results2.push(this.deleteKey(k));
                } else {
                  results2.push(void 0);
                }
              } catch (error) {
                e = error;
                results2.push(v.Events.trigger("error", e));
              }
            }
            return results2;
          }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
        }
        updateSettings(options = {}) {
          parser$3.overwrite(options, this.defaults, this);
          parser$3.overwrite(options, options, this.limiterOptions);
          if (options.timeout != null) {
            return this._startAutoCleanup();
          }
        }
        disconnect(flush = true) {
          var ref;
          if (!this.sharedConnection) {
            return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
          }
        }
      }
      Group2.prototype.defaults = {
        timeout: 1e3 * 60 * 5,
        connection: null,
        Promise,
        id: "group-key"
      };
      return Group2;
    }.call(commonjsGlobal$1);
    var Group_1 = Group;
    var Batcher, Events$3, parser$4;
    parser$4 = parser;
    Events$3 = Events_1;
    Batcher = function() {
      class Batcher2 {
        constructor(options = {}) {
          this.options = options;
          parser$4.load(this.options, this.defaults, this);
          this.Events = new Events$3(this);
          this._arr = [];
          this._resetPromise();
          this._lastFlush = Date.now();
        }
        _resetPromise() {
          return this._promise = new this.Promise((res2, rej) => {
            return this._resolve = res2;
          });
        }
        _flush() {
          clearTimeout(this._timeout);
          this._lastFlush = Date.now();
          this._resolve();
          this.Events.trigger("batch", this._arr);
          this._arr = [];
          return this._resetPromise();
        }
        add(data) {
          var ret;
          this._arr.push(data);
          ret = this._promise;
          if (this._arr.length === this.maxSize) {
            this._flush();
          } else if (this.maxTime != null && this._arr.length === 1) {
            this._timeout = setTimeout(() => {
              return this._flush();
            }, this.maxTime);
          }
          return ret;
        }
      }
      Batcher2.prototype.defaults = {
        maxTime: null,
        maxSize: null,
        Promise
      };
      return Batcher2;
    }.call(commonjsGlobal$1);
    var Batcher_1 = Batcher;
    var require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
    var require$$8 = getCjsExportFromNamespace(version$2);
    var Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
    NUM_PRIORITIES$1 = 10;
    DEFAULT_PRIORITY$1 = 5;
    parser$5 = parser;
    Queues$1 = Queues_1;
    Job$1 = Job_1;
    LocalDatastore$1 = LocalDatastore_1;
    RedisDatastore$1 = require$$4$1;
    Events$4 = Events_1;
    States$1 = States_1;
    Sync$1 = Sync_1;
    Bottleneck = function() {
      class Bottleneck2 {
        constructor(options = {}, ...invalid) {
          var storeInstanceOptions, storeOptions;
          this._addToQueue = this._addToQueue.bind(this);
          this._validateOptions(options, invalid);
          parser$5.load(options, this.instanceDefaults, this);
          this._queues = new Queues$1(NUM_PRIORITIES$1);
          this._scheduled = {};
          this._states = new States$1(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
          this._limiter = null;
          this.Events = new Events$4(this);
          this._submitLock = new Sync$1("submit", this.Promise);
          this._registerLock = new Sync$1("register", this.Promise);
          storeOptions = parser$5.load(options, this.storeDefaults, {});
          this._store = function() {
            if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
              storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
              return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
            } else if (this.datastore === "local") {
              storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
              return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
            } else {
              throw new Bottleneck2.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
            }
          }.call(this);
          this._queues.on("leftzero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
          });
          this._queues.on("zero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
          });
        }
        _validateOptions(options, invalid) {
          if (!(options != null && typeof options === "object" && invalid.length === 0)) {
            throw new Bottleneck2.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
          }
        }
        ready() {
          return this._store.ready;
        }
        clients() {
          return this._store.clients;
        }
        channel() {
          return `b_${this.id}`;
        }
        channel_client() {
          return `b_${this.id}_${this._store.clientId}`;
        }
        publish(message) {
          return this._store.__publish__(message);
        }
        disconnect(flush = true) {
          return this._store.__disconnect__(flush);
        }
        chain(_limiter) {
          this._limiter = _limiter;
          return this;
        }
        queued(priority) {
          return this._queues.queued(priority);
        }
        clusterQueued() {
          return this._store.__queued__();
        }
        empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
        running() {
          return this._store.__running__();
        }
        done() {
          return this._store.__done__();
        }
        jobStatus(id) {
          return this._states.jobStatus(id);
        }
        jobs(status2) {
          return this._states.statusJobs(status2);
        }
        counts() {
          return this._states.statusCounts();
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        check(weight = 1) {
          return this._store.__check__(weight);
        }
        _clearGlobalState(index2) {
          if (this._scheduled[index2] != null) {
            clearTimeout(this._scheduled[index2].expiration);
            delete this._scheduled[index2];
            return true;
          } else {
            return false;
          }
        }
        async _free(index2, job, options, eventInfo) {
          var e, running;
          try {
            ({ running } = await this._store.__free__(index2, options.weight));
            this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
            if (running === 0 && this.empty()) {
              return this.Events.trigger("idle");
            }
          } catch (error1) {
            e = error1;
            return this.Events.trigger("error", e);
          }
        }
        _run(index2, job, wait2) {
          var clearGlobalState, free2, run;
          job.doRun();
          clearGlobalState = this._clearGlobalState.bind(this, index2);
          run = this._run.bind(this, index2, job);
          free2 = this._free.bind(this, index2, job);
          return this._scheduled[index2] = {
            timeout: setTimeout(() => {
              return job.doExecute(this._limiter, clearGlobalState, run, free2);
            }, wait2),
            expiration: job.options.expiration != null ? setTimeout(function() {
              return job.doExpire(clearGlobalState, run, free2);
            }, wait2 + job.options.expiration) : void 0,
            job
          };
        }
        _drainOne(capacity) {
          return this._registerLock.schedule(() => {
            var args, index2, next2, options, queue;
            if (this.queued() === 0) {
              return this.Promise.resolve(null);
            }
            queue = this._queues.getFirst();
            ({ options, args } = next2 = queue.first());
            if (capacity != null && options.weight > capacity) {
              return this.Promise.resolve(null);
            }
            this.Events.trigger("debug", `Draining ${options.id}`, { args, options });
            index2 = this._randomIndex();
            return this._store.__register__(index2, options.weight, options.expiration).then(({ success, wait: wait2, reservoir }) => {
              var empty;
              this.Events.trigger("debug", `Drained ${options.id}`, { success, args, options });
              if (success) {
                queue.shift();
                empty = this.empty();
                if (empty) {
                  this.Events.trigger("empty");
                }
                if (reservoir === 0) {
                  this.Events.trigger("depleted", empty);
                }
                this._run(index2, next2, wait2);
                return this.Promise.resolve(options.weight);
              } else {
                return this.Promise.resolve(null);
              }
            });
          });
        }
        _drainAll(capacity, total = 0) {
          return this._drainOne(capacity).then((drained) => {
            var newCapacity;
            if (drained != null) {
              newCapacity = capacity != null ? capacity - drained : capacity;
              return this._drainAll(newCapacity, total + drained);
            } else {
              return this.Promise.resolve(total);
            }
          }).catch((e) => {
            return this.Events.trigger("error", e);
          });
        }
        _dropAllQueued(message) {
          return this._queues.shiftAll(function(job) {
            return job.doDrop({ message });
          });
        }
        stop(options = {}) {
          var done, waitForExecuting;
          options = parser$5.load(options, this.stopDefaults);
          waitForExecuting = (at) => {
            var finished;
            finished = () => {
              var counts;
              counts = this._states.counts;
              return counts[0] + counts[1] + counts[2] + counts[3] === at;
            };
            return new this.Promise((resolve2, reject) => {
              if (finished()) {
                return resolve2();
              } else {
                return this.on("done", () => {
                  if (finished()) {
                    this.removeAllListeners("done");
                    return resolve2();
                  }
                });
              }
            });
          };
          done = options.dropWaitingJobs ? (this._run = function(index2, next2) {
            return next2.doDrop({
              message: options.dropErrorMessage
            });
          }, this._drainOne = () => {
            return this.Promise.resolve(null);
          }, this._registerLock.schedule(() => {
            return this._submitLock.schedule(() => {
              var k, ref, v;
              ref = this._scheduled;
              for (k in ref) {
                v = ref[k];
                if (this.jobStatus(v.job.options.id) === "RUNNING") {
                  clearTimeout(v.timeout);
                  clearTimeout(v.expiration);
                  v.job.doDrop({
                    message: options.dropErrorMessage
                  });
                }
              }
              this._dropAllQueued(options.dropErrorMessage);
              return waitForExecuting(0);
            });
          })) : this.schedule({
            priority: NUM_PRIORITIES$1 - 1,
            weight: 0
          }, () => {
            return waitForExecuting(1);
          });
          this._receive = function(job) {
            return job._reject(new Bottleneck2.prototype.BottleneckError(options.enqueueErrorMessage));
          };
          this.stop = () => {
            return this.Promise.reject(new Bottleneck2.prototype.BottleneckError("stop() has already been called"));
          };
          return done;
        }
        async _addToQueue(job) {
          var args, blocked, error, options, reachedHWM, shifted, strategy;
          ({ args, options } = job);
          try {
            ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
          } catch (error1) {
            error = error1;
            this.Events.trigger("debug", `Could not queue ${options.id}`, { args, options, error });
            job.doDrop({ error });
            return false;
          }
          if (blocked) {
            job.doDrop();
            return true;
          } else if (reachedHWM) {
            shifted = strategy === Bottleneck2.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck2.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck2.prototype.strategy.OVERFLOW ? job : void 0;
            if (shifted != null) {
              shifted.doDrop();
            }
            if (shifted == null || strategy === Bottleneck2.prototype.strategy.OVERFLOW) {
              if (shifted == null) {
                job.doDrop();
              }
              return reachedHWM;
            }
          }
          job.doQueue(reachedHWM, blocked);
          this._queues.push(job);
          await this._drainAll();
          return reachedHWM;
        }
        _receive(job) {
          if (this._states.jobStatus(job.options.id) != null) {
            job._reject(new Bottleneck2.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
            return false;
          } else {
            job.doReceive();
            return this._submitLock.schedule(this._addToQueue, job);
          }
        }
        submit(...args) {
          var cb, fn, job, options, ref, ref1, task;
          if (typeof args[0] === "function") {
            ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
            options = parser$5.load({}, this.jobDefaults);
          } else {
            ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
            options = parser$5.load(options, this.jobDefaults);
          }
          task = (...args2) => {
            return new this.Promise(function(resolve2, reject) {
              return fn(...args2, function(...args3) {
                return (args3[0] != null ? reject : resolve2)(args3);
              });
            });
          };
          job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          job.promise.then(function(args2) {
            return typeof cb === "function" ? cb(...args2) : void 0;
          }).catch(function(args2) {
            if (Array.isArray(args2)) {
              return typeof cb === "function" ? cb(...args2) : void 0;
            } else {
              return typeof cb === "function" ? cb(args2) : void 0;
            }
          });
          return this._receive(job);
        }
        schedule(...args) {
          var job, options, task;
          if (typeof args[0] === "function") {
            [task, ...args] = args;
            options = {};
          } else {
            [options, task, ...args] = args;
          }
          job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          this._receive(job);
          return job.promise;
        }
        wrap(fn) {
          var schedule, wrapped;
          schedule = this.schedule.bind(this);
          wrapped = function(...args) {
            return schedule(fn.bind(this), ...args);
          };
          wrapped.withOptions = function(options, ...args) {
            return schedule(options, fn, ...args);
          };
          return wrapped;
        }
        async updateSettings(options = {}) {
          await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
          parser$5.overwrite(options, this.instanceDefaults, this);
          return this;
        }
        currentReservoir() {
          return this._store.__currentReservoir__();
        }
        incrementReservoir(incr = 0) {
          return this._store.__incrementReservoir__(incr);
        }
      }
      Bottleneck2.default = Bottleneck2;
      Bottleneck2.Events = Events$4;
      Bottleneck2.version = Bottleneck2.prototype.version = require$$8.version;
      Bottleneck2.strategy = Bottleneck2.prototype.strategy = {
        LEAK: 1,
        OVERFLOW: 2,
        OVERFLOW_PRIORITY: 4,
        BLOCK: 3
      };
      Bottleneck2.BottleneckError = Bottleneck2.prototype.BottleneckError = BottleneckError_1;
      Bottleneck2.Group = Bottleneck2.prototype.Group = Group_1;
      Bottleneck2.RedisConnection = Bottleneck2.prototype.RedisConnection = require$$22;
      Bottleneck2.IORedisConnection = Bottleneck2.prototype.IORedisConnection = require$$32;
      Bottleneck2.Batcher = Bottleneck2.prototype.Batcher = Batcher_1;
      Bottleneck2.prototype.jobDefaults = {
        priority: DEFAULT_PRIORITY$1,
        weight: 1,
        expiration: null,
        id: "<no-id>"
      };
      Bottleneck2.prototype.storeDefaults = {
        maxConcurrent: null,
        minTime: 0,
        highWater: null,
        strategy: Bottleneck2.prototype.strategy.LEAK,
        penalty: null,
        reservoir: null,
        reservoirRefreshInterval: null,
        reservoirRefreshAmount: null,
        reservoirIncreaseInterval: null,
        reservoirIncreaseAmount: null,
        reservoirIncreaseMaximum: null
      };
      Bottleneck2.prototype.localStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 250
      };
      Bottleneck2.prototype.redisStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 5e3,
        clientTimeout: 1e4,
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        clearDatastore: false,
        connection: null
      };
      Bottleneck2.prototype.instanceDefaults = {
        datastore: "local",
        connection: null,
        id: "<no-id>",
        rejectOnDrop: true,
        trackDoneStatus: false,
        Promise
      };
      Bottleneck2.prototype.stopDefaults = {
        enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
        dropWaitingJobs: true,
        dropErrorMessage: "This limiter has been stopped."
      };
      return Bottleneck2;
    }.call(commonjsGlobal$1);
    var Bottleneck_1 = Bottleneck;
    var lib2 = Bottleneck_1;
    return lib2;
  });
})(light);
var lightExports = light.exports;
const BottleneckLight = /* @__PURE__ */ getDefaultExportFromCjs(lightExports);
async function wrapRequest$1(state, octokit, request2, options) {
  const limiter = new BottleneckLight();
  limiter.on("failed", function(error, info) {
    const maxRetries = ~~error.request.request.retries;
    const after = ~~error.request.request.retryAfter;
    options.request.retryCount = info.retryCount + 1;
    if (maxRetries > info.retryCount) {
      return after * state.retryAfterBaseValue;
    }
  });
  return limiter.schedule(
    requestWithGraphqlErrorHandling.bind(null, state, octokit, request2),
    options
  );
}
async function requestWithGraphqlErrorHandling(state, octokit, request2, options) {
  const response = await request2(request2, options);
  if (response.data && response.data.errors && /Something went wrong while executing your query/.test(
    response.data.errors[0].message
  )) {
    const error = new RequestError(response.data.errors[0].message, 500, {
      request: options,
      response
    });
    return errorRequest(state, octokit, error, options);
  }
  return response;
}
const VERSION$7 = "0.0.0-development";
function retry(octokit, octokitOptions) {
  const state = Object.assign(
    {
      enabled: true,
      retryAfterBaseValue: 1e3,
      doNotRetry: [400, 401, 403, 404, 422, 451],
      retries: 3
    },
    octokitOptions.retry
  );
  if (state.enabled) {
    octokit.hook.error("request", errorRequest.bind(null, state, octokit));
    octokit.hook.wrap("request", wrapRequest$1.bind(null, state, octokit));
  }
  return {
    retry: {
      retryRequest: (error, retries, retryAfter) => {
        error.request.request = Object.assign({}, error.request.request, {
          retries,
          retryAfter
        });
        return error;
      }
    }
  };
}
retry.VERSION = VERSION$7;
const VERSION$6 = "8.2.0";
const noop = () => Promise.resolve();
function wrapRequest(state, request2, options) {
  return state.retryLimiter.schedule(doRequest, state, request2, options);
}
async function doRequest(state, request2, options) {
  const isWrite = options.method !== "GET" && options.method !== "HEAD";
  const { pathname } = new URL(options.url, "http://github.test");
  const isSearch = options.method === "GET" && pathname.startsWith("/search/");
  const isGraphQL = pathname.startsWith("/graphql");
  const retryCount = ~~request2.retryCount;
  const jobOptions = retryCount > 0 ? { priority: 0, weight: 0 } : {};
  if (state.clustering) {
    jobOptions.expiration = 1e3 * 60;
  }
  if (isWrite || isGraphQL) {
    await state.write.key(state.id).schedule(jobOptions, noop);
  }
  if (isWrite && state.triggersNotification(pathname)) {
    await state.notifications.key(state.id).schedule(jobOptions, noop);
  }
  if (isSearch) {
    await state.search.key(state.id).schedule(jobOptions, noop);
  }
  const req = state.global.key(state.id).schedule(jobOptions, request2, options);
  if (isGraphQL) {
    const res2 = await req;
    if (res2.data.errors != null && res2.data.errors.some((error) => error.type === "RATE_LIMITED")) {
      const error = Object.assign(new Error("GraphQL Rate Limit Exceeded"), {
        response: res2,
        data: res2.data
      });
      throw error;
    }
  }
  return req;
}
var triggers_notification_paths_default = [
  "/orgs/{org}/invitations",
  "/orgs/{org}/invitations/{invitation_id}",
  "/orgs/{org}/teams/{team_slug}/discussions",
  "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
  "/repos/{owner}/{repo}/collaborators/{username}",
  "/repos/{owner}/{repo}/commits/{commit_sha}/comments",
  "/repos/{owner}/{repo}/issues",
  "/repos/{owner}/{repo}/issues/{issue_number}/comments",
  "/repos/{owner}/{repo}/pulls",
  "/repos/{owner}/{repo}/pulls/{pull_number}/comments",
  "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
  "/repos/{owner}/{repo}/pulls/{pull_number}/merge",
  "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
  "/repos/{owner}/{repo}/pulls/{pull_number}/reviews",
  "/repos/{owner}/{repo}/releases",
  "/teams/{team_id}/discussions",
  "/teams/{team_id}/discussions/{discussion_number}/comments"
];
function routeMatcher(paths) {
  const regexes = paths.map(
    (path) => path.split("/").map((c2) => c2.startsWith("{") ? "(?:.+?)" : c2).join("/")
  );
  const regex2 = `^(?:${regexes.map((r) => `(?:${r})`).join("|")})[^/]*$`;
  return new RegExp(regex2, "i");
}
const regex = routeMatcher(triggers_notification_paths_default);
const triggersNotification = regex.test.bind(regex);
const groups = {};
const createGroups = function(Bottleneck, common2) {
  groups.global = new Bottleneck.Group({
    id: "octokit-global",
    maxConcurrent: 10,
    ...common2
  });
  groups.search = new Bottleneck.Group({
    id: "octokit-search",
    maxConcurrent: 1,
    minTime: 2e3,
    ...common2
  });
  groups.write = new Bottleneck.Group({
    id: "octokit-write",
    maxConcurrent: 1,
    minTime: 1e3,
    ...common2
  });
  groups.notifications = new Bottleneck.Group({
    id: "octokit-notifications",
    maxConcurrent: 1,
    minTime: 3e3,
    ...common2
  });
};
function throttling(octokit, octokitOptions) {
  const {
    enabled = true,
    Bottleneck = BottleneckLight,
    id = "no-id",
    timeout = 1e3 * 60 * 2,
    // Redis TTL: 2 minutes
    connection
  } = octokitOptions.throttle || {};
  if (!enabled) {
    return {};
  }
  const common2 = { connection, timeout };
  if (groups.global == null) {
    createGroups(Bottleneck, common2);
  }
  const state = Object.assign(
    {
      clustering: connection != null,
      triggersNotification,
      fallbackSecondaryRateRetryAfter: 60,
      retryAfterBaseValue: 1e3,
      retryLimiter: new Bottleneck(),
      id,
      ...groups
    },
    octokitOptions.throttle
  );
  if (typeof state.onSecondaryRateLimit !== "function" || typeof state.onRateLimit !== "function") {
    throw new Error(`octokit/plugin-throttling error:
        You must pass the onSecondaryRateLimit and onRateLimit error handlers.
        See https://octokit.github.io/rest.js/#throttling

        const octokit = new Octokit({
          throttle: {
            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);
  }
  const events = {};
  const emitter = new Bottleneck.Events(events);
  events.on("secondary-limit", state.onSecondaryRateLimit);
  events.on("rate-limit", state.onRateLimit);
  events.on(
    "error",
    (e) => octokit.log.warn("Error in throttling-plugin limit handler", e)
  );
  state.retryLimiter.on("failed", async function(error, info) {
    const [state2, request2, options] = info.args;
    const { pathname } = new URL(options.url, "http://github.test");
    const shouldRetryGraphQL = pathname.startsWith("/graphql") && error.status !== 401;
    if (!(shouldRetryGraphQL || error.status === 403)) {
      return;
    }
    const retryCount = ~~request2.retryCount;
    request2.retryCount = retryCount;
    options.request.retryCount = retryCount;
    const { wantRetry, retryAfter = 0 } = await async function() {
      var _a2;
      if (/\bsecondary rate\b/i.test(error.message)) {
        const retryAfter2 = Number(error.response.headers["retry-after"]) || state2.fallbackSecondaryRateRetryAfter;
        const wantRetry2 = await emitter.trigger(
          "secondary-limit",
          retryAfter2,
          options,
          octokit,
          retryCount
        );
        return { wantRetry: wantRetry2, retryAfter: retryAfter2 };
      }
      if (error.response.headers != null && error.response.headers["x-ratelimit-remaining"] === "0" || (((_a2 = error.response.data) == null ? void 0 : _a2.errors) ?? []).some(
        (error2) => error2.type === "RATE_LIMITED"
      )) {
        const rateLimitReset = new Date(
          ~~error.response.headers["x-ratelimit-reset"] * 1e3
        ).getTime();
        const retryAfter2 = Math.max(
          // Add one second so we retry _after_ the reset time
          // https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#exceeding-the-rate-limit
          Math.ceil((rateLimitReset - Date.now()) / 1e3) + 1,
          0
        );
        const wantRetry2 = await emitter.trigger(
          "rate-limit",
          retryAfter2,
          options,
          octokit,
          retryCount
        );
        return { wantRetry: wantRetry2, retryAfter: retryAfter2 };
      }
      return {};
    }();
    if (wantRetry) {
      request2.retryCount++;
      return retryAfter * state2.retryAfterBaseValue;
    }
  });
  octokit.hook.wrap("request", wrapRequest.bind(null, state));
  return {};
}
throttling.VERSION = VERSION$6;
throttling.triggersNotification = triggersNotification;
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(distWeb$2);
var btoaNode = function btoa(str2) {
  return new Buffer(str2).toString("base64");
};
const btoa2 = /* @__PURE__ */ getDefaultExportFromCjs(btoaNode);
const VERSION$5 = "4.1.0";
const VERSION$4 = "4.1.0";
function oauthAuthorizationUrl(options) {
  const clientType = options.clientType || "oauth-app";
  const baseUrl = options.baseUrl || "https://github.com";
  const result = {
    clientType,
    allowSignup: options.allowSignup === false ? false : true,
    clientId: options.clientId,
    login: options.login || null,
    redirectUrl: options.redirectUrl || null,
    state: options.state || Math.random().toString(36).substr(2),
    url: ""
  };
  if (clientType === "oauth-app") {
    const scopes = "scopes" in options ? options.scopes : [];
    result.scopes = typeof scopes === "string" ? scopes.split(/[,\s]+/).filter(Boolean) : scopes;
  }
  result.url = urlBuilderAuthorize(`${baseUrl}/login/oauth/authorize`, result);
  return result;
}
function urlBuilderAuthorize(base, options) {
  const map2 = {
    allowSignup: "allow_signup",
    clientId: "client_id",
    login: "login",
    redirectUrl: "redirect_uri",
    scopes: "scope",
    state: "state"
  };
  let url = base;
  Object.keys(map2).filter((k) => options[k] !== null).filter((k) => {
    if (k !== "scopes")
      return true;
    if (options.clientType === "github-app")
      return false;
    return !Array.isArray(options[k]) || options[k].length > 0;
  }).map((key) => [map2[key], `${options[key]}`]).forEach(([key, value2], index2) => {
    url += index2 === 0 ? `?` : "&";
    url += `${key}=${encodeURIComponent(value2)}`;
  });
  return url;
}
function requestToOAuthBaseUrl(request2) {
  const endpointDefaults = request2.endpoint.DEFAULTS;
  return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request2, route, parameters) {
  const withOAuthParameters = {
    baseUrl: requestToOAuthBaseUrl(request2),
    headers: {
      accept: "application/json"
    },
    ...parameters
  };
  const response = await request2(route, withOAuthParameters);
  if ("error" in response.data) {
    const error = new RequestError(
      `${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`,
      400,
      {
        request: request2.endpoint.merge(
          route,
          withOAuthParameters
        ),
        headers: response.headers
      }
    );
    error.response = response;
    throw error;
  }
  return response;
}
function getWebFlowAuthorizationUrl({
  request: request$1 = request,
  ...options
}) {
  const baseUrl = requestToOAuthBaseUrl(request$1);
  return oauthAuthorizationUrl({
    ...options,
    baseUrl
  });
}
async function exchangeWebFlowCode(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await oauthRequest(
    request$1,
    "POST /login/oauth/access_token",
    {
      client_id: options.clientId,
      client_secret: options.clientSecret,
      code: options.code,
      redirect_uri: options.redirectUrl
    }
  );
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp$2(
        apiTimeInMs,
        response.data.expires_in
      ), authentication.refreshTokenExpiresAt = toTimestamp$2(
        apiTimeInMs,
        response.data.refresh_token_expires_in
      );
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp$2(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
async function createDeviceCode(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const parameters = {
    client_id: options.clientId
  };
  if ("scopes" in options && Array.isArray(options.scopes)) {
    parameters.scope = options.scopes.join(" ");
  }
  return oauthRequest(request$1, "POST /login/device/code", parameters);
}
async function exchangeDeviceCode(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await oauthRequest(
    request$1,
    "POST /login/oauth/access_token",
    {
      client_id: options.clientId,
      device_code: options.code,
      grant_type: "urn:ietf:params:oauth:grant-type:device_code"
    }
  );
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if ("clientSecret" in options) {
    authentication.clientSecret = options.clientSecret;
  }
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp$1(
        apiTimeInMs,
        response.data.expires_in
      ), authentication.refreshTokenExpiresAt = toTimestamp$1(
        apiTimeInMs,
        response.data.refresh_token_expires_in
      );
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp$1(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
async function checkToken(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await request$1("POST /applications/{client_id}/token", {
    headers: {
      authorization: `basic ${btoa2(
        `${options.clientId}:${options.clientSecret}`
      )}`
    },
    client_id: options.clientId,
    access_token: options.token
  });
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: options.token,
    scopes: response.data.scopes
  };
  if (response.data.expires_at)
    authentication.expiresAt = response.data.expires_at;
  if (options.clientType === "github-app") {
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
async function refreshToken(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await oauthRequest(
    request$1,
    "POST /login/oauth/access_token",
    {
      client_id: options.clientId,
      client_secret: options.clientSecret,
      grant_type: "refresh_token",
      refresh_token: options.refreshToken
    }
  );
  const apiTimeInMs = new Date(response.headers.date).getTime();
  const authentication = {
    clientType: "github-app",
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.access_token,
    refreshToken: response.data.refresh_token,
    expiresAt: toTimestamp(apiTimeInMs, response.data.expires_in),
    refreshTokenExpiresAt: toTimestamp(
      apiTimeInMs,
      response.data.refresh_token_expires_in
    )
  };
  return { ...response, authentication };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
async function scopeToken(options) {
  const {
    request: optionsRequest,
    clientType,
    clientId,
    clientSecret,
    token,
    ...requestOptions
  } = options;
  const request$1 = optionsRequest || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await request$1(
    "POST /applications/{client_id}/token/scoped",
    {
      headers: {
        authorization: `basic ${btoa2(`${clientId}:${clientSecret}`)}`
      },
      client_id: clientId,
      access_token: token,
      ...requestOptions
    }
  );
  const authentication = Object.assign(
    {
      clientType,
      clientId,
      clientSecret,
      token: response.data.token
    },
    response.data.expires_at ? { expiresAt: response.data.expires_at } : {}
  );
  return { ...response, authentication };
}
async function resetToken(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const auth2 = btoa2(`${options.clientId}:${options.clientSecret}`);
  const response = await request$1(
    "PATCH /applications/{client_id}/token",
    {
      headers: {
        authorization: `basic ${auth2}`
      },
      client_id: options.clientId,
      access_token: options.token
    }
  );
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.token,
    scopes: response.data.scopes
  };
  if (response.data.expires_at)
    authentication.expiresAt = response.data.expires_at;
  if (options.clientType === "github-app") {
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
async function deleteToken(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const auth2 = btoa2(`${options.clientId}:${options.clientSecret}`);
  return request$1(
    "DELETE /applications/{client_id}/token",
    {
      headers: {
        authorization: `basic ${auth2}`
      },
      client_id: options.clientId,
      access_token: options.token
    }
  );
}
async function deleteAuthorization(options) {
  const request$1 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const auth2 = btoa2(`${options.clientId}:${options.clientSecret}`);
  return request$1(
    "DELETE /applications/{client_id}/grant",
    {
      headers: {
        authorization: `basic ${auth2}`
      },
      client_id: options.clientId,
      access_token: options.token
    }
  );
}
const distSrc$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: VERSION$4,
  checkToken,
  createDeviceCode,
  deleteAuthorization,
  deleteToken,
  exchangeDeviceCode,
  exchangeWebFlowCode,
  getWebFlowAuthorizationUrl,
  refreshToken,
  resetToken,
  scopeToken
}, Symbol.toStringTag, { value: "Module" }));
async function getOAuthAccessToken(state, options) {
  const cachedAuthentication = getCachedAuthentication(state, options.auth);
  if (cachedAuthentication)
    return cachedAuthentication;
  const { data: verification } = await createDeviceCode({
    clientType: state.clientType,
    clientId: state.clientId,
    request: options.request || state.request,
    // @ts-expect-error the extra code to make TS happy is not worth it
    scopes: options.auth.scopes || state.scopes
  });
  await state.onVerification(verification);
  const authentication = await waitForAccessToken(
    options.request || state.request,
    state.clientId,
    state.clientType,
    verification
  );
  state.authentication = authentication;
  return authentication;
}
function getCachedAuthentication(state, auth2) {
  if (auth2.refresh === true)
    return false;
  if (!state.authentication)
    return false;
  if (state.clientType === "github-app") {
    return state.authentication;
  }
  const authentication = state.authentication;
  const newScope = ("scopes" in auth2 && auth2.scopes || state.scopes).join(
    " "
  );
  const currentScope = authentication.scopes.join(" ");
  return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
  await new Promise((resolve2) => setTimeout(resolve2, seconds * 1e3));
}
async function waitForAccessToken(request2, clientId, clientType, verification) {
  try {
    const options = {
      clientId,
      request: request2,
      code: verification.device_code
    };
    const { authentication } = clientType === "oauth-app" ? await exchangeDeviceCode({
      ...options,
      clientType: "oauth-app"
    }) : await exchangeDeviceCode({
      ...options,
      clientType: "github-app"
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  } catch (error) {
    if (!error.response)
      throw error;
    const errorType = error.response.data.error;
    if (errorType === "authorization_pending") {
      await wait(verification.interval);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    if (errorType === "slow_down") {
      await wait(verification.interval + 5);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    throw error;
  }
}
async function auth$3(state, authOptions) {
  return getOAuthAccessToken(state, {
    auth: authOptions
  });
}
async function hook$3(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  const { token } = await getOAuthAccessToken(state, {
    request: request2,
    auth: { type: "oauth" }
  });
  endpoint2.headers.authorization = `token ${token}`;
  return request2(endpoint2);
}
const VERSION$3 = "6.1.0";
function createOAuthDeviceAuth(options) {
  const requestWithDefaults = options.request || request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-device.js/${VERSION$3} ${getUserAgent()}`
    }
  });
  const { request: request$1 = requestWithDefaults, ...otherOptions } = options;
  const state = options.clientType === "github-app" ? {
    ...otherOptions,
    clientType: "github-app",
    request: request$1
  } : {
    ...otherOptions,
    clientType: "oauth-app",
    request: request$1,
    scopes: options.scopes || []
  };
  if (!options.clientId) {
    throw new Error(
      '[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  if (!options.onVerification) {
    throw new Error(
      '[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  return Object.assign(auth$3.bind(null, state), {
    hook: hook$3.bind(null, state)
  });
}
async function getAuthentication(state) {
  if ("code" in state.strategyOptions) {
    const { authentication } = await exchangeWebFlowCode({
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions,
      request: state.request
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  }
  if ("onVerification" in state.strategyOptions) {
    const deviceAuth = createOAuthDeviceAuth({
      clientType: state.clientType,
      clientId: state.clientId,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions,
      request: state.request
    });
    const authentication = await deviceAuth({
      type: "oauth"
    });
    return {
      clientSecret: state.clientSecret,
      ...authentication
    };
  }
  if ("token" in state.strategyOptions) {
    return {
      type: "token",
      tokenType: "oauth",
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      onTokenCreated: state.onTokenCreated,
      ...state.strategyOptions
    };
  }
  throw new Error("[@octokit/auth-oauth-user] Invalid strategy options");
}
async function auth$2(state, options = {}) {
  var _a2, _b2;
  if (!state.authentication) {
    state.authentication = state.clientType === "oauth-app" ? await getAuthentication(state) : await getAuthentication(state);
  }
  if (state.authentication.invalid) {
    throw new Error("[@octokit/auth-oauth-user] Token is invalid");
  }
  const currentAuthentication = state.authentication;
  if ("expiresAt" in currentAuthentication) {
    if (options.type === "refresh" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */ new Date()) {
      const { authentication } = await refreshToken({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        refreshToken: currentAuthentication.refreshToken,
        request: state.request
      });
      state.authentication = {
        tokenType: "oauth",
        type: "token",
        ...authentication
      };
    }
  }
  if (options.type === "refresh") {
    if (state.clientType === "oauth-app") {
      throw new Error(
        "[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens"
      );
    }
    if (!currentAuthentication.hasOwnProperty("expiresAt")) {
      throw new Error("[@octokit/auth-oauth-user] Refresh token missing");
    }
    await ((_a2 = state.onTokenCreated) == null ? void 0 : _a2.call(state, state.authentication, {
      type: options.type
    }));
  }
  if (options.type === "check" || options.type === "reset") {
    const method = options.type === "check" ? checkToken : resetToken;
    try {
      const { authentication } = await method({
        // @ts-expect-error making TS happy would require unnecessary code so no
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: state.authentication.token,
        request: state.request
      });
      state.authentication = {
        tokenType: "oauth",
        type: "token",
        // @ts-expect-error TBD
        ...authentication
      };
      if (options.type === "reset") {
        await ((_b2 = state.onTokenCreated) == null ? void 0 : _b2.call(state, state.authentication, {
          type: options.type
        }));
      }
      return state.authentication;
    } catch (error) {
      if (error.status === 404) {
        error.message = "[@octokit/auth-oauth-user] Token is invalid";
        state.authentication.invalid = true;
      }
      throw error;
    }
  }
  if (options.type === "delete" || options.type === "deleteAuthorization") {
    const method = options.type === "delete" ? deleteToken : deleteAuthorization;
    try {
      await method({
        // @ts-expect-error making TS happy would require unnecessary code so no
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: state.authentication.token,
        request: state.request
      });
    } catch (error) {
      if (error.status !== 404)
        throw error;
    }
    state.authentication.invalid = true;
    return state.authentication;
  }
  return state.authentication;
}
const ROUTES_REQUIRING_BASIC_AUTH = /\/applications\/[^/]+\/(token|grant)s?/;
function requiresBasicAuth(url) {
  return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);
}
async function hook$2(state, request2, route, parameters = {}) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  if (requiresBasicAuth(endpoint2.url)) {
    const credentials = btoa2(`${state.clientId}:${state.clientSecret}`);
    endpoint2.headers.authorization = `basic ${credentials}`;
    return request2(endpoint2);
  }
  const { token } = state.clientType === "oauth-app" ? await auth$2({ ...state, request: request2 }) : await auth$2({ ...state, request: request2 });
  endpoint2.headers.authorization = "token " + token;
  return request2(endpoint2);
}
function createOAuthUserAuth({
  clientId,
  clientSecret,
  clientType = "oauth-app",
  request: request$1 = request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-app.js/${VERSION$5} ${getUserAgent()}`
    }
  }),
  onTokenCreated,
  ...strategyOptions
}) {
  const state = Object.assign({
    clientType,
    clientId,
    clientSecret,
    onTokenCreated,
    strategyOptions,
    request: request$1
  });
  return Object.assign(auth$2.bind(null, state), {
    // @ts-expect-error not worth the extra code needed to appease TS
    hook: hook$2.bind(null, state)
  });
}
createOAuthUserAuth.VERSION = VERSION$5;
const distSrc$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createOAuthUserAuth,
  requiresBasicAuth
}, Symbol.toStringTag, { value: "Module" }));
async function auth$1(state, authOptions) {
  if (authOptions.type === "oauth-app") {
    return {
      type: "oauth-app",
      clientId: state.clientId,
      clientSecret: state.clientSecret,
      clientType: state.clientType,
      headers: {
        authorization: `basic ${btoa2(
          `${state.clientId}:${state.clientSecret}`
        )}`
      }
    };
  }
  if ("factory" in authOptions) {
    const { type: type2, ...options } = {
      ...authOptions,
      ...state
    };
    return authOptions.factory(options);
  }
  const common2 = {
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.request,
    ...authOptions
  };
  const userAuth = state.clientType === "oauth-app" ? await createOAuthUserAuth({
    ...common2,
    clientType: state.clientType
  }) : await createOAuthUserAuth({
    ...common2,
    clientType: state.clientType
  });
  return userAuth();
}
async function hook$1(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  if (state.clientType === "github-app" && !requiresBasicAuth(endpoint2.url)) {
    throw new Error(
      `[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint2.method} ${endpoint2.url}" is not supported.`
    );
  }
  const credentials = btoa2(`${state.clientId}:${state.clientSecret}`);
  endpoint2.headers.authorization = `basic ${credentials}`;
  try {
    return await request2(endpoint2);
  } catch (error) {
    if (error.status !== 401)
      throw error;
    error.message = `[@octokit/auth-oauth-app] "${endpoint2.method} ${endpoint2.url}" does not support clientId/clientSecret basic authentication.`;
    throw error;
  }
}
const VERSION$2 = "7.1.0";
function createOAuthAppAuth(options) {
  const state = Object.assign(
    {
      request: request.defaults({
        headers: {
          "user-agent": `octokit-auth-oauth-app.js/${VERSION$2} ${getUserAgent()}`
        }
      }),
      clientType: "oauth-app"
    },
    options
  );
  return Object.assign(auth$1.bind(null, state), {
    hook: hook$1.bind(null, state)
  });
}
const distSrc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createOAuthAppAuth,
  createOAuthUserAuth
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(distSrc);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(distSrc$1);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(distWeb$1);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(distSrc$2);
async function auth(reason) {
  return {
    type: "unauthenticated",
    reason
  };
}
function isRateLimitError(error) {
  if (error.status !== 403) {
    return false;
  }
  if (!error.response) {
    return false;
  }
  return error.response.headers["x-ratelimit-remaining"] === "0";
}
var REGEX_ABUSE_LIMIT_MESSAGE = /\babuse\b/i;
function isAbuseLimitError(error) {
  if (error.status !== 403) {
    return false;
  }
  return REGEX_ABUSE_LIMIT_MESSAGE.test(error.message);
}
async function hook(reason, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  return request2(endpoint2).catch((error) => {
    if (error.status === 404) {
      error.message = `Not found. May be due to lack of authentication. Reason: ${reason}`;
      throw error;
    }
    if (isRateLimitError(error)) {
      error.message = `API rate limit exceeded. This maybe caused by the lack of authentication. Reason: ${reason}`;
      throw error;
    }
    if (isAbuseLimitError(error)) {
      error.message = `You have triggered an abuse detection mechanism. This maybe caused by the lack of authentication. Reason: ${reason}`;
      throw error;
    }
    if (error.status === 401) {
      error.message = `Unauthorized. "${endpoint2.method} ${endpoint2.url}" failed most likely due to lack of authentication. Reason: ${reason}`;
      throw error;
    }
    if (error.status >= 400 && error.status < 500) {
      error.message = error.message.replace(
        /\.?$/,
        `. May be caused by lack of authentication (${reason}).`
      );
    }
    throw error;
  });
}
var createUnauthenticatedAuth = function createUnauthenticatedAuth2(options) {
  if (!options || !options.reason) {
    throw new Error(
      "[@octokit/auth-unauthenticated] No reason passed to createUnauthenticatedAuth"
    );
  }
  return Object.assign(auth.bind(null, options.reason), {
    hook: hook.bind(null, options.reason)
  });
};
const distWeb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createUnauthenticatedAuth
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(distWeb);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dist_src_exports = {};
__export(dist_src_exports, {
  OAuthApp: () => OAuthApp,
  createAWSLambdaAPIGatewayV2Handler: () => createAWSLambdaAPIGatewayV2Handler,
  createNodeMiddleware: () => createNodeMiddleware,
  createWebWorkerHandler: () => createWebWorkerHandler,
  handleRequest: () => handleRequest,
  sendNodeResponse: () => sendResponse,
  unknownRouteResponse: () => unknownRouteResponse
});
var distNode = __toCommonJS(dist_src_exports);
var import_auth_oauth_app = require$$0;
var VERSION$1 = "6.1.0";
function addEventHandler(state, eventName, eventHandler) {
  if (Array.isArray(eventName)) {
    for (const singleEventName of eventName) {
      addEventHandler(state, singleEventName, eventHandler);
    }
    return;
  }
  if (!state.eventHandlers[eventName]) {
    state.eventHandlers[eventName] = [];
  }
  state.eventHandlers[eventName].push(eventHandler);
}
var import_core = require$$1;
var import_universal_user_agent = require$$2;
var OAuthAppOctokit = import_core.Octokit.defaults({
  userAgent: `octokit-oauth-app.js/${VERSION$1} ${(0, import_universal_user_agent.getUserAgent)()}`
});
var import_auth_oauth_user = require$$3;
async function emitEvent(state, context) {
  const { name, action } = context;
  if (state.eventHandlers[`${name}.${action}`]) {
    for (const eventHandler of state.eventHandlers[`${name}.${action}`]) {
      await eventHandler(context);
    }
  }
  if (state.eventHandlers[name]) {
    for (const eventHandler of state.eventHandlers[name]) {
      await eventHandler(context);
    }
  }
}
async function getUserOctokitWithState(state, options) {
  return state.octokit.auth({
    type: "oauth-user",
    ...options,
    async factory(options2) {
      const octokit = new state.Octokit({
        authStrategy: import_auth_oauth_user.createOAuthUserAuth,
        auth: options2
      });
      const authentication = await octokit.auth({
        type: "get"
      });
      await emitEvent(state, {
        name: "token",
        action: "created",
        token: authentication.token,
        scopes: authentication.scopes,
        authentication,
        octokit
      });
      return octokit;
    }
  });
}
var OAuthMethods = __toESM(require$$4);
function getWebFlowAuthorizationUrlWithState(state, options) {
  const optionsWithDefaults = {
    clientId: state.clientId,
    request: state.octokit.request,
    ...options,
    allowSignup: state.allowSignup ?? options.allowSignup,
    redirectUrl: options.redirectUrl ?? state.redirectUrl,
    scopes: options.scopes ?? state.defaultScopes
  };
  return OAuthMethods.getWebFlowAuthorizationUrl({
    clientType: state.clientType,
    ...optionsWithDefaults
  });
}
var OAuthAppAuth = __toESM(require$$0);
async function createTokenWithState(state, options) {
  const authentication = await state.octokit.auth({
    type: "oauth-user",
    ...options
  });
  await emitEvent(state, {
    name: "token",
    action: "created",
    token: authentication.token,
    scopes: authentication.scopes,
    authentication,
    octokit: new state.Octokit({
      authStrategy: OAuthAppAuth.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: authentication.token,
        scopes: authentication.scopes,
        refreshToken: authentication.refreshToken,
        expiresAt: authentication.expiresAt,
        refreshTokenExpiresAt: authentication.refreshTokenExpiresAt
      }
    })
  });
  return { authentication };
}
var OAuthMethods2 = __toESM(require$$4);
async function checkTokenWithState(state, options) {
  const result = await OAuthMethods2.checkToken({
    // @ts-expect-error not worth the extra code to appease TS
    clientType: state.clientType,
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    ...options
  });
  Object.assign(result.authentication, { type: "token", tokenType: "oauth" });
  return result;
}
var OAuthMethods3 = __toESM(require$$4);
var import_auth_oauth_user2 = require$$3;
async function resetTokenWithState(state, options) {
  const optionsWithDefaults = {
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    ...options
  };
  if (state.clientType === "oauth-app") {
    const response2 = await OAuthMethods3.resetToken({
      clientType: "oauth-app",
      ...optionsWithDefaults
    });
    const authentication2 = Object.assign(response2.authentication, {
      type: "token",
      tokenType: "oauth"
    });
    await emitEvent(state, {
      name: "token",
      action: "reset",
      token: response2.authentication.token,
      scopes: response2.authentication.scopes || void 0,
      authentication: authentication2,
      octokit: new state.Octokit({
        authStrategy: import_auth_oauth_user2.createOAuthUserAuth,
        auth: {
          clientType: state.clientType,
          clientId: state.clientId,
          clientSecret: state.clientSecret,
          token: response2.authentication.token,
          scopes: response2.authentication.scopes
        }
      })
    });
    return { ...response2, authentication: authentication2 };
  }
  const response = await OAuthMethods3.resetToken({
    clientType: "github-app",
    ...optionsWithDefaults
  });
  const authentication = Object.assign(response.authentication, {
    type: "token",
    tokenType: "oauth"
  });
  await emitEvent(state, {
    name: "token",
    action: "reset",
    token: response.authentication.token,
    authentication,
    octokit: new state.Octokit({
      authStrategy: import_auth_oauth_user2.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return { ...response, authentication };
}
var OAuthMethods4 = __toESM(require$$4);
var import_auth_oauth_user3 = require$$3;
async function refreshTokenWithState(state, options) {
  if (state.clientType === "oauth-app") {
    throw new Error(
      "[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps"
    );
  }
  const response = await OAuthMethods4.refreshToken({
    clientType: "github-app",
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    refreshToken: options.refreshToken
  });
  const authentication = Object.assign(response.authentication, {
    type: "token",
    tokenType: "oauth"
  });
  await emitEvent(state, {
    name: "token",
    action: "refreshed",
    token: response.authentication.token,
    authentication,
    octokit: new state.Octokit({
      authStrategy: import_auth_oauth_user3.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return { ...response, authentication };
}
var OAuthMethods5 = __toESM(require$$4);
var import_auth_oauth_user4 = require$$3;
async function scopeTokenWithState(state, options) {
  if (state.clientType === "oauth-app") {
    throw new Error(
      "[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps"
    );
  }
  const response = await OAuthMethods5.scopeToken({
    clientType: "github-app",
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    ...options
  });
  const authentication = Object.assign(response.authentication, {
    type: "token",
    tokenType: "oauth"
  });
  await emitEvent(state, {
    name: "token",
    action: "scoped",
    token: response.authentication.token,
    authentication,
    octokit: new state.Octokit({
      authStrategy: import_auth_oauth_user4.createOAuthUserAuth,
      auth: {
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        token: response.authentication.token
      }
    })
  });
  return { ...response, authentication };
}
var OAuthMethods6 = __toESM(require$$4);
var import_auth_unauthenticated = require$$5;
async function deleteTokenWithState(state, options) {
  const optionsWithDefaults = {
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    ...options
  };
  const response = state.clientType === "oauth-app" ? await OAuthMethods6.deleteToken({
    clientType: "oauth-app",
    ...optionsWithDefaults
  }) : (
    // istanbul ignore next
    await OAuthMethods6.deleteToken({
      clientType: "github-app",
      ...optionsWithDefaults
    })
  );
  await emitEvent(state, {
    name: "token",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: import_auth_unauthenticated.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "token.deleted" event. The access for the token has been revoked.`
      }
    })
  });
  return response;
}
var OAuthMethods7 = __toESM(require$$4);
var import_auth_unauthenticated2 = require$$5;
async function deleteAuthorizationWithState(state, options) {
  const optionsWithDefaults = {
    clientId: state.clientId,
    clientSecret: state.clientSecret,
    request: state.octokit.request,
    ...options
  };
  const response = state.clientType === "oauth-app" ? await OAuthMethods7.deleteAuthorization({
    clientType: "oauth-app",
    ...optionsWithDefaults
  }) : (
    // istanbul ignore next
    await OAuthMethods7.deleteAuthorization({
      clientType: "github-app",
      ...optionsWithDefaults
    })
  );
  await emitEvent(state, {
    name: "token",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: import_auth_unauthenticated2.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "token.deleted" event. The access for the token has been revoked.`
      }
    })
  });
  await emitEvent(state, {
    name: "authorization",
    action: "deleted",
    token: options.token,
    octokit: new state.Octokit({
      authStrategy: import_auth_unauthenticated2.createUnauthenticatedAuth,
      auth: {
        reason: `Handling "authorization.deleted" event. The access for the app has been revoked.`
      }
    })
  });
  return response;
}
function unknownRouteResponse(request2) {
  return {
    status: 404,
    headers: { "content-type": "application/json" },
    text: JSON.stringify({
      error: `Unknown route: ${request2.method} ${request2.url}`
    })
  };
}
async function handleRequest(app, { pathPrefix = "/api/github/oauth" }, request2) {
  var _a2, _b2, _c, _d, _e, _f;
  if (request2.method === "OPTIONS") {
    return {
      status: 200,
      headers: {
        "access-control-allow-origin": "*",
        "access-control-allow-methods": "*",
        "access-control-allow-headers": "Content-Type, User-Agent, Authorization"
      }
    };
  }
  let { pathname } = new URL(request2.url, "http://localhost");
  if (!pathname.startsWith(`${pathPrefix}/`)) {
    return void 0;
  }
  pathname = pathname.slice(pathPrefix.length + 1);
  const route = [request2.method, pathname].join(" ");
  const routes = {
    getLogin: `GET login`,
    getCallback: `GET callback`,
    createToken: `POST token`,
    getToken: `GET token`,
    patchToken: `PATCH token`,
    patchRefreshToken: `PATCH refresh-token`,
    scopeToken: `POST token/scoped`,
    deleteToken: `DELETE token`,
    deleteGrant: `DELETE grant`
  };
  if (!Object.values(routes).includes(route)) {
    return unknownRouteResponse(request2);
  }
  let json2;
  try {
    const text = await request2.text();
    json2 = text ? JSON.parse(text) : {};
  } catch (error) {
    return {
      status: 400,
      headers: {
        "content-type": "application/json",
        "access-control-allow-origin": "*"
      },
      text: JSON.stringify({
        error: "[@octokit/oauth-app] request error"
      })
    };
  }
  const { searchParams } = new URL(request2.url, "http://localhost");
  const query = Object.fromEntries(searchParams);
  const headers = request2.headers;
  try {
    if (route === routes.getLogin) {
      const { url } = app.getWebFlowAuthorizationUrl({
        state: query.state,
        scopes: query.scopes ? query.scopes.split(",") : void 0,
        allowSignup: query.allowSignup ? query.allowSignup === "true" : void 0,
        redirectUrl: query.redirectUrl
      });
      return { status: 302, headers: { location: url } };
    }
    if (route === routes.getCallback) {
      if (query.error) {
        throw new Error(
          `[@octokit/oauth-app] ${query.error} ${query.error_description}`
        );
      }
      if (!query.code) {
        throw new Error('[@octokit/oauth-app] "code" parameter is required');
      }
      const {
        authentication: { token: token2 }
      } = await app.createToken({
        code: query.code
      });
      return {
        status: 200,
        headers: {
          "content-type": "text/html"
        },
        text: `<h1>Token created successfully</h1>

<p>Your token is: <strong>${token2}</strong>. Copy it now as it cannot be shown again.</p>`
      };
    }
    if (route === routes.createToken) {
      const { code, redirectUrl } = json2;
      if (!code) {
        throw new Error('[@octokit/oauth-app] "code" parameter is required');
      }
      const result = await app.createToken({
        code,
        redirectUrl
      });
      delete result.authentication.clientSecret;
      return {
        status: 201,
        headers: {
          "content-type": "application/json",
          "access-control-allow-origin": "*"
        },
        text: JSON.stringify(result)
      };
    }
    if (route === routes.getToken) {
      const token2 = (_a2 = headers.authorization) == null ? void 0 : _a2.substr("token ".length);
      if (!token2) {
        throw new Error(
          '[@octokit/oauth-app] "Authorization" header is required'
        );
      }
      const result = await app.checkToken({
        token: token2
      });
      delete result.authentication.clientSecret;
      return {
        status: 200,
        headers: {
          "content-type": "application/json",
          "access-control-allow-origin": "*"
        },
        text: JSON.stringify(result)
      };
    }
    if (route === routes.patchToken) {
      const token2 = (_b2 = headers.authorization) == null ? void 0 : _b2.substr("token ".length);
      if (!token2) {
        throw new Error(
          '[@octokit/oauth-app] "Authorization" header is required'
        );
      }
      const result = await app.resetToken({ token: token2 });
      delete result.authentication.clientSecret;
      return {
        status: 200,
        headers: {
          "content-type": "application/json",
          "access-control-allow-origin": "*"
        },
        text: JSON.stringify(result)
      };
    }
    if (route === routes.patchRefreshToken) {
      const token2 = (_c = headers.authorization) == null ? void 0 : _c.substr("token ".length);
      if (!token2) {
        throw new Error(
          '[@octokit/oauth-app] "Authorization" header is required'
        );
      }
      const { refreshToken: refreshToken2 } = json2;
      if (!refreshToken2) {
        throw new Error(
          "[@octokit/oauth-app] refreshToken must be sent in request body"
        );
      }
      const result = await app.refreshToken({ refreshToken: refreshToken2 });
      delete result.authentication.clientSecret;
      return {
        status: 200,
        headers: {
          "content-type": "application/json",
          "access-control-allow-origin": "*"
        },
        text: JSON.stringify(result)
      };
    }
    if (route === routes.scopeToken) {
      const token2 = (_d = headers.authorization) == null ? void 0 : _d.substr("token ".length);
      if (!token2) {
        throw new Error(
          '[@octokit/oauth-app] "Authorization" header is required'
        );
      }
      const result = await app.scopeToken({
        token: token2,
        ...json2
      });
      delete result.authentication.clientSecret;
      return {
        status: 200,
        headers: {
          "content-type": "application/json",
          "access-control-allow-origin": "*"
        },
        text: JSON.stringify(result)
      };
    }
    if (route === routes.deleteToken) {
      const token2 = (_e = headers.authorization) == null ? void 0 : _e.substr("token ".length);
      if (!token2) {
        throw new Error(
          '[@octokit/oauth-app] "Authorization" header is required'
        );
      }
      await app.deleteToken({
        token: token2
      });
      return {
        status: 204,
        headers: { "access-control-allow-origin": "*" }
      };
    }
    const token = (_f = headers.authorization) == null ? void 0 : _f.substr("token ".length);
    if (!token) {
      throw new Error(
        '[@octokit/oauth-app] "Authorization" header is required'
      );
    }
    await app.deleteAuthorization({
      token
    });
    return {
      status: 204,
      headers: { "access-control-allow-origin": "*" }
    };
  } catch (error) {
    return {
      status: 400,
      headers: {
        "content-type": "application/json",
        "access-control-allow-origin": "*"
      },
      text: JSON.stringify({ error: error.message })
    };
  }
}
function parseRequest(request2) {
  const { method, url, headers } = request2;
  async function text() {
    const text2 = await new Promise((resolve2, reject) => {
      let bodyChunks = [];
      request2.on("error", reject).on("data", (chunk) => bodyChunks.push(chunk)).on("end", () => resolve2(Buffer.concat(bodyChunks).toString()));
    });
    return text2;
  }
  return { method, url, headers, text };
}
function sendResponse(octokitResponse, response) {
  response.writeHead(octokitResponse.status, octokitResponse.headers);
  response.end(octokitResponse.text);
}
function createNodeMiddleware(app, options = {}) {
  return async function(request2, response, next2) {
    const octokitRequest = await parseRequest(request2);
    const octokitResponse = await handleRequest(app, options, octokitRequest);
    if (octokitResponse) {
      sendResponse(octokitResponse, response);
      return true;
    } else {
      next2 == null ? void 0 : next2();
      return false;
    }
  };
}
function parseRequest2(request2) {
  const headers = Object.fromEntries(request2.headers.entries());
  return {
    method: request2.method,
    url: request2.url,
    headers,
    text: () => request2.text()
  };
}
function sendResponse2(octokitResponse) {
  return new Response(octokitResponse.text, {
    status: octokitResponse.status,
    headers: octokitResponse.headers
  });
}
function createWebWorkerHandler(app, options = {}) {
  return async function(request2) {
    const octokitRequest = await parseRequest2(request2);
    const octokitResponse = await handleRequest(app, options, octokitRequest);
    return octokitResponse ? sendResponse2(octokitResponse) : void 0;
  };
}
function parseRequest3(request2) {
  const { method } = request2.requestContext.http;
  let url = request2.rawPath;
  const { stage } = request2.requestContext;
  if (url.startsWith("/" + stage))
    url = url.substring(stage.length + 1);
  if (request2.rawQueryString)
    url += "?" + request2.rawQueryString;
  const headers = request2.headers;
  const text = async () => request2.body || "";
  return { method, url, headers, text };
}
function sendResponse3(octokitResponse) {
  return {
    statusCode: octokitResponse.status,
    headers: octokitResponse.headers,
    body: octokitResponse.text
  };
}
function createAWSLambdaAPIGatewayV2Handler(app, options = {}) {
  return async function(event) {
    const request2 = parseRequest3(event);
    const response = await handleRequest(app, options, request2);
    return response ? sendResponse3(response) : void 0;
  };
}
var OAuthApp = (_b = class {
  static defaults(defaults2) {
    const OAuthAppWithDefaults = class extends this {
      constructor(...args) {
        super({
          ...defaults2,
          ...args[0]
        });
      }
    };
    return OAuthAppWithDefaults;
  }
  constructor(options) {
    const Octokit2 = options.Octokit || OAuthAppOctokit;
    this.type = options.clientType || "oauth-app";
    const octokit = new Octokit2({
      authStrategy: import_auth_oauth_app.createOAuthAppAuth,
      auth: {
        clientType: this.type,
        clientId: options.clientId,
        clientSecret: options.clientSecret
      }
    });
    const state = {
      clientType: this.type,
      clientId: options.clientId,
      clientSecret: options.clientSecret,
      // @ts-expect-error defaultScopes not permitted for GitHub Apps
      defaultScopes: options.defaultScopes || [],
      allowSignup: options.allowSignup,
      baseUrl: options.baseUrl,
      redirectUrl: options.redirectUrl,
      log: options.log,
      Octokit: Octokit2,
      octokit,
      eventHandlers: {}
    };
    this.on = addEventHandler.bind(null, state);
    this.octokit = octokit;
    this.getUserOctokit = getUserOctokitWithState.bind(null, state);
    this.getWebFlowAuthorizationUrl = getWebFlowAuthorizationUrlWithState.bind(
      null,
      state
    );
    this.createToken = createTokenWithState.bind(
      null,
      state
    );
    this.checkToken = checkTokenWithState.bind(
      null,
      state
    );
    this.resetToken = resetTokenWithState.bind(
      null,
      state
    );
    this.refreshToken = refreshTokenWithState.bind(
      null,
      state
    );
    this.scopeToken = scopeTokenWithState.bind(
      null,
      state
    );
    this.deleteToken = deleteTokenWithState.bind(null, state);
    this.deleteAuthorization = deleteAuthorizationWithState.bind(null, state);
  }
}, _b.VERSION = VERSION$1, _b);
var VERSION = "3.1.2";
var Octokit = Octokit$1.plugin(
  restEndpointMethods,
  paginateRest,
  paginateGraphql,
  retry,
  throttling
).defaults({
  userAgent: `octokit.js/${VERSION}`,
  throttle: {
    onRateLimit,
    onSecondaryRateLimit
  }
});
function onRateLimit(retryAfter, options, octokit) {
  octokit.log.warn(
    `Request quota exhausted for request ${options.method} ${options.url}`
  );
  if (options.request.retryCount === 0) {
    octokit.log.info(`Retrying after ${retryAfter} seconds!`);
    return true;
  }
}
function onSecondaryRateLimit(retryAfter, options, octokit) {
  octokit.log.warn(
    `SecondaryRateLimit detected for request ${options.method} ${options.url}`
  );
  if (options.request.retryCount === 0) {
    octokit.log.info(`Retrying after ${retryAfter} seconds!`);
    return true;
  }
}
distNode.OAuthApp.defaults({ Octokit });
function makeGithubClient({ gitHubProxyUrl } = {}) {
  const githubClient = new Octokit({
    request: {
      fetch: (...ghArgs) => {
        ghArgs[0] = gitHubProxyUrl + "/" + ghArgs[0];
        if (!ghArgs[1]) {
          ghArgs[1] = {};
        }
        if (gitHubProxyUrl) {
          ghArgs[1].credentials = "include";
        }
        return fetch(...ghArgs);
      }
    }
  });
  const getRepo = async ({ repoName, owner }) => await githubClient.request("GET /repos/{owner}/{repo}", {
    owner,
    repo: repoName
  }).catch((newError) => {
    return { error: newError };
  });
  const getAvailableRepos = async (installation_id) => await githubClient.request(`GET /user/installations/{installation_id}/repositories`, {
    installation_id
  }).then(({ data }) => data).catch((newError) => {
    return { error: newError };
  });
  const getInstallations = async () => await githubClient.request("GET /user/installations").then(({ data }) => data).catch((newError) => {
    return { error: newError };
  });
  const createFork2 = githubClient.rest.repos.createFork;
  const mergeUpstream2 = async ({ branch: branch2, owner, repoName }) => await githubClient.request("POST /repos/{owner}/{repo}/merge-upstream", {
    branch: branch2,
    owner,
    repo: repoName
  });
  const compare = async ({ owner, repoName, base, head }) => {
    return await githubClient.request("GET /repos/{owner}/{repo}/compare/{base}...{head}", {
      owner,
      repo: repoName,
      base,
      head
    });
  };
  return {
    getInstallations,
    getAvailableRepos,
    getRepo,
    createFork: createFork2,
    mergeUpstream: mergeUpstream2,
    compare
  };
}
async function repoContext(url, args) {
  var _a2;
  const rawFs = args.nodeishFs || (await import("../index-9cf8cd4d.js")).createNodeishMemoryFs();
  const author = args.author;
  let debug = args.debug || false;
  if (!url || !url.startsWith("file://") && !url.startsWith("https://") && !url.startsWith("http://")) {
    throw new Error("repo url is required, use file:// for local repos");
  }
  if (debug && typeof window !== "undefined") {
    window["rawFs"] = rawFs;
  }
  let freshClone = false;
  let dir = "/";
  if (url.startsWith("file:")) {
    dir = url.replace("file://", "");
    const remotes = await index$1.listRemotes({
      fs: rawFs,
      dir
    }).catch(() => []);
    const origin = ((_a2 = remotes.find(({ remote }) => remote === "origin")) == null ? void 0 : _a2.url) || "";
    if (origin.startsWith("git@githubClient.com:")) {
      url = origin.replace("git@githubClient.com:", "https://githubClient.com/");
    } else {
      url = origin;
    }
  } else {
    const maybeGitDir = await rawFs.stat(".git").catch((error) => ({ error }));
    if ("error" in maybeGitDir) {
      freshClone = true;
    }
  }
  const { protocol, lixHost, repoHost, owner, repoName, username, password, namespace } = parseLixUri(url);
  if (debug && (username || password)) {
    console.warn("username and password and providers other than github are not supported yet. Only local commands will work.");
  }
  const isWhitelistedRepo = whitelistedExperimentalRepos.includes(`${owner}/${repoName}`.toLocaleLowerCase());
  const experimentalFeatures = args.experimentalFeatures || (isWhitelistedRepo ? { lazyClone: freshClone, lixCommit: true } : {});
  const useLazyFS = (experimentalFeatures == null ? void 0 : experimentalFeatures.lazyClone) && (rawFs == null ? void 0 : rawFs._createPlaceholder);
  const cache2 = useLazyFS ? {} : void 0;
  let gitProxyUrl;
  let gitHubProxyUrl;
  if (namespace === "git") {
    gitProxyUrl = lixHost ? `${protocol}//${lixHost}/git-proxy` : "";
    gitHubProxyUrl = lixHost ? `${protocol}//${lixHost}/github-proxy` : "";
  }
  debug && console.info({
    gitProxyUrl,
    gitHubProxyUrl,
    protocol,
    lixHost,
    repoHost,
    owner,
    repoName,
    username,
    password
  });
  const githubClient = makeGithubClient({ gitHubProxyUrl });
  const gitUrl = repoName ? `https://${repoHost}/${owner}/${repoName}` : "";
  if (!gitUrl && debug) {
    console.warn("valid repo url / local repo not found, only fs features available outside of repo");
  }
  const expFeatures = Object.entries(experimentalFeatures).filter(([_, value2]) => value2).map(([key]) => key);
  if (expFeatures.length) {
    console.warn("using experimental git features for this repo.", expFeatures);
  }
  return {
    gitUrl,
    gitProxyUrl,
    protocol,
    lixHost,
    repoHost,
    owner,
    repoName,
    username,
    password,
    namespace,
    useLazyFS,
    githubClient,
    debug,
    experimentalFeatures,
    author,
    freshClone,
    dir,
    // maybe handle these different when touching lixFS impl.
    rawFs,
    cache: cache2
  };
}
async function repoState(ctx, args) {
  const { gitUrl, debug, rawFs, experimentalFeatures, gitProxyUrl, freshClone, useLazyFS, dir, cache: cache2 } = ctx;
  const nodeishFs = withProxy({
    nodeishFs: rawFs,
    verbose: debug,
    description: "app",
    intercept: useLazyFS ? delayedAction : void 0
  });
  let preloads = [];
  let nextBatch = [];
  const state = {
    ensureFirstBatch,
    pending: void 0,
    nodeishFs,
    checkedOut: /* @__PURE__ */ new Set(),
    branchName: args.branch,
    currentRef: "HEAD",
    defaultBranch: "refs/remotes/origin/HEAD",
    sparseFilter: args.sparseFilter
  };
  async function ensureFirstBatch(args2) {
    if (!useLazyFS) {
      return;
    }
    preloads = preloads.concat((args2 == null ? void 0 : args2.preload) || []);
    if (state.pending) {
      await state.pending.catch((error) => console.error(error));
    } else {
      if (preloads.length) {
        nextBatch.push("");
        state.pending = doCheckout().finally(() => {
          state.pending = void 0;
        });
      }
    }
  }
  async function doCheckout() {
    if (nextBatch.length < 1) {
      return;
    }
    const thisBatch = [];
    const oidPromises = [];
    for (const entry of nextBatch) {
      if (entry === "") {
        continue;
      }
      if (typeof entry === "string") {
        if (!state.checkedOut.has(entry)) {
          thisBatch.push(entry);
        }
      } else {
        oidPromises.push(entry);
      }
    }
    nextBatch = [];
    if (debug) {
      oidPromises.length && console.warn("fetching oids ", oidPromises);
    }
    if (oidPromises.length > 0) {
      await Promise.all(oidPromises).catch(console.error);
    }
    const allBatchFiles = [.../* @__PURE__ */ new Set([...preloads, ...thisBatch])];
    preloads = [];
    if (debug) {
      console.warn("checking out ", JSON.stringify(allBatchFiles));
    }
    const oids = [];
    const placeholders = allBatchFiles.filter((entry) => {
      var _a2;
      return (_a2 = rawFs._isPlaceholder) == null ? void 0 : _a2.call(rawFs, entry);
    });
    for (const placeholder of placeholders) {
      const stats = await rawFs.stat(placeholder);
      oids.push(stats._oid);
    }
    if (useLazyFS && oids.length > 0) {
      const toFetch = (await Promise.all(oids.map((oid) => blobExistsLocaly({
        fs: rawFs,
        cache: cache2,
        oid,
        gitdir: ".git"
      }).then((exists) => exists ? false : oid)))).filter((a) => a !== false);
      if (toFetch.length) {
        await index$1.fetch({
          cache: cache2,
          fs: rawFs,
          dir: "/",
          http: makeHttpClient({
            debug,
            description: "lazy fetch",
            onReq: optimizeReq.bind(null, {
              noBlobs: false,
              addRefs: [state.branchName || "HEAD"],
              overrideWants: toFetch
            }),
            onRes: optimizeRes
          }),
          depth: 1,
          singleBranch: true,
          tags: false
        }).catch((error) => {
          console.error({ error, toFetch });
        });
      }
    }
    let res2;
    if (allBatchFiles.length > 0) {
      await Promise.all(placeholders.map((placeholder) => rawFs.rm(placeholder).catch(() => {
      })));
      res2 = await _checkout({
        fs: rawFs,
        dir,
        cache: cache2,
        ref: state.branchName,
        filepaths: allBatchFiles
      }).catch((error) => {
        console.error({ error, allBatchFiles });
      });
    }
    for (const entry of allBatchFiles) {
      state.checkedOut.add(entry);
    }
    if (debug) {
      console.warn("checked out ", allBatchFiles);
    }
    if (nextBatch.length) {
      return doCheckout();
    }
    return res2;
  }
  if (freshClone) {
    if (!rawFs._createPlaceholder && !rawFs._isPlaceholder) {
      throw new Error("fs provider does not support placeholders");
    }
    console.info("Using lix for cloning repo");
    await index$1.clone({
      fs: rawFs,
      http: makeHttpClient({
        debug,
        description: "clone",
        onReq: experimentalFeatures.lazyClone ? optimizeReq.bind(null, {
          noBlobs: true,
          addRefs: [state.branchName || "HEAD"]
        }) : void 0,
        onRes: experimentalFeatures.lazyClone ? optimizeRes : void 0
      }),
      dir,
      cache: cache2,
      corsProxy: gitProxyUrl,
      url: gitUrl,
      singleBranch: false,
      noCheckout: experimentalFeatures.lazyClone,
      ref: state.branchName,
      // TODO: use only first and last commit in lazy clone? (we need first commit for repo id)
      depth: 1,
      noTags: true
    }).then(async () => {
      if (!experimentalFeatures.lazyClone) {
        return;
      }
      const { gitignoreFiles } = await checkOutPlaceholders(ctx, {
        branchName: state.branchName,
        checkedOut: state.checkedOut,
        sparseFilter: state.sparseFilter,
        ensureFirstBatch
      }, { materializeGitignores: false });
      preloads = gitignoreFiles;
    });
  } else {
    console.info("Using existing cloned repo");
  }
  function delayedAction({ execute, prop, argumentsList }) {
    var _a2;
    const filename = (_a2 = argumentsList == null ? void 0 : argumentsList[0]) == null ? void 0 : _a2.replace(/^(\.)?(\/)?\//, "");
    const pathParts = (filename == null ? void 0 : filename.split("/")) || [];
    const rootObject = pathParts[0];
    if (experimentalFeatures.lazyClone && typeof rootObject !== "undefined" && rootObject !== ".git" && ["readFile", "readlink", "writeFile", "readdir"].includes(prop) && !state.checkedOut.has(rootObject) && !state.checkedOut.has(filename)) {
      if (debug) {
        console.info("delayedAction", {
          prop,
          argumentsList,
          rootObject,
          checkedOut: state.checkedOut,
          filename,
          pending: state.pending,
          nextBatch
        });
      }
      if (prop !== "readdir") {
        nextBatch.push(filename);
      }
      if (!state.pending && nextBatch.length > 0) {
        state.pending = doCheckout();
      }
    } else if (experimentalFeatures.lazyClone && typeof rootObject !== "undefined" && rootObject === ".git" && // TODO #1459 more solid check for git folder !filePath.startsWith(gitdir))
    pathParts[1] === "objects" && pathParts[2] !== "pack" && pathParts.length === 4 && prop === "readFile") {
      const oid = pathParts[2] + pathParts[3];
      nextBatch.push(blobExistsLocaly({
        fs: rawFs,
        cache: cache2,
        oid,
        gitdir: ".git"
      }).then((existsLocaly) => {
        if (!existsLocaly) {
          console.warn("missing oid!! in git object store interceptor: ", oid);
          return index$1.fetch({
            cache: cache2,
            fs: rawFs,
            dir: "/",
            http: makeHttpClient({
              debug,
              description: "lazy fetch",
              onReq: optimizeReq.bind(null, {
                noBlobs: false,
                addRefs: [state.branchName || "HEAD"],
                // we don't need to override the haves any more since adding the capabilities
                // allow-tip-sha1-in-want allow-reachable-sha1-in-want to the request enable us to request objects explicetly
                overrideWants: [oid]
              }),
              onRes: optimizeRes
            }),
            depth: 1,
            singleBranch: true,
            tags: false
          });
        }
        return void 0;
      }));
      if (!state.pending) {
        state.pending = doCheckout();
      }
    } else {
      return execute();
    }
    if (state.pending) {
      return state.pending.then(execute).finally(() => {
        state.pending = void 0;
        if (debug) {
          console.warn("executed", filename, prop);
        }
      });
    }
    return execute();
  }
  return state;
}
const lixFs = (nodeishFs) => ({
  read(path) {
    return nodeishFs.readFile(path, { encoding: "utf-8" });
  },
  write(path, content) {
    return nodeishFs.writeFile(path, content);
  },
  listDir(path) {
    return nodeishFs.readdir(path);
  }
});
async function openRepository(url, args) {
  const ctx = await repoContext(url, args);
  const state = await repoState(ctx, args);
  return {
    _experimentalFeatures: ctx.experimentalFeatures,
    _rawFs: ctx.rawFs,
    nodeishFs: state.nodeishFs,
    commit: commit.bind(void 0, ctx, state),
    status: status.bind(void 0, ctx, state),
    statusList: statusList.bind(void 0, ctx, state),
    forkStatus: forkStatus.bind(void 0, ctx),
    getMeta: getMeta.bind(void 0, ctx),
    listRemotes: listRemotes.bind(void 0, ctx, state),
    log: log.bind(void 0, ctx),
    getOrigin: getOrigin.bind(void 0, ctx, state),
    getBranches: getBranches.bind(void 0, ctx),
    getCurrentBranch: getCurrentBranch.bind(void 0, ctx, state),
    getFirstCommitHash: getFirstCommitHash.bind(void 0, ctx),
    checkout: checkout.bind(void 0, ctx, state),
    createFork: createFork.bind(void 0, ctx),
    mergeUpstream: mergeUpstream.bind(void 0, ctx),
    push: push.bind(void 0, ctx),
    pull: pull.bind(void 0, ctx, state),
    ...ctx.experimentalFeatures.lixFs ? lixFs(state.nodeishFs) : {},
    // only exposed for testing
    _emptyWorkdir: emptyWorkdir.bind(void 0, ctx, state),
    _checkOutPlaceholders: checkOutPlaceholders.bind(void 0, ctx, state),
    _add: add$3.bind(void 0, ctx, state),
    _remove: remove$1.bind(void 0, ctx, state),
    _isoCommit: isoCommit.bind(void 0, ctx)
  };
}
async function findRepoRoot(args) {
  const gitroot = await findRoot({
    fs: args.nodeishFs,
    filepath: args.path
  }).catch(() => void 0);
  return gitroot ? "file://" + gitroot : void 0;
}
const ignores = ["node_modules", ".git"];
const listProjects = async (nodeishFs, from) => {
  const recursionLimit = 5;
  const projects = [];
  async function searchDir(path, depth) {
    if (depth > recursionLimit) {
      return;
    }
    const files = await nodeishFs.readdir(path);
    for (const file of files) {
      const filePath = `${path}/${file}`;
      try {
        const stats = await nodeishFs.stat(filePath);
        if (stats.isDirectory()) {
          if (ignores.includes(file)) {
            continue;
          }
          if (file.endsWith(".inlang")) {
            projects.push({ projectPath: filePath });
          } else {
            await searchDir(filePath, depth + 1);
          }
        }
      } catch {
        continue;
      }
    }
  }
  await searchDir(from, 0);
  for (const project of projects) {
    project.projectPath = project.projectPath.replace(/\/\//g, "/");
  }
  return projects;
};
const runCompiler = async (ctx) => {
  const absoluteOutdir = nodePath__default.resolve(process.cwd(), ctx.outdir);
  const output = await compile({
    messages: ctx.project.query.messages.getAll(),
    settings: ctx.project.settings(),
    projectId: ctx.project.id
  });
  await writeOutput(absoluteOutdir, output, ctx.repo.nodeishFs);
  return ctx;
};
function getNewProjectTemplate() {
  if (!("structuredClone" in globalThis)) {
    try {
      return JSON.parse(JSON.stringify(defaultProjectSettings));
    } catch {
      throw new Error(
        "structuredClone is not supported in your Node Version. Please use version 17 or higher"
      );
    }
  }
  return structuredClone(defaultProjectSettings);
}
const DEFAULT_PROJECT_PATH = "./project.inlang";
const DEFAULT_OUTDIR = "./src/paraglide";
const defaults = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_OUTDIR,
  DEFAULT_PROJECT_PATH,
  getNewProjectTemplate
}, Symbol.toStringTag, { value: "Module" }));
const compileCommand = new Command().name("compile").summary("Compiles inlang Paraglide-JS.").requiredOption("--project <path>", 'The path to the inlang project. Example: "./project.inlang"').requiredOption(
  "--outdir <path>",
  'The path to the output directory. Example: "./src/paraglide"',
  DEFAULT_OUTDIR
).requiredOption("--silent", "Only log errors to the console", false).requiredOption("--watch", "Watch for changes and recompile.", false).action(async (options) => {
  const logger = new Logger({ silent: options.silent, prefix: true });
  const path = resolve(process.cwd(), options.project);
  logger.info(`Compiling inlang project at "${options.project}".`);
  const repoRoot = await findRepoRoot({ nodeishFs: nodeFsPromises, path });
  const repo = await openRepository(repoRoot || "file://" + process.cwd(), {
    nodeishFs: nodeFsPromises
  });
  if (!repoRoot) {
    logger.warn(`Could not find repository root for path ${path}`);
  }
  const project = await loadProject({
    projectPath: path,
    repo,
    appId: "library.inlang.paraglideJs"
  });
  if (project.errors().length > 0) {
    const { nonFatalErrors, fatalErrors } = classifyProjectErrors(project.errors());
    if (fatalErrors.length > 0) {
      logger.error(`The project has fatal errors:`);
      for (const error of [...fatalErrors, ...nonFatalErrors]) {
        logger.error(error);
      }
      process.exit(1);
    }
    if (nonFatalErrors.length > 0) {
      logger.warn(`The project has warnings:`);
      for (const error of nonFatalErrors) {
        logger.warn(error);
      }
    }
  }
  await runCompiler({
    project,
    repo,
    outdir: options.outdir
  });
  if (options.watch) {
    process.on("SIGINT", () => {
      process.exit(0);
    });
    let numChanges = 0;
    project.query.messages.getAll.subscribe(async (messages2) => {
      numChanges++;
      if (messages2.length === 0)
        return;
      if (numChanges === 1)
        return;
      logger.info("Messages changed. Recompiling...");
      await runCompiler({
        project,
        repo,
        outdir: options.outdir
      });
    });
    while (true) {
      await new Promise((resolve2) => setTimeout(resolve2, 1e4));
    }
  }
  logger.info("Successfully compiled the project.");
});
const prompt = async (message, options) => {
  const response = await consola.prompt(message, options);
  if ((response == null ? void 0 : response.toString()) === "Symbol(clack:cancel)") {
    process.exit(0);
  }
  return response;
};
const promptSelection = async (message, options = { options: [] }) => {
  return prompt(message, { type: "select", ...options });
};
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  prompt,
  promptSelection
}, Symbol.toStringTag, { value: "Module" }));
const checkForUncommittedChanges = async (ctx) => {
  try {
    if ((await execAsync("git status --porcelain")).toString().length === 0) {
      return ctx;
    }
    ctx.logger.info(
      `You have uncommitted changes.

Please commit your changes before initializing inlang Paraglide-JS. Committing outstanding changes ensures that you don't lose any work, and see the changes the paraglide-js init command introduces.`
    );
    const response = await prompt(
      "Do you want to initialize inlang Paraglide-JS without committing your current changes?",
      {
        type: "confirm",
        initial: false
      }
    );
    if (response === true) {
      return ctx;
    } else {
      process.exit(0);
    }
  } catch (e) {
    return ctx;
  }
};
function execAsync(command) {
  return new Promise((resolve2, reject) => {
    childProcess.exec(command, (error, stdout) => {
      if (error) {
        reject(error);
      } else {
        resolve2(stdout);
      }
    });
  });
}
const initializeInlangProject = async (ctx) => {
  const existingProjectPaths = (await listProjects(ctx.repo.nodeishFs, ctx.repoRoot)).map(
    (v) => v.projectPath
  );
  if (existingProjectPaths.length > 0) {
    const { project, projectPath } = await existingProjectFlow({
      existingProjectPaths,
      repo: ctx.repo,
      logger: ctx.logger,
      appId: ctx.appId
    });
    return {
      ...ctx,
      project,
      projectPath
    };
  } else {
    const { project, projectPath } = await createNewProjectFlow(ctx);
    return {
      ...ctx,
      project,
      projectPath
    };
  }
};
const existingProjectFlow = async (ctx) => {
  const NEW_PROJECT_VALUE = "newProject";
  const commonPrefix = getCommonPrefix(ctx.existingProjectPaths);
  const options = ctx.existingProjectPaths.map((path) => {
    return {
      label: path.replace(commonPrefix, ""),
      value: path
    };
  });
  const selection = await prompt(
    `Do you want to use an existing Inlang Project or create a new one?`,
    {
      type: "select",
      options: [{ label: "Create a new project", value: NEW_PROJECT_VALUE }, ...options]
    }
  );
  if (selection === NEW_PROJECT_VALUE)
    return createNewProjectFlow(ctx);
  const projectPath = selection;
  const project = await loadProject({
    projectPath,
    repo: ctx.repo,
    appId: ctx.appId
  });
  if (project.errors().length > 0) {
    ctx.logger.error(
      "Aborting paragilde initialization. - The selected project has errors. Either fix them, or remove the project and create a new one."
    );
    for (const error of project.errors()) {
      ctx.logger.error(error);
    }
    process.exit(1);
  }
  return { project, projectPath };
};
function parseLanguageTagInput(input) {
  const languageTags = input.replaceAll(/[,:\s]/g, " ").split(" ").filter(Boolean).map((tag2) => tag2.toLowerCase());
  const validLanguageTags = [];
  const invalidLanguageTags = [];
  for (const tag2 of languageTags) {
    if (isValidLanguageTag(tag2)) {
      validLanguageTags.push(tag2);
    } else {
      invalidLanguageTags.push(tag2);
    }
  }
  return {
    validLanguageTags,
    invalidLanguageTags
  };
}
async function promptForLanguageTags(initialLanguageTags = []) {
  const languageTagsInput = await prompt("Which languages do you want to support?", {
    type: "text",
    placeholder: "en, de-ch, ar",
    initial: initialLanguageTags.length ? initialLanguageTags.join(", ") : void 0
  }) ?? "";
  const { invalidLanguageTags, validLanguageTags } = parseLanguageTagInput(languageTagsInput);
  if (validLanguageTags.length === 0) {
    consola.warn("You must specify at least one language tag");
    return await promptForLanguageTags();
  }
  if (invalidLanguageTags.length > 0) {
    const message = invalidLanguageTags.length === 1 ? invalidLanguageTags[0] + " isn't a valid language tag. Please stick to IEEE BCP-47 Language Tags" : invalidLanguageTags.map((tag2) => `"${tag2}"`).join(", ") + " aren't valid language tags. Please stick to IEEE BCP-47 Language Tags";
    consola.warn(message);
    return await promptForLanguageTags(validLanguageTags);
  }
  return validLanguageTags;
}
const createNewProjectFlow = async (ctx) => {
  const languageTags = await promptForLanguageTags();
  const settings = getNewProjectTemplate();
  const sourceLanguageTag = languageTags[0];
  if (!sourceLanguageTag)
    throw new Error("sourceLanguageTag is not defined");
  settings.languageTags = languageTags;
  settings.sourceLanguageTag = sourceLanguageTag;
  const messagePath = settings["plugin.inlang.messageFormat"].pathPattern;
  const messageDir = nodePath__default.dirname(nodePath__default.resolve(process.cwd(), messagePath));
  await ctx.repo.nodeishFs.mkdir(messageDir, { recursive: true });
  await Promise.allSettled(
    languageTags.map(async (languageTag) => {
      const languageFile = nodePath__default.resolve(messageDir, languageTag + ".json");
      await ctx.repo.nodeishFs.writeFile(
        languageFile,
        dedent`
                    {
                        "$schema": "https://inlang.com/schema/inlang-message-format"
                    }`
      );
    })
  );
  ctx.logger.info(`Creating a new inlang project in the current working directory.`);
  const projectPath = nodePath__default.resolve(process.cwd(), DEFAULT_PROJECT_PATH);
  await createNewProject({
    projectPath,
    repo: ctx.repo,
    projectSettings: settings
  });
  const project = await loadProject({
    projectPath,
    repo: ctx.repo,
    appId: ctx.appId
  });
  if (project.errors().length > 0) {
    ctx.logger.warn(
      "Failed to create a new inlang project.\n\nThis is likely an internal bug. Please file an issue at https://github.com/opral/monorepo."
    );
    for (const error of project.errors()) {
      ctx.logger.error(error);
    }
    return process.exit(1);
  } else {
    ctx.logger.success("Successfully created a new inlang project.");
  }
  return { project, projectPath };
};
function getCommonPrefix(strings2) {
  const strs = strings2.filter(Boolean);
  if (strs.length <= 1)
    return "";
  const firstString = strs[0];
  if (firstString === void 0) {
    return "";
  }
  return strs.reduce((commonPrefix, str2) => longestCommonPrefix(commonPrefix, str2), firstString);
}
function longestCommonPrefix(strA, strB) {
  let commonPrefix = "";
  for (let i = 0; i < Math.min(strA.length, strB.length); i++) {
    if (strA[i] === strB[i]) {
      commonPrefix += strA[i];
    } else {
      break;
    }
  }
  return commonPrefix;
}
function joinPath(...parts) {
  return parts.map((part) => part.replace(/\/$/, "")).join("/");
}
var esprima$1 = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory2) {
    module.exports = factory2();
  })(commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            /******/
            exports: {},
            /******/
            id: moduleId,
            /******/
            loaded: false
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        /* 0 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var comment_handler_1 = __webpack_require__(1);
          var jsx_parser_1 = __webpack_require__(3);
          var parser_1 = __webpack_require__(8);
          var tokenizer_1 = __webpack_require__(15);
          function parse2(code, options, delegate) {
            var commentHandler = null;
            var proxyDelegate = function(node, metadata) {
              if (delegate) {
                delegate(node, metadata);
              }
              if (commentHandler) {
                commentHandler.visit(node, metadata);
              }
            };
            var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
            var collectComment = false;
            if (options) {
              collectComment = typeof options.comment === "boolean" && options.comment;
              var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
              if (collectComment || attachComment) {
                commentHandler = new comment_handler_1.CommentHandler();
                commentHandler.attach = attachComment;
                options.comment = true;
                parserDelegate = proxyDelegate;
              }
            }
            var isModule = false;
            if (options && typeof options.sourceType === "string") {
              isModule = options.sourceType === "module";
            }
            var parser;
            if (options && typeof options.jsx === "boolean" && options.jsx) {
              parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
            } else {
              parser = new parser_1.Parser(code, options, parserDelegate);
            }
            var program = isModule ? parser.parseModule() : parser.parseScript();
            var ast = program;
            if (collectComment && commentHandler) {
              ast.comments = commentHandler.comments;
            }
            if (parser.config.tokens) {
              ast.tokens = parser.tokens;
            }
            if (parser.config.tolerant) {
              ast.errors = parser.errorHandler.errors;
            }
            return ast;
          }
          exports2.parse = parse2;
          function parseModule(code, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "module";
            return parse2(code, parsingOptions, delegate);
          }
          exports2.parseModule = parseModule;
          function parseScript(code, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "script";
            return parse2(code, parsingOptions, delegate);
          }
          exports2.parseScript = parseScript;
          function tokenize2(code, options, delegate) {
            var tokenizer = new tokenizer_1.Tokenizer(code, options);
            var tokens2;
            tokens2 = [];
            try {
              while (true) {
                var token = tokenizer.getNextToken();
                if (!token) {
                  break;
                }
                if (delegate) {
                  token = delegate(token);
                }
                tokens2.push(token);
              }
            } catch (e) {
              tokenizer.errorHandler.tolerate(e);
            }
            if (tokenizer.errorHandler.tolerant) {
              tokens2.errors = tokenizer.errors();
            }
            return tokens2;
          }
          exports2.tokenize = tokenize2;
          var syntax_1 = __webpack_require__(2);
          exports2.Syntax = syntax_1.Syntax;
          exports2.version = "4.0.1";
        },
        /* 1 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var CommentHandler = function() {
            function CommentHandler2() {
              this.attach = false;
              this.comments = [];
              this.stack = [];
              this.leading = [];
              this.trailing = [];
            }
            CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
              if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                var innerComments = [];
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                    this.trailing.splice(i, 1);
                  }
                }
                if (innerComments.length) {
                  node.innerComments = innerComments;
                }
              }
            };
            CommentHandler2.prototype.findTrailingComments = function(metadata) {
              var trailingComments = [];
              if (this.trailing.length > 0) {
                for (var i = this.trailing.length - 1; i >= 0; --i) {
                  var entry_1 = this.trailing[i];
                  if (entry_1.start >= metadata.end.offset) {
                    trailingComments.unshift(entry_1.comment);
                  }
                }
                this.trailing.length = 0;
                return trailingComments;
              }
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.node.trailingComments) {
                var firstComment = entry.node.trailingComments[0];
                if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                  trailingComments = entry.node.trailingComments;
                  delete entry.node.trailingComments;
                }
              }
              return trailingComments;
            };
            CommentHandler2.prototype.findLeadingComments = function(metadata) {
              var leadingComments = [];
              var target;
              while (this.stack.length > 0) {
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.start >= metadata.start.offset) {
                  target = entry.node;
                  this.stack.pop();
                } else {
                  break;
                }
              }
              if (target) {
                var count = target.leadingComments ? target.leadingComments.length : 0;
                for (var i = count - 1; i >= 0; --i) {
                  var comment = target.leadingComments[i];
                  if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i, 1);
                  }
                }
                if (target.leadingComments && target.leadingComments.length === 0) {
                  delete target.leadingComments;
                }
                return leadingComments;
              }
              for (var i = this.leading.length - 1; i >= 0; --i) {
                var entry = this.leading[i];
                if (entry.start <= metadata.start.offset) {
                  leadingComments.unshift(entry.comment);
                  this.leading.splice(i, 1);
                }
              }
              return leadingComments;
            };
            CommentHandler2.prototype.visitNode = function(node, metadata) {
              if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                return;
              }
              this.insertInnerComments(node, metadata);
              var trailingComments = this.findTrailingComments(metadata);
              var leadingComments = this.findLeadingComments(metadata);
              if (leadingComments.length > 0) {
                node.leadingComments = leadingComments;
              }
              if (trailingComments.length > 0) {
                node.trailingComments = trailingComments;
              }
              this.stack.push({
                node,
                start: metadata.start.offset
              });
            };
            CommentHandler2.prototype.visitComment = function(node, metadata) {
              var type2 = node.type[0] === "L" ? "Line" : "Block";
              var comment = {
                type: type2,
                value: node.value
              };
              if (node.range) {
                comment.range = node.range;
              }
              if (node.loc) {
                comment.loc = node.loc;
              }
              this.comments.push(comment);
              if (this.attach) {
                var entry = {
                  comment: {
                    type: type2,
                    value: node.value,
                    range: [metadata.start.offset, metadata.end.offset]
                  },
                  start: metadata.start.offset
                };
                if (node.loc) {
                  entry.comment.loc = node.loc;
                }
                node.type = type2;
                this.leading.push(entry);
                this.trailing.push(entry);
              }
            };
            CommentHandler2.prototype.visit = function(node, metadata) {
              if (node.type === "LineComment") {
                this.visitComment(node, metadata);
              } else if (node.type === "BlockComment") {
                this.visitComment(node, metadata);
              } else if (this.attach) {
                this.visitNode(node, metadata);
              }
            };
            return CommentHandler2;
          }();
          exports2.CommentHandler = CommentHandler;
        },
        /* 2 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        /* 3 */
        /***/
        function(module2, exports2, __webpack_require__) {
          var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b)
                if (b.hasOwnProperty(p))
                  d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports2, "__esModule", { value: true });
          var character_1 = __webpack_require__(4);
          var JSXNode = __webpack_require__(5);
          var jsx_syntax_1 = __webpack_require__(6);
          var Node = __webpack_require__(7);
          var parser_1 = __webpack_require__(8);
          var token_1 = __webpack_require__(13);
          var xhtml_entities_1 = __webpack_require__(14);
          token_1.TokenName[
            100
            /* Identifier */
          ] = "JSXIdentifier";
          token_1.TokenName[
            101
            /* Text */
          ] = "JSXText";
          function getQualifiedElementName(elementName) {
            var qualifiedName;
            switch (elementName.type) {
              case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                var id = elementName;
                qualifiedName = id.name;
                break;
              case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                var ns = elementName;
                qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                break;
              case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                var expr = elementName;
                qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                break;
            }
            return qualifiedName;
          }
          var JSXParser = function(_super) {
            __extends(JSXParser2, _super);
            function JSXParser2(code, options, delegate) {
              return _super.call(this, code, options, delegate) || this;
            }
            JSXParser2.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
            };
            JSXParser2.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index;
              this.scanner.lineNumber = this.startMarker.line;
              this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
            };
            JSXParser2.prototype.finishJSX = function() {
              this.nextToken();
            };
            JSXParser2.prototype.reenterJSX = function() {
              this.startJSX();
              this.expectJSX("}");
              if (this.config.tokens) {
                this.tokens.pop();
              }
            };
            JSXParser2.prototype.createJSXNode = function() {
              this.collectComments();
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.scanXHTMLEntity = function(quote2) {
              var result = "&";
              var valid = true;
              var terminated = false;
              var numeric = false;
              var hex = false;
              while (!this.scanner.eof() && valid && !terminated) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === quote2) {
                  break;
                }
                terminated = ch === ";";
                result += ch;
                ++this.scanner.index;
                if (!terminated) {
                  switch (result.length) {
                    case 2:
                      numeric = ch === "#";
                      break;
                    case 3:
                      if (numeric) {
                        hex = ch === "x";
                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                        numeric = numeric && !hex;
                      }
                      break;
                    default:
                      valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                      valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                      break;
                  }
                }
              }
              if (valid && terminated && result.length > 2) {
                var str2 = result.substr(1, result.length - 2);
                if (numeric && str2.length > 1) {
                  result = String.fromCharCode(parseInt(str2.substr(1), 10));
                } else if (hex && str2.length > 2) {
                  result = String.fromCharCode(parseInt("0" + str2.substr(1), 16));
                } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str2]) {
                  result = xhtml_entities_1.XHTMLEntities[str2];
                }
              }
              return result;
            };
            JSXParser2.prototype.lexJSX = function() {
              var cp = this.scanner.source.charCodeAt(this.scanner.index);
              if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                var value2 = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value: value2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (cp === 34 || cp === 39) {
                var start = this.scanner.index;
                var quote2 = this.scanner.source[this.scanner.index++];
                var str2 = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index++];
                  if (ch === quote2) {
                    break;
                  } else if (ch === "&") {
                    str2 += this.scanXHTMLEntity(quote2);
                  } else {
                    str2 += ch;
                  }
                }
                return {
                  type: 8,
                  value: str2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 46) {
                var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                var value2 = n1 === 46 && n2 === 46 ? "..." : ".";
                var start = this.scanner.index;
                this.scanner.index += value2.length;
                return {
                  type: 7,
                  value: value2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 96) {
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              }
              if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                var start = this.scanner.index;
                ++this.scanner.index;
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source.charCodeAt(this.scanner.index);
                  if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                    ++this.scanner.index;
                  } else if (ch === 45) {
                    ++this.scanner.index;
                  } else {
                    break;
                  }
                }
                var id = this.scanner.source.slice(start, this.scanner.index);
                return {
                  type: 100,
                  value: id,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            };
            JSXParser2.prototype.nextJSXToken = function() {
              this.collectComments();
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = this.lexJSX();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              if (this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var start = this.scanner.index;
              var text = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === "{" || ch === "<") {
                  break;
                }
                ++this.scanner.index;
                text += ch;
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.scanner.lineNumber;
                  if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                    ++this.scanner.index;
                  }
                  this.scanner.lineStart = this.scanner.index;
                }
              }
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = {
                type: 101,
                value: text,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
              if (text.length > 0 && this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.peekJSXToken = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next2 = this.lexJSX();
              this.scanner.restoreState(state);
              return next2;
            };
            JSXParser2.prototype.expectJSX = function(value2) {
              var token = this.nextJSXToken();
              if (token.type !== 7 || token.value !== value2) {
                this.throwUnexpectedToken(token);
              }
            };
            JSXParser2.prototype.matchJSX = function(value2) {
              var next2 = this.peekJSXToken();
              return next2.type === 7 && next2.value === value2;
            };
            JSXParser2.prototype.parseJSXIdentifier = function() {
              var node = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 100) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
            };
            JSXParser2.prototype.parseJSXElementName = function() {
              var node = this.createJSXNode();
              var elementName = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = elementName;
                this.expectJSX(":");
                var name_1 = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
              } else if (this.matchJSX(".")) {
                while (this.matchJSX(".")) {
                  var object = elementName;
                  this.expectJSX(".");
                  var property = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                }
              }
              return elementName;
            };
            JSXParser2.prototype.parseJSXAttributeName = function() {
              var node = this.createJSXNode();
              var attributeName;
              var identifier = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = identifier;
                this.expectJSX(":");
                var name_2 = this.parseJSXIdentifier();
                attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
              } else {
                attributeName = identifier;
              }
              return attributeName;
            };
            JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
              var node = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 8) {
                this.throwUnexpectedToken(token);
              }
              var raw = this.getTokenRaw(token);
              return this.finalize(node, new Node.Literal(token.value, raw));
            };
            JSXParser2.prototype.parseJSXExpressionAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.finishJSX();
              if (this.match("}")) {
                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
              }
              var expression = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            };
            JSXParser2.prototype.parseJSXNameValueAttribute = function() {
              var node = this.createJSXNode();
              var name = this.parseJSXAttributeName();
              var value2 = null;
              if (this.matchJSX("=")) {
                this.expectJSX("=");
                value2 = this.parseJSXAttributeValue();
              }
              return this.finalize(node, new JSXNode.JSXAttribute(name, value2));
            };
            JSXParser2.prototype.parseJSXSpreadAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.expectJSX("...");
              this.finishJSX();
              var argument = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
            };
            JSXParser2.prototype.parseJSXAttributes = function() {
              var attributes = [];
              while (!this.matchJSX("/") && !this.matchJSX(">")) {
                var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                attributes.push(attribute);
              }
              return attributes;
            };
            JSXParser2.prototype.parseJSXOpeningElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXBoundaryElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              if (this.matchJSX("/")) {
                this.expectJSX("/");
                var name_3 = this.parseJSXElementName();
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
              }
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXEmptyExpression = function() {
              var node = this.createJSXChildNode();
              this.collectComments();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              return this.finalize(node, new JSXNode.JSXEmptyExpression());
            };
            JSXParser2.prototype.parseJSXExpressionContainer = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              var expression;
              if (this.matchJSX("}")) {
                expression = this.parseJSXEmptyExpression();
                this.expectJSX("}");
              } else {
                this.finishJSX();
                expression = this.parseAssignmentExpression();
                this.reenterJSX();
              }
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXChildren = function() {
              var children = [];
              while (!this.scanner.eof()) {
                var node = this.createJSXChildNode();
                var token = this.nextJSXText();
                if (token.start < token.end) {
                  var raw = this.getTokenRaw(token);
                  var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                  children.push(child);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var container = this.parseJSXExpressionContainer();
                  children.push(container);
                } else {
                  break;
                }
              }
              return children;
            };
            JSXParser2.prototype.parseComplexJSXElement = function(el) {
              var stack = [];
              while (!this.scanner.eof()) {
                el.children = el.children.concat(this.parseJSXChildren());
                var node = this.createJSXChildNode();
                var element = this.parseJSXBoundaryElement();
                if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                  var opening = element;
                  if (opening.selfClosing) {
                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                  } else {
                    stack.push(el);
                    el = { node, opening, closing: null, children: [] };
                  }
                }
                if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                  el.closing = element;
                  var open_1 = getQualifiedElementName(el.opening.name);
                  var close_1 = getQualifiedElementName(el.closing.name);
                  if (open_1 !== close_1) {
                    this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                  }
                  if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                  } else {
                    break;
                  }
                }
              }
              return el;
            };
            JSXParser2.prototype.parseJSXElement = function() {
              var node = this.createJSXNode();
              var opening = this.parseJSXOpeningElement();
              var children = [];
              var closing = null;
              if (!opening.selfClosing) {
                var el = this.parseComplexJSXElement({ node, opening, closing, children });
                children = el.children;
                closing = el.closing;
              }
              return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
            };
            JSXParser2.prototype.parseJSXRoot = function() {
              if (this.config.tokens) {
                this.tokens.pop();
              }
              this.startJSX();
              var element = this.parseJSXElement();
              this.finishJSX();
              return element;
            };
            JSXParser2.prototype.isStartOfExpression = function() {
              return _super.prototype.isStartOfExpression.call(this) || this.match("<");
            };
            return JSXParser2;
          }(parser_1.Parser);
          exports2.JSXParser = JSXParser;
        },
        /* 4 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Regex = {
            // Unicode v8.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            // Unicode v8.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          exports2.Character = {
            /* tslint:disable:no-bitwise */
            fromCodePoint: function(cp) {
              return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
            },
            // https://tc39.github.io/ecma262/#sec-white-space
            isWhiteSpace: function(cp) {
              return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
            },
            // https://tc39.github.io/ecma262/#sec-line-terminators
            isLineTerminator: function(cp) {
              return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
            },
            // https://tc39.github.io/ecma262/#sec-names-and-keywords
            isIdentifierStart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
            },
            isIdentifierPart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
            },
            // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
            isDecimalDigit: function(cp) {
              return cp >= 48 && cp <= 57;
            },
            isHexDigit: function(cp) {
              return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
            },
            isOctalDigit: function(cp) {
              return cp >= 48 && cp <= 55;
            }
          };
        },
        /* 5 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var jsx_syntax_1 = __webpack_require__(6);
          var JSXClosingElement = function() {
            function JSXClosingElement2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
              this.name = name;
            }
            return JSXClosingElement2;
          }();
          exports2.JSXClosingElement = JSXClosingElement;
          var JSXElement = function() {
            function JSXElement2(openingElement, children, closingElement) {
              this.type = jsx_syntax_1.JSXSyntax.JSXElement;
              this.openingElement = openingElement;
              this.children = children;
              this.closingElement = closingElement;
            }
            return JSXElement2;
          }();
          exports2.JSXElement = JSXElement;
          var JSXEmptyExpression = function() {
            function JSXEmptyExpression2() {
              this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
            }
            return JSXEmptyExpression2;
          }();
          exports2.JSXEmptyExpression = JSXEmptyExpression;
          var JSXExpressionContainer = function() {
            function JSXExpressionContainer2(expression) {
              this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
              this.expression = expression;
            }
            return JSXExpressionContainer2;
          }();
          exports2.JSXExpressionContainer = JSXExpressionContainer;
          var JSXIdentifier = function() {
            function JSXIdentifier2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
              this.name = name;
            }
            return JSXIdentifier2;
          }();
          exports2.JSXIdentifier = JSXIdentifier;
          var JSXMemberExpression = function() {
            function JSXMemberExpression2(object, property) {
              this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
              this.object = object;
              this.property = property;
            }
            return JSXMemberExpression2;
          }();
          exports2.JSXMemberExpression = JSXMemberExpression;
          var JSXAttribute = function() {
            function JSXAttribute2(name, value2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
              this.name = name;
              this.value = value2;
            }
            return JSXAttribute2;
          }();
          exports2.JSXAttribute = JSXAttribute;
          var JSXNamespacedName = function() {
            function JSXNamespacedName2(namespace, name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
              this.namespace = namespace;
              this.name = name;
            }
            return JSXNamespacedName2;
          }();
          exports2.JSXNamespacedName = JSXNamespacedName;
          var JSXOpeningElement = function() {
            function JSXOpeningElement2(name, selfClosing, attributes) {
              this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
              this.name = name;
              this.selfClosing = selfClosing;
              this.attributes = attributes;
            }
            return JSXOpeningElement2;
          }();
          exports2.JSXOpeningElement = JSXOpeningElement;
          var JSXSpreadAttribute = function() {
            function JSXSpreadAttribute2(argument) {
              this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
              this.argument = argument;
            }
            return JSXSpreadAttribute2;
          }();
          exports2.JSXSpreadAttribute = JSXSpreadAttribute;
          var JSXText = function() {
            function JSXText2(value2, raw) {
              this.type = jsx_syntax_1.JSXSyntax.JSXText;
              this.value = value2;
              this.raw = raw;
            }
            return JSXText2;
          }();
          exports2.JSXText = JSXText;
        },
        /* 6 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        /* 7 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var ArrayExpression = function() {
            function ArrayExpression2(elements) {
              this.type = syntax_1.Syntax.ArrayExpression;
              this.elements = elements;
            }
            return ArrayExpression2;
          }();
          exports2.ArrayExpression = ArrayExpression;
          var ArrayPattern = function() {
            function ArrayPattern2(elements) {
              this.type = syntax_1.Syntax.ArrayPattern;
              this.elements = elements;
            }
            return ArrayPattern2;
          }();
          exports2.ArrayPattern = ArrayPattern;
          var ArrowFunctionExpression = function() {
            function ArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = false;
            }
            return ArrowFunctionExpression2;
          }();
          exports2.ArrowFunctionExpression = ArrowFunctionExpression;
          var AssignmentExpression = function() {
            function AssignmentExpression2(operator, left, right) {
              this.type = syntax_1.Syntax.AssignmentExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return AssignmentExpression2;
          }();
          exports2.AssignmentExpression = AssignmentExpression;
          var AssignmentPattern = function() {
            function AssignmentPattern2(left, right) {
              this.type = syntax_1.Syntax.AssignmentPattern;
              this.left = left;
              this.right = right;
            }
            return AssignmentPattern2;
          }();
          exports2.AssignmentPattern = AssignmentPattern;
          var AsyncArrowFunctionExpression = function() {
            function AsyncArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = true;
            }
            return AsyncArrowFunctionExpression2;
          }();
          exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
          var AsyncFunctionDeclaration = function() {
            function AsyncFunctionDeclaration2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionDeclaration2;
          }();
          exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
          var AsyncFunctionExpression = function() {
            function AsyncFunctionExpression2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionExpression2;
          }();
          exports2.AsyncFunctionExpression = AsyncFunctionExpression;
          var AwaitExpression = function() {
            function AwaitExpression2(argument) {
              this.type = syntax_1.Syntax.AwaitExpression;
              this.argument = argument;
            }
            return AwaitExpression2;
          }();
          exports2.AwaitExpression = AwaitExpression;
          var BinaryExpression = function() {
            function BinaryExpression2(operator, left, right) {
              var logical = operator === "||" || operator === "&&";
              this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return BinaryExpression2;
          }();
          exports2.BinaryExpression = BinaryExpression;
          var BlockStatement = function() {
            function BlockStatement2(body) {
              this.type = syntax_1.Syntax.BlockStatement;
              this.body = body;
            }
            return BlockStatement2;
          }();
          exports2.BlockStatement = BlockStatement;
          var BreakStatement = function() {
            function BreakStatement2(label) {
              this.type = syntax_1.Syntax.BreakStatement;
              this.label = label;
            }
            return BreakStatement2;
          }();
          exports2.BreakStatement = BreakStatement;
          var CallExpression = function() {
            function CallExpression2(callee, args) {
              this.type = syntax_1.Syntax.CallExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return CallExpression2;
          }();
          exports2.CallExpression = CallExpression;
          var CatchClause = function() {
            function CatchClause2(param, body) {
              this.type = syntax_1.Syntax.CatchClause;
              this.param = param;
              this.body = body;
            }
            return CatchClause2;
          }();
          exports2.CatchClause = CatchClause;
          var ClassBody = function() {
            function ClassBody2(body) {
              this.type = syntax_1.Syntax.ClassBody;
              this.body = body;
            }
            return ClassBody2;
          }();
          exports2.ClassBody = ClassBody;
          var ClassDeclaration = function() {
            function ClassDeclaration2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassDeclaration;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassDeclaration2;
          }();
          exports2.ClassDeclaration = ClassDeclaration;
          var ClassExpression = function() {
            function ClassExpression2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassExpression;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassExpression2;
          }();
          exports2.ClassExpression = ClassExpression;
          var ComputedMemberExpression = function() {
            function ComputedMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = true;
              this.object = object;
              this.property = property;
            }
            return ComputedMemberExpression2;
          }();
          exports2.ComputedMemberExpression = ComputedMemberExpression;
          var ConditionalExpression = function() {
            function ConditionalExpression2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.ConditionalExpression;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return ConditionalExpression2;
          }();
          exports2.ConditionalExpression = ConditionalExpression;
          var ContinueStatement = function() {
            function ContinueStatement2(label) {
              this.type = syntax_1.Syntax.ContinueStatement;
              this.label = label;
            }
            return ContinueStatement2;
          }();
          exports2.ContinueStatement = ContinueStatement;
          var DebuggerStatement = function() {
            function DebuggerStatement2() {
              this.type = syntax_1.Syntax.DebuggerStatement;
            }
            return DebuggerStatement2;
          }();
          exports2.DebuggerStatement = DebuggerStatement;
          var Directive = function() {
            function Directive2(expression, directive) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
              this.directive = directive;
            }
            return Directive2;
          }();
          exports2.Directive = Directive;
          var DoWhileStatement = function() {
            function DoWhileStatement2(body, test) {
              this.type = syntax_1.Syntax.DoWhileStatement;
              this.body = body;
              this.test = test;
            }
            return DoWhileStatement2;
          }();
          exports2.DoWhileStatement = DoWhileStatement;
          var EmptyStatement = function() {
            function EmptyStatement2() {
              this.type = syntax_1.Syntax.EmptyStatement;
            }
            return EmptyStatement2;
          }();
          exports2.EmptyStatement = EmptyStatement;
          var ExportAllDeclaration = function() {
            function ExportAllDeclaration2(source) {
              this.type = syntax_1.Syntax.ExportAllDeclaration;
              this.source = source;
            }
            return ExportAllDeclaration2;
          }();
          exports2.ExportAllDeclaration = ExportAllDeclaration;
          var ExportDefaultDeclaration = function() {
            function ExportDefaultDeclaration2(declaration) {
              this.type = syntax_1.Syntax.ExportDefaultDeclaration;
              this.declaration = declaration;
            }
            return ExportDefaultDeclaration2;
          }();
          exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
          var ExportNamedDeclaration = function() {
            function ExportNamedDeclaration2(declaration, specifiers, source) {
              this.type = syntax_1.Syntax.ExportNamedDeclaration;
              this.declaration = declaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ExportNamedDeclaration2;
          }();
          exports2.ExportNamedDeclaration = ExportNamedDeclaration;
          var ExportSpecifier = function() {
            function ExportSpecifier2(local, exported) {
              this.type = syntax_1.Syntax.ExportSpecifier;
              this.exported = exported;
              this.local = local;
            }
            return ExportSpecifier2;
          }();
          exports2.ExportSpecifier = ExportSpecifier;
          var ExpressionStatement = function() {
            function ExpressionStatement2(expression) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
            }
            return ExpressionStatement2;
          }();
          exports2.ExpressionStatement = ExpressionStatement;
          var ForInStatement = function() {
            function ForInStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForInStatement;
              this.left = left;
              this.right = right;
              this.body = body;
              this.each = false;
            }
            return ForInStatement2;
          }();
          exports2.ForInStatement = ForInStatement;
          var ForOfStatement = function() {
            function ForOfStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForOfStatement;
              this.left = left;
              this.right = right;
              this.body = body;
            }
            return ForOfStatement2;
          }();
          exports2.ForOfStatement = ForOfStatement;
          var ForStatement = function() {
            function ForStatement2(init2, test, update, body) {
              this.type = syntax_1.Syntax.ForStatement;
              this.init = init2;
              this.test = test;
              this.update = update;
              this.body = body;
            }
            return ForStatement2;
          }();
          exports2.ForStatement = ForStatement;
          var FunctionDeclaration = function() {
            function FunctionDeclaration2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionDeclaration2;
          }();
          exports2.FunctionDeclaration = FunctionDeclaration;
          var FunctionExpression = function() {
            function FunctionExpression2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionExpression2;
          }();
          exports2.FunctionExpression = FunctionExpression;
          var Identifier = function() {
            function Identifier2(name) {
              this.type = syntax_1.Syntax.Identifier;
              this.name = name;
            }
            return Identifier2;
          }();
          exports2.Identifier = Identifier;
          var IfStatement = function() {
            function IfStatement2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.IfStatement;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return IfStatement2;
          }();
          exports2.IfStatement = IfStatement;
          var ImportDeclaration = function() {
            function ImportDeclaration2(specifiers, source) {
              this.type = syntax_1.Syntax.ImportDeclaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ImportDeclaration2;
          }();
          exports2.ImportDeclaration = ImportDeclaration;
          var ImportDefaultSpecifier = function() {
            function ImportDefaultSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportDefaultSpecifier;
              this.local = local;
            }
            return ImportDefaultSpecifier2;
          }();
          exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
          var ImportNamespaceSpecifier = function() {
            function ImportNamespaceSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
              this.local = local;
            }
            return ImportNamespaceSpecifier2;
          }();
          exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          var ImportSpecifier = function() {
            function ImportSpecifier2(local, imported) {
              this.type = syntax_1.Syntax.ImportSpecifier;
              this.local = local;
              this.imported = imported;
            }
            return ImportSpecifier2;
          }();
          exports2.ImportSpecifier = ImportSpecifier;
          var LabeledStatement = function() {
            function LabeledStatement2(label, body) {
              this.type = syntax_1.Syntax.LabeledStatement;
              this.label = label;
              this.body = body;
            }
            return LabeledStatement2;
          }();
          exports2.LabeledStatement = LabeledStatement;
          var Literal = function() {
            function Literal2(value2, raw) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value2;
              this.raw = raw;
            }
            return Literal2;
          }();
          exports2.Literal = Literal;
          var MetaProperty = function() {
            function MetaProperty2(meta2, property) {
              this.type = syntax_1.Syntax.MetaProperty;
              this.meta = meta2;
              this.property = property;
            }
            return MetaProperty2;
          }();
          exports2.MetaProperty = MetaProperty;
          var MethodDefinition = function() {
            function MethodDefinition2(key, computed, value2, kind, isStatic) {
              this.type = syntax_1.Syntax.MethodDefinition;
              this.key = key;
              this.computed = computed;
              this.value = value2;
              this.kind = kind;
              this.static = isStatic;
            }
            return MethodDefinition2;
          }();
          exports2.MethodDefinition = MethodDefinition;
          var Module = function() {
            function Module2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "module";
            }
            return Module2;
          }();
          exports2.Module = Module;
          var NewExpression = function() {
            function NewExpression2(callee, args) {
              this.type = syntax_1.Syntax.NewExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return NewExpression2;
          }();
          exports2.NewExpression = NewExpression;
          var ObjectExpression = function() {
            function ObjectExpression2(properties) {
              this.type = syntax_1.Syntax.ObjectExpression;
              this.properties = properties;
            }
            return ObjectExpression2;
          }();
          exports2.ObjectExpression = ObjectExpression;
          var ObjectPattern = function() {
            function ObjectPattern2(properties) {
              this.type = syntax_1.Syntax.ObjectPattern;
              this.properties = properties;
            }
            return ObjectPattern2;
          }();
          exports2.ObjectPattern = ObjectPattern;
          var Property = function() {
            function Property2(kind, key, computed, value2, method, shorthand) {
              this.type = syntax_1.Syntax.Property;
              this.key = key;
              this.computed = computed;
              this.value = value2;
              this.kind = kind;
              this.method = method;
              this.shorthand = shorthand;
            }
            return Property2;
          }();
          exports2.Property = Property;
          var RegexLiteral = function() {
            function RegexLiteral2(value2, raw, pattern2, flags) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value2;
              this.raw = raw;
              this.regex = { pattern: pattern2, flags };
            }
            return RegexLiteral2;
          }();
          exports2.RegexLiteral = RegexLiteral;
          var RestElement = function() {
            function RestElement2(argument) {
              this.type = syntax_1.Syntax.RestElement;
              this.argument = argument;
            }
            return RestElement2;
          }();
          exports2.RestElement = RestElement;
          var ReturnStatement = function() {
            function ReturnStatement2(argument) {
              this.type = syntax_1.Syntax.ReturnStatement;
              this.argument = argument;
            }
            return ReturnStatement2;
          }();
          exports2.ReturnStatement = ReturnStatement;
          var Script = function() {
            function Script2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "script";
            }
            return Script2;
          }();
          exports2.Script = Script;
          var SequenceExpression = function() {
            function SequenceExpression2(expressions) {
              this.type = syntax_1.Syntax.SequenceExpression;
              this.expressions = expressions;
            }
            return SequenceExpression2;
          }();
          exports2.SequenceExpression = SequenceExpression;
          var SpreadElement = function() {
            function SpreadElement2(argument) {
              this.type = syntax_1.Syntax.SpreadElement;
              this.argument = argument;
            }
            return SpreadElement2;
          }();
          exports2.SpreadElement = SpreadElement;
          var StaticMemberExpression = function() {
            function StaticMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = false;
              this.object = object;
              this.property = property;
            }
            return StaticMemberExpression2;
          }();
          exports2.StaticMemberExpression = StaticMemberExpression;
          var Super = function() {
            function Super2() {
              this.type = syntax_1.Syntax.Super;
            }
            return Super2;
          }();
          exports2.Super = Super;
          var SwitchCase = function() {
            function SwitchCase2(test, consequent) {
              this.type = syntax_1.Syntax.SwitchCase;
              this.test = test;
              this.consequent = consequent;
            }
            return SwitchCase2;
          }();
          exports2.SwitchCase = SwitchCase;
          var SwitchStatement = function() {
            function SwitchStatement2(discriminant, cases) {
              this.type = syntax_1.Syntax.SwitchStatement;
              this.discriminant = discriminant;
              this.cases = cases;
            }
            return SwitchStatement2;
          }();
          exports2.SwitchStatement = SwitchStatement;
          var TaggedTemplateExpression = function() {
            function TaggedTemplateExpression2(tag2, quasi) {
              this.type = syntax_1.Syntax.TaggedTemplateExpression;
              this.tag = tag2;
              this.quasi = quasi;
            }
            return TaggedTemplateExpression2;
          }();
          exports2.TaggedTemplateExpression = TaggedTemplateExpression;
          var TemplateElement = function() {
            function TemplateElement2(value2, tail) {
              this.type = syntax_1.Syntax.TemplateElement;
              this.value = value2;
              this.tail = tail;
            }
            return TemplateElement2;
          }();
          exports2.TemplateElement = TemplateElement;
          var TemplateLiteral = function() {
            function TemplateLiteral2(quasis, expressions) {
              this.type = syntax_1.Syntax.TemplateLiteral;
              this.quasis = quasis;
              this.expressions = expressions;
            }
            return TemplateLiteral2;
          }();
          exports2.TemplateLiteral = TemplateLiteral;
          var ThisExpression = function() {
            function ThisExpression2() {
              this.type = syntax_1.Syntax.ThisExpression;
            }
            return ThisExpression2;
          }();
          exports2.ThisExpression = ThisExpression;
          var ThrowStatement = function() {
            function ThrowStatement2(argument) {
              this.type = syntax_1.Syntax.ThrowStatement;
              this.argument = argument;
            }
            return ThrowStatement2;
          }();
          exports2.ThrowStatement = ThrowStatement;
          var TryStatement = function() {
            function TryStatement2(block, handler2, finalizer) {
              this.type = syntax_1.Syntax.TryStatement;
              this.block = block;
              this.handler = handler2;
              this.finalizer = finalizer;
            }
            return TryStatement2;
          }();
          exports2.TryStatement = TryStatement;
          var UnaryExpression = function() {
            function UnaryExpression2(operator, argument) {
              this.type = syntax_1.Syntax.UnaryExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = true;
            }
            return UnaryExpression2;
          }();
          exports2.UnaryExpression = UnaryExpression;
          var UpdateExpression = function() {
            function UpdateExpression2(operator, argument, prefix) {
              this.type = syntax_1.Syntax.UpdateExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = prefix;
            }
            return UpdateExpression2;
          }();
          exports2.UpdateExpression = UpdateExpression;
          var VariableDeclaration = function() {
            function VariableDeclaration2(declarations, kind) {
              this.type = syntax_1.Syntax.VariableDeclaration;
              this.declarations = declarations;
              this.kind = kind;
            }
            return VariableDeclaration2;
          }();
          exports2.VariableDeclaration = VariableDeclaration;
          var VariableDeclarator = function() {
            function VariableDeclarator2(id, init2) {
              this.type = syntax_1.Syntax.VariableDeclarator;
              this.id = id;
              this.init = init2;
            }
            return VariableDeclarator2;
          }();
          exports2.VariableDeclarator = VariableDeclarator;
          var WhileStatement = function() {
            function WhileStatement2(test, body) {
              this.type = syntax_1.Syntax.WhileStatement;
              this.test = test;
              this.body = body;
            }
            return WhileStatement2;
          }();
          exports2.WhileStatement = WhileStatement;
          var WithStatement = function() {
            function WithStatement2(object, body) {
              this.type = syntax_1.Syntax.WithStatement;
              this.object = object;
              this.body = body;
            }
            return WithStatement2;
          }();
          exports2.WithStatement = WithStatement;
          var YieldExpression = function() {
            function YieldExpression2(argument, delegate) {
              this.type = syntax_1.Syntax.YieldExpression;
              this.argument = argument;
              this.delegate = delegate;
            }
            return YieldExpression2;
          }();
          exports2.YieldExpression = YieldExpression;
        },
        /* 8 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var error_handler_1 = __webpack_require__(10);
          var messages_1 = __webpack_require__(11);
          var Node = __webpack_require__(7);
          var scanner_1 = __webpack_require__(12);
          var syntax_1 = __webpack_require__(2);
          var token_1 = __webpack_require__(13);
          var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
          var Parser = function() {
            function Parser2(code, options, delegate) {
              if (options === void 0) {
                options = {};
              }
              this.config = {
                range: typeof options.range === "boolean" && options.range,
                loc: typeof options.loc === "boolean" && options.loc,
                source: null,
                tokens: typeof options.tokens === "boolean" && options.tokens,
                comment: typeof options.comment === "boolean" && options.comment,
                tolerant: typeof options.tolerant === "boolean" && options.tolerant
              };
              if (this.config.loc && options.source && options.source !== null) {
                this.config.source = String(options.source);
              }
              this.delegate = delegate;
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = this.config.tolerant;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = this.config.comment;
              this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              };
              this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              };
              this.hasLineTerminator = false;
              this.context = {
                isModule: false,
                await: false,
                allowIn: true,
                allowStrictDirective: true,
                allowYield: true,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: false,
                isBindingElement: false,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                labelSet: {},
                strict: false
              };
              this.tokens = [];
              this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.nextToken();
              this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            Parser2.prototype.throwError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg2 = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              throw this.errorHandler.createError(index2, line, column, msg2);
            };
            Parser2.prototype.tolerateError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg2 = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.scanner.lineNumber;
              var column = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(index2, line, column, msg2);
            };
            Parser2.prototype.unexpectedTokenError = function(token, message) {
              var msg2 = message || messages_1.Messages.UnexpectedToken;
              var value2;
              if (token) {
                if (!message) {
                  msg2 = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                  if (token.type === 4) {
                    if (this.scanner.isFutureReservedWord(token.value)) {
                      msg2 = messages_1.Messages.UnexpectedReserved;
                    } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                      msg2 = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                value2 = token.value;
              } else {
                value2 = "ILLEGAL";
              }
              msg2 = msg2.replace("%0", value2);
              if (token && typeof token.lineNumber === "number") {
                var index2 = token.start;
                var line = token.lineNumber;
                var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                var column = token.start - lastMarkerLineStart + 1;
                return this.errorHandler.createError(index2, line, column, msg2);
              } else {
                var index2 = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                return this.errorHandler.createError(index2, line, column, msg2);
              }
            };
            Parser2.prototype.throwUnexpectedToken = function(token, message) {
              throw this.unexpectedTokenError(token, message);
            };
            Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
              this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
            };
            Parser2.prototype.collectComments = function() {
              if (!this.config.comment) {
                this.scanner.scanComments();
              } else {
                var comments = this.scanner.scanComments();
                if (comments.length > 0 && this.delegate) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var node = void 0;
                    node = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(e.slice[0], e.slice[1])
                    };
                    if (this.config.range) {
                      node.range = e.range;
                    }
                    if (this.config.loc) {
                      node.loc = e.loc;
                    }
                    var metadata = {
                      start: {
                        line: e.loc.start.line,
                        column: e.loc.start.column,
                        offset: e.range[0]
                      },
                      end: {
                        line: e.loc.end.line,
                        column: e.loc.end.column,
                        offset: e.range[1]
                      }
                    };
                    this.delegate(node, metadata);
                  }
                }
              }
            };
            Parser2.prototype.getTokenRaw = function(token) {
              return this.scanner.source.slice(token.start, token.end);
            };
            Parser2.prototype.convertToken = function(token) {
              var t = {
                type: token_1.TokenName[token.type],
                value: this.getTokenRaw(token)
              };
              if (this.config.range) {
                t.range = [token.start, token.end];
              }
              if (this.config.loc) {
                t.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                };
              }
              if (token.type === 9) {
                var pattern2 = token.pattern;
                var flags = token.flags;
                t.regex = { pattern: pattern2, flags };
              }
              return t;
            };
            Parser2.prototype.nextToken = function() {
              var token = this.lookahead;
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              this.collectComments();
              if (this.scanner.index !== this.startMarker.index) {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              }
              var next2 = this.scanner.lex();
              this.hasLineTerminator = token.lineNumber !== next2.lineNumber;
              if (next2 && this.context.strict && next2.type === 3) {
                if (this.scanner.isStrictModeReservedWord(next2.value)) {
                  next2.type = 4;
                }
              }
              this.lookahead = next2;
              if (this.config.tokens && next2.type !== 2) {
                this.tokens.push(this.convertToken(next2));
              }
              return token;
            };
            Parser2.prototype.nextRegexToken = function() {
              this.collectComments();
              var token = this.scanner.scanRegExp();
              if (this.config.tokens) {
                this.tokens.pop();
                this.tokens.push(this.convertToken(token));
              }
              this.lookahead = token;
              this.nextToken();
              return token;
            };
            Parser2.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            };
            Parser2.prototype.startNode = function(token, lastLineStart) {
              if (lastLineStart === void 0) {
                lastLineStart = 0;
              }
              var column = token.start - token.lineStart;
              var line = token.lineNumber;
              if (column < 0) {
                column += lastLineStart;
                line--;
              }
              return {
                index: token.start,
                line,
                column
              };
            };
            Parser2.prototype.finalize = function(marker, node) {
              if (this.config.range) {
                node.range = [marker.index, this.lastMarker.index];
              }
              if (this.config.loc) {
                node.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                };
                if (this.config.source) {
                  node.loc.source = this.config.source;
                }
              }
              if (this.delegate) {
                var metadata = {
                  start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(node, metadata);
              }
              return node;
            };
            Parser2.prototype.expect = function(value2) {
              var token = this.nextToken();
              if (token.type !== 7 || token.value !== value2) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var token = this.lookahead;
                if (token.type === 7 && token.value === ",") {
                  this.nextToken();
                } else if (token.type === 7 && token.value === ";") {
                  this.nextToken();
                  this.tolerateUnexpectedToken(token);
                } else {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                }
              } else {
                this.expect(",");
              }
            };
            Parser2.prototype.expectKeyword = function(keyword) {
              var token = this.nextToken();
              if (token.type !== 4 || token.value !== keyword) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.match = function(value2) {
              return this.lookahead.type === 7 && this.lookahead.value === value2;
            };
            Parser2.prototype.matchKeyword = function(keyword) {
              return this.lookahead.type === 4 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchContextualKeyword = function(keyword) {
              return this.lookahead.type === 3 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7) {
                return false;
              }
              var op = this.lookahead.value;
              return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            };
            Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              if (this.context.firstCoverInitializedNameError !== null) {
                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
              }
              this.context.isBindingElement = previousIsBindingElement;
              this.context.isAssignmentTarget = previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
              this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.consumeSemicolon = function() {
              if (this.match(";")) {
                this.nextToken();
              } else if (!this.hasLineTerminator) {
                if (this.lookahead.type !== 2 && !this.match("}")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.lastMarker.index = this.startMarker.index;
                this.lastMarker.line = this.startMarker.line;
                this.lastMarker.column = this.startMarker.column;
              }
            };
            Parser2.prototype.parsePrimaryExpression = function() {
              var node = this.createNode();
              var expr;
              var token, raw;
              switch (this.lookahead.type) {
                case 3:
                  if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(token.value, raw));
                  break;
                case 1:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                  break;
                case 5:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(null, raw));
                  break;
                case 10:
                  expr = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = false;
                      expr = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.scanner.index = this.startMarker.index;
                      token = this.nextRegexToken();
                      raw = this.getTokenRaw(token);
                      expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                      break;
                    default:
                      expr = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                    expr = this.parseIdentifierName();
                  } else if (!this.context.strict && this.matchKeyword("let")) {
                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                  } else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword("function")) {
                      expr = this.parseFunctionExpression();
                    } else if (this.matchKeyword("this")) {
                      this.nextToken();
                      expr = this.finalize(node, new Node.ThisExpression());
                    } else if (this.matchKeyword("class")) {
                      expr = this.parseClassExpression();
                    } else {
                      expr = this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  break;
                default:
                  expr = this.throwUnexpectedToken(this.nextToken());
              }
              return expr;
            };
            Parser2.prototype.parseSpreadElement = function() {
              var node = this.createNode();
              this.expect("...");
              var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(node, new Node.SpreadElement(arg));
            };
            Parser2.prototype.parseArrayInitializer = function() {
              var node = this.createNode();
              var elements = [];
              this.expect("[");
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else if (this.match("...")) {
                  var element = this.parseSpreadElement();
                  if (!this.match("]")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(",");
                  }
                  elements.push(element);
                } else {
                  elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayExpression(elements));
            };
            Parser2.prototype.parsePropertyMethod = function(params) {
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = params.simple;
              var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              if (this.context.strict && params.firstRestricted) {
                this.tolerateUnexpectedToken(params.firstRestricted, params.message);
              }
              if (this.context.strict && params.stricted) {
                this.tolerateUnexpectedToken(params.stricted, params.message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              return body;
            };
            Parser2.prototype.parsePropertyMethodFunction = function() {
              var isGenerator = false;
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              var previousAwait = this.context.await;
              this.context.allowYield = false;
              this.context.await = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              this.context.await = previousAwait;
              return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
            };
            Parser2.prototype.parseObjectPropertyKey = function() {
              var node = this.createNode();
              var token = this.nextToken();
              var key;
              switch (token.type) {
                case 8:
                case 6:
                  if (this.context.strict && token.octal) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                  }
                  var raw = this.getTokenRaw(token);
                  key = this.finalize(node, new Node.Literal(token.value, raw));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  key = this.finalize(node, new Node.Identifier(token.value));
                  break;
                case 7:
                  if (token.value === "[") {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect("]");
                  } else {
                    key = this.throwUnexpectedToken(token);
                  }
                  break;
                default:
                  key = this.throwUnexpectedToken(token);
              }
              return key;
            };
            Parser2.prototype.isPropertyKey = function(key, value2) {
              return key.type === syntax_1.Syntax.Identifier && key.name === value2 || key.type === syntax_1.Syntax.Literal && key.value === value2;
            };
            Parser2.prototype.parseObjectProperty = function(hasProto) {
              var node = this.createNode();
              var token = this.lookahead;
              var kind;
              var key = null;
              var value2 = null;
              var computed = false;
              var method = false;
              var shorthand = false;
              var isAsync = false;
              if (token.type === 3) {
                var id = token.value;
                this.nextToken();
                computed = this.match("[");
                isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
              } else if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value2 = this.parseGetterMethod();
              } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseSetterMethod();
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseGeneratorMethod();
                method = true;
              } else {
                if (!key) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                kind = "init";
                if (this.match(":") && !isAsync) {
                  if (!computed && this.isPropertyKey(key, "__proto__")) {
                    if (hasProto.value) {
                      this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto.value = true;
                  }
                  this.nextToken();
                  value2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                } else if (this.match("(")) {
                  value2 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                } else if (token.type === 3) {
                  var id = this.finalize(node, new Node.Identifier(token.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value2 = this.finalize(node, new Node.AssignmentPattern(id, init2));
                  } else {
                    shorthand = true;
                    value2 = id;
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.Property(kind, key, computed, value2, method, shorthand));
            };
            Parser2.prototype.parseObjectInitializer = function() {
              var node = this.createNode();
              this.expect("{");
              var properties = [];
              var hasProto = { value: false };
              while (!this.match("}")) {
                properties.push(this.parseObjectProperty(hasProto));
                if (!this.match("}")) {
                  this.expectCommaSeparator();
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectExpression(properties));
            };
            Parser2.prototype.parseTemplateHead = function() {
              assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
              var node = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateElement = function() {
              if (this.lookahead.type !== 10) {
                this.throwUnexpectedToken();
              }
              var node = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateLiteral = function() {
              var node = this.createNode();
              var expressions = [];
              var quasis = [];
              var quasi = this.parseTemplateHead();
              quasis.push(quasi);
              while (!quasi.tail) {
                expressions.push(this.parseExpression());
                quasi = this.parseTemplateElement();
                quasis.push(quasi);
              }
              return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
            };
            Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                case syntax_1.Syntax.MemberExpression:
                case syntax_1.Syntax.RestElement:
                case syntax_1.Syntax.AssignmentPattern:
                  break;
                case syntax_1.Syntax.SpreadElement:
                  expr.type = syntax_1.Syntax.RestElement;
                  this.reinterpretExpressionAsPattern(expr.argument);
                  break;
                case syntax_1.Syntax.ArrayExpression:
                  expr.type = syntax_1.Syntax.ArrayPattern;
                  for (var i = 0; i < expr.elements.length; i++) {
                    if (expr.elements[i] !== null) {
                      this.reinterpretExpressionAsPattern(expr.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectExpression:
                  expr.type = syntax_1.Syntax.ObjectPattern;
                  for (var i = 0; i < expr.properties.length; i++) {
                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
                  }
                  break;
                case syntax_1.Syntax.AssignmentExpression:
                  expr.type = syntax_1.Syntax.AssignmentPattern;
                  delete expr.operator;
                  this.reinterpretExpressionAsPattern(expr.left);
                  break;
              }
            };
            Parser2.prototype.parseGroupExpression = function() {
              var expr;
              this.expect("(");
              if (this.match(")")) {
                this.nextToken();
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [],
                  async: false
                };
              } else {
                var startToken = this.lookahead;
                var params = [];
                if (this.match("...")) {
                  expr = this.parseRestElement(params);
                  this.expect(")");
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                  };
                } else {
                  var arrow = false;
                  this.context.isBindingElement = true;
                  expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      if (this.match(")")) {
                        this.nextToken();
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else if (this.match("...")) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        expressions.push(this.parseRestElement(params));
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        this.context.isBindingElement = false;
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else {
                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      }
                      if (arrow) {
                        break;
                      }
                    }
                    if (!arrow) {
                      expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                  }
                  if (!arrow) {
                    this.expect(")");
                    if (this.match("=>")) {
                      if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      }
                      if (!arrow) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                          for (var i = 0; i < expr.expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expr.expressions[i]);
                          }
                        } else {
                          this.reinterpretExpressionAsPattern(expr);
                        }
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: false
                        };
                      }
                    }
                    this.context.isBindingElement = false;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.isIdentifierName = function(token) {
              return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
            };
            Parser2.prototype.parseIdentifierName = function() {
              var node = this.createNode();
              var token = this.nextToken();
              if (!this.isIdentifierName(token)) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseNewExpression = function() {
              var node = this.createNode();
              var id = this.parseIdentifierName();
              assert_1.assert(id.name === "new", "New expression must start with `new`");
              var expr;
              if (this.match(".")) {
                this.nextToken();
                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var property = this.parseIdentifierName();
                  expr = new Node.MetaProperty(id, property);
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                var args = this.match("(") ? this.parseArguments() : [];
                expr = new Node.NewExpression(callee, args);
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return this.finalize(node, expr);
            };
            Parser2.prototype.parseAsyncArgument = function() {
              var arg = this.parseAssignmentExpression();
              this.context.firstCoverInitializedNameError = null;
              return arg;
            };
            Parser2.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var startToken = this.lookahead;
              var maybeAsync = this.matchContextualKeyword("async");
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var expr;
              if (this.matchKeyword("super") && this.context.inFunctionBody) {
                expr = this.createNode();
                this.nextToken();
                expr = this.finalize(expr, new Node.Super());
                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              }
              while (true) {
                if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                } else if (this.match("(")) {
                  var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = false;
                  var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                  expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                  if (asyncArrow && this.match("=>")) {
                    for (var i = 0; i < args.length; ++i) {
                      this.reinterpretExpressionAsPattern(args[i]);
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: args,
                      async: true
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              this.context.allowIn = previousAllowIn;
              return expr;
            };
            Parser2.prototype.parseSuper = function() {
              var node = this.createNode();
              this.expectKeyword("super");
              if (!this.match("[") && !this.match(".")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              return this.finalize(node, new Node.Super());
            };
            Parser2.prototype.parseLeftHandSideExpression = function() {
              assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              var node = this.startNode(this.lookahead);
              var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              while (true) {
                if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                } else if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              return expr;
            };
            Parser2.prototype.parseUpdateExpression = function() {
              var expr;
              var startToken = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var node = this.startNode(startToken);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                var prefix = true;
                expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else {
                expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                  if (this.match("++") || this.match("--")) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseAwaitExpression = function() {
              var node = this.createNode();
              this.nextToken();
              var argument = this.parseUnaryExpression();
              return this.finalize(node, new Node.AwaitExpression(argument));
            };
            Parser2.prototype.parseUnaryExpression = function() {
              var expr;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                var node = this.startNode(this.lookahead);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                  this.tolerateError(messages_1.Messages.StrictDelete);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else if (this.context.await && this.matchContextualKeyword("await")) {
                expr = this.parseAwaitExpression();
              } else {
                expr = this.parseUpdateExpression();
              }
              return expr;
            };
            Parser2.prototype.parseExponentiationExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
              }
              return expr;
            };
            Parser2.prototype.binaryPrecedence = function(token) {
              var op = token.value;
              var precedence;
              if (token.type === 7) {
                precedence = this.operatorPrecedence[op] || 0;
              } else if (token.type === 4) {
                precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
              } else {
                precedence = 0;
              }
              return precedence;
            };
            Parser2.prototype.parseBinaryExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
              var token = this.lookahead;
              var prec = this.binaryPrecedence(token);
              if (prec > 0) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var markers = [startToken, this.lookahead];
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                var stack = [left, token.value, right];
                var precedences = [prec];
                while (true) {
                  prec = this.binaryPrecedence(this.lookahead);
                  if (prec <= 0) {
                    break;
                  }
                  while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                    right = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left = stack.pop();
                    markers.pop();
                    var node = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                  }
                  stack.push(this.nextToken().value);
                  precedences.push(prec);
                  markers.push(this.lookahead);
                  stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var i = stack.length - 1;
                expr = stack[i];
                var lastMarker = markers.pop();
                while (i > 1) {
                  var marker = markers.pop();
                  var lastLineStart = lastMarker && lastMarker.lineStart;
                  var node = this.startNode(marker, lastLineStart);
                  var operator = stack[i - 1];
                  expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                  i -= 2;
                  lastMarker = marker;
                }
              }
              return expr;
            };
            Parser2.prototype.parseConditionalExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                this.expect(":");
                var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return expr;
            };
            Parser2.prototype.checkPatternParam = function(options, param) {
              switch (param.type) {
                case syntax_1.Syntax.Identifier:
                  this.validateParam(options, param, param.name);
                  break;
                case syntax_1.Syntax.RestElement:
                  this.checkPatternParam(options, param.argument);
                  break;
                case syntax_1.Syntax.AssignmentPattern:
                  this.checkPatternParam(options, param.left);
                  break;
                case syntax_1.Syntax.ArrayPattern:
                  for (var i = 0; i < param.elements.length; i++) {
                    if (param.elements[i] !== null) {
                      this.checkPatternParam(options, param.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectPattern:
                  for (var i = 0; i < param.properties.length; i++) {
                    this.checkPatternParam(options, param.properties[i].value);
                  }
                  break;
              }
              options.simple = options.simple && param instanceof Node.Identifier;
            };
            Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
              var params = [expr];
              var options;
              var asyncArrow = false;
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                  break;
                case ArrowParameterPlaceHolder:
                  params = expr.params;
                  asyncArrow = expr.async;
                  break;
                default:
                  return null;
              }
              options = {
                simple: true,
                paramSet: {}
              };
              for (var i = 0; i < params.length; ++i) {
                var param = params[i];
                if (param.type === syntax_1.Syntax.AssignmentPattern) {
                  if (param.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param.right.argument) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    param.right.type = syntax_1.Syntax.Identifier;
                    param.right.name = "yield";
                    delete param.right.argument;
                    delete param.right.delegate;
                  }
                } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.checkPatternParam(options, param);
                params[i] = param;
              }
              if (this.context.strict || !this.context.allowYield) {
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  if (param.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              }
              if (options.message === messages_1.Messages.StrictParamDupe) {
                var token = this.context.strict ? options.stricted : options.firstRestricted;
                this.throwUnexpectedToken(token, options.message);
              }
              return {
                simple: options.simple,
                params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.parseAssignmentExpression = function() {
              var expr;
              if (!this.context.allowYield && this.matchKeyword("yield")) {
                expr = this.parseYieldExpression();
              } else {
                var startToken = this.lookahead;
                var token = startToken;
                expr = this.parseConditionalExpression();
                if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                  if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: true
                    };
                  }
                }
                if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var isAsync = expr.async;
                  var list = this.reinterpretAsCoverFormalsList(expr);
                  if (list) {
                    if (this.hasLineTerminator) {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node = this.startNode(startToken);
                    this.expect("=>");
                    var body = void 0;
                    if (this.match("{")) {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      body = this.parseFunctionSourceElements();
                      this.context.allowIn = previousAllowIn;
                    } else {
                      body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                      this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                      this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                  }
                } else {
                  if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                      }
                      if (this.scanner.isStrictModeReservedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      }
                    }
                    if (!this.match("=")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    token = this.nextToken();
                    var operator = token.value;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                    this.context.firstCoverInitializedNameError = null;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseExpression = function() {
              var startToken = this.lookahead;
              var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var expressions = [];
                expressions.push(expr);
                while (this.lookahead.type !== 2) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
              }
              return expr;
            };
            Parser2.prototype.parseStatementListItem = function() {
              var statement;
              this.context.isAssignmentTarget = true;
              this.context.isBindingElement = true;
              if (this.lookahead.type === 4) {
                switch (this.lookahead.value) {
                  case "export":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                  case "import":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                    }
                    statement = this.parseImportDeclaration();
                    break;
                  case "const":
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    statement = this.parseClassDeclaration();
                    break;
                  case "let":
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    statement = this.parseStatement();
                    break;
                }
              } else {
                statement = this.parseStatement();
              }
              return statement;
            };
            Parser2.prototype.parseBlock = function() {
              var node = this.createNode();
              this.expect("{");
              var block = [];
              while (true) {
                if (this.match("}")) {
                  break;
                }
                block.push(this.parseStatementListItem());
              }
              this.expect("}");
              return this.finalize(node, new Node.BlockStatement(block));
            };
            Parser2.prototype.parseLexicalBinding = function(kind, options) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, kind);
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init2 = null;
              if (kind === "const") {
                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                  if (this.match("=")) {
                    this.nextToken();
                    init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                  }
                }
              } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                this.expect("=");
                init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init2));
            };
            Parser2.prototype.parseBindingList = function(kind, options) {
              var list = [this.parseLexicalBinding(kind, options)];
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseLexicalBinding(kind, options));
              }
              return list;
            };
            Parser2.prototype.isLexicalDeclaration = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next2 = this.scanner.lex();
              this.scanner.restoreState(state);
              return next2.type === 3 || next2.type === 7 && next2.value === "[" || next2.type === 7 && next2.value === "{" || next2.type === 4 && next2.value === "let" || next2.type === 4 && next2.value === "yield";
            };
            Parser2.prototype.parseLexicalDeclaration = function(options) {
              var node = this.createNode();
              var kind = this.nextToken().value;
              assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
              var declarations = this.parseBindingList(kind, options);
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
            };
            Parser2.prototype.parseBindingRestElement = function(params, kind) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params, kind);
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseArrayPattern = function(params, kind) {
              var node = this.createNode();
              this.expect("[");
              var elements = [];
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else {
                  if (this.match("...")) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                  } else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                  }
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayPattern(elements));
            };
            Parser2.prototype.parsePropertyPattern = function(params, kind) {
              var node = this.createNode();
              var computed = false;
              var shorthand = false;
              var method = false;
              var key;
              var value2;
              if (this.lookahead.type === 3) {
                var keyToken = this.lookahead;
                key = this.parseVariableIdentifier();
                var init2 = this.finalize(node, new Node.Identifier(keyToken.value));
                if (this.match("=")) {
                  params.push(keyToken);
                  shorthand = true;
                  this.nextToken();
                  var expr = this.parseAssignmentExpression();
                  value2 = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init2, expr));
                } else if (!this.match(":")) {
                  params.push(keyToken);
                  shorthand = true;
                  value2 = init2;
                } else {
                  this.expect(":");
                  value2 = this.parsePatternWithDefault(params, kind);
                }
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.expect(":");
                value2 = this.parsePatternWithDefault(params, kind);
              }
              return this.finalize(node, new Node.Property("init", key, computed, value2, method, shorthand));
            };
            Parser2.prototype.parseObjectPattern = function(params, kind) {
              var node = this.createNode();
              var properties = [];
              this.expect("{");
              while (!this.match("}")) {
                properties.push(this.parsePropertyPattern(params, kind));
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectPattern(properties));
            };
            Parser2.prototype.parsePattern = function(params, kind) {
              var pattern2;
              if (this.match("[")) {
                pattern2 = this.parseArrayPattern(params, kind);
              } else if (this.match("{")) {
                pattern2 = this.parseObjectPattern(params, kind);
              } else {
                if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                }
                params.push(this.lookahead);
                pattern2 = this.parseVariableIdentifier(kind);
              }
              return pattern2;
            };
            Parser2.prototype.parsePatternWithDefault = function(params, kind) {
              var startToken = this.lookahead;
              var pattern2 = this.parsePattern(params, kind);
              if (this.match("=")) {
                this.nextToken();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = previousAllowYield;
                pattern2 = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern2, right));
              }
              return pattern2;
            };
            Parser2.prototype.parseVariableIdentifier = function(kind) {
              var node = this.createNode();
              var token = this.nextToken();
              if (token.type === 4 && token.value === "yield") {
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else if (!this.context.allowYield) {
                  this.throwUnexpectedToken(token);
                }
              } else if (token.type !== 3) {
                if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else {
                  if (this.context.strict || token.value !== "let" || kind !== "var") {
                    this.throwUnexpectedToken(token);
                  }
                }
              } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                this.tolerateUnexpectedToken(token);
              }
              return this.finalize(node, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseVariableDeclaration = function(options) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, "var");
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init2 = null;
              if (this.match("=")) {
                this.nextToken();
                init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                this.expect("=");
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init2));
            };
            Parser2.prototype.parseVariableDeclarationList = function(options) {
              var opt = { inFor: options.inFor };
              var list = [];
              list.push(this.parseVariableDeclaration(opt));
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseVariableDeclaration(opt));
              }
              return list;
            };
            Parser2.prototype.parseVariableStatement = function() {
              var node = this.createNode();
              this.expectKeyword("var");
              var declarations = this.parseVariableDeclarationList({ inFor: false });
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
            };
            Parser2.prototype.parseEmptyStatement = function() {
              var node = this.createNode();
              this.expect(";");
              return this.finalize(node, new Node.EmptyStatement());
            };
            Parser2.prototype.parseExpressionStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseIfClause = function() {
              if (this.context.strict && this.matchKeyword("function")) {
                this.tolerateError(messages_1.Messages.StrictFunction);
              }
              return this.parseStatement();
            };
            Parser2.prototype.parseIfStatement = function() {
              var node = this.createNode();
              var consequent;
              var alternate = null;
              this.expectKeyword("if");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                consequent = this.parseIfClause();
                if (this.matchKeyword("else")) {
                  this.nextToken();
                  alternate = this.parseIfClause();
                }
              }
              return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
            };
            Parser2.prototype.parseDoWhileStatement = function() {
              var node = this.createNode();
              this.expectKeyword("do");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              var body = this.parseStatement();
              this.context.inIteration = previousInIteration;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
              } else {
                this.expect(")");
                if (this.match(";")) {
                  this.nextToken();
                }
              }
              return this.finalize(node, new Node.DoWhileStatement(body, test));
            };
            Parser2.prototype.parseWhileStatement = function() {
              var node = this.createNode();
              var body;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.parseStatement();
                this.context.inIteration = previousInIteration;
              }
              return this.finalize(node, new Node.WhileStatement(test, body));
            };
            Parser2.prototype.parseForStatement = function() {
              var init2 = null;
              var test = null;
              var update = null;
              var forIn = true;
              var left, right;
              var node = this.createNode();
              this.expectKeyword("for");
              this.expect("(");
              if (this.match(";")) {
                this.nextToken();
              } else {
                if (this.matchKeyword("var")) {
                  init2 = this.createNode();
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseVariableDeclarationList({ inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                      this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                    }
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init2;
                    right = this.parseAssignmentExpression();
                    init2 = null;
                    forIn = false;
                  } else {
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.expect(";");
                  }
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init2 = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in") {
                    init2 = this.finalize(init2, new Node.Identifier(kind));
                    this.nextToken();
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init2;
                      right = this.parseExpression();
                      init2 = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init2;
                      right = this.parseAssignmentExpression();
                      init2 = null;
                      forIn = false;
                    } else {
                      this.consumeSemicolon();
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                    }
                  }
                } else {
                  var initStartToken = this.lookahead;
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  init2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  if (this.matchKeyword("in")) {
                    if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init2);
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else if (this.matchContextualKeyword("of")) {
                    if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init2);
                    left = init2;
                    right = this.parseAssignmentExpression();
                    init2 = null;
                    forIn = false;
                  } else {
                    if (this.match(",")) {
                      var initSeq = [init2];
                      while (this.match(",")) {
                        this.nextToken();
                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      init2 = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
              }
              if (typeof left === "undefined") {
                if (!this.match(";")) {
                  test = this.parseExpression();
                }
                this.expect(";");
                if (!this.match(")")) {
                  update = this.parseExpression();
                }
              }
              var body;
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.isolateCoverGrammar(this.parseStatement);
                this.context.inIteration = previousInIteration;
              }
              return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init2, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
            };
            Parser2.prototype.parseContinueStatement = function() {
              var node = this.createNode();
              this.expectKeyword("continue");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                label = id;
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration) {
                this.throwError(messages_1.Messages.IllegalContinue);
              }
              return this.finalize(node, new Node.ContinueStatement(label));
            };
            Parser2.prototype.parseBreakStatement = function() {
              var node = this.createNode();
              this.expectKeyword("break");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                label = id;
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                this.throwError(messages_1.Messages.IllegalBreak);
              }
              return this.finalize(node, new Node.BreakStatement(label));
            };
            Parser2.prototype.parseReturnStatement = function() {
              if (!this.context.inFunctionBody) {
                this.tolerateError(messages_1.Messages.IllegalReturn);
              }
              var node = this.createNode();
              this.expectKeyword("return");
              var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
              var argument = hasArgument ? this.parseExpression() : null;
              this.consumeSemicolon();
              return this.finalize(node, new Node.ReturnStatement(argument));
            };
            Parser2.prototype.parseWithStatement = function() {
              if (this.context.strict) {
                this.tolerateError(messages_1.Messages.StrictModeWith);
              }
              var node = this.createNode();
              var body;
              this.expectKeyword("with");
              this.expect("(");
              var object = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                body = this.parseStatement();
              }
              return this.finalize(node, new Node.WithStatement(object, body));
            };
            Parser2.prototype.parseSwitchCase = function() {
              var node = this.createNode();
              var test;
              if (this.matchKeyword("default")) {
                this.nextToken();
                test = null;
              } else {
                this.expectKeyword("case");
                test = this.parseExpression();
              }
              this.expect(":");
              var consequent = [];
              while (true) {
                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                  break;
                }
                consequent.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.SwitchCase(test, consequent));
            };
            Parser2.prototype.parseSwitchStatement = function() {
              var node = this.createNode();
              this.expectKeyword("switch");
              this.expect("(");
              var discriminant = this.parseExpression();
              this.expect(")");
              var previousInSwitch = this.context.inSwitch;
              this.context.inSwitch = true;
              var cases = [];
              var defaultFound = false;
              this.expect("{");
              while (true) {
                if (this.match("}")) {
                  break;
                }
                var clause = this.parseSwitchCase();
                if (clause.test === null) {
                  if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                  }
                  defaultFound = true;
                }
                cases.push(clause);
              }
              this.expect("}");
              this.context.inSwitch = previousInSwitch;
              return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
            };
            Parser2.prototype.parseLabelledStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              var statement;
              if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var id = expr;
                var key = "$" + id.name;
                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                }
                this.context.labelSet[key] = true;
                var body = void 0;
                if (this.matchKeyword("class")) {
                  this.tolerateUnexpectedToken(this.lookahead);
                  body = this.parseClassDeclaration();
                } else if (this.matchKeyword("function")) {
                  var token = this.lookahead;
                  var declaration = this.parseFunctionDeclaration();
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                  } else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                  }
                  body = declaration;
                } else {
                  body = this.parseStatement();
                }
                delete this.context.labelSet[key];
                statement = new Node.LabeledStatement(id, body);
              } else {
                this.consumeSemicolon();
                statement = new Node.ExpressionStatement(expr);
              }
              return this.finalize(node, statement);
            };
            Parser2.prototype.parseThrowStatement = function() {
              var node = this.createNode();
              this.expectKeyword("throw");
              if (this.hasLineTerminator) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
              }
              var argument = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ThrowStatement(argument));
            };
            Parser2.prototype.parseCatchClause = function() {
              var node = this.createNode();
              this.expectKeyword("catch");
              this.expect("(");
              if (this.match(")")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              var params = [];
              var param = this.parsePattern(params);
              var paramMap = {};
              for (var i = 0; i < params.length; i++) {
                var key = "$" + params[i].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                  this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                }
                paramMap[key] = true;
              }
              if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(param.name)) {
                  this.tolerateError(messages_1.Messages.StrictCatchVariable);
                }
              }
              this.expect(")");
              var body = this.parseBlock();
              return this.finalize(node, new Node.CatchClause(param, body));
            };
            Parser2.prototype.parseFinallyClause = function() {
              this.expectKeyword("finally");
              return this.parseBlock();
            };
            Parser2.prototype.parseTryStatement = function() {
              var node = this.createNode();
              this.expectKeyword("try");
              var block = this.parseBlock();
              var handler2 = this.matchKeyword("catch") ? this.parseCatchClause() : null;
              var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
              if (!handler2 && !finalizer) {
                this.throwError(messages_1.Messages.NoCatchOrFinally);
              }
              return this.finalize(node, new Node.TryStatement(block, handler2, finalizer));
            };
            Parser2.prototype.parseDebuggerStatement = function() {
              var node = this.createNode();
              this.expectKeyword("debugger");
              this.consumeSemicolon();
              return this.finalize(node, new Node.DebuggerStatement());
            };
            Parser2.prototype.parseStatement = function() {
              var statement;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  statement = this.parseExpressionStatement();
                  break;
                case 7:
                  var value2 = this.lookahead.value;
                  if (value2 === "{") {
                    statement = this.parseBlock();
                  } else if (value2 === "(") {
                    statement = this.parseExpressionStatement();
                  } else if (value2 === ";") {
                    statement = this.parseEmptyStatement();
                  } else {
                    statement = this.parseExpressionStatement();
                  }
                  break;
                case 3:
                  statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      statement = this.parseBreakStatement();
                      break;
                    case "continue":
                      statement = this.parseContinueStatement();
                      break;
                    case "debugger":
                      statement = this.parseDebuggerStatement();
                      break;
                    case "do":
                      statement = this.parseDoWhileStatement();
                      break;
                    case "for":
                      statement = this.parseForStatement();
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      statement = this.parseIfStatement();
                      break;
                    case "return":
                      statement = this.parseReturnStatement();
                      break;
                    case "switch":
                      statement = this.parseSwitchStatement();
                      break;
                    case "throw":
                      statement = this.parseThrowStatement();
                      break;
                    case "try":
                      statement = this.parseTryStatement();
                      break;
                    case "var":
                      statement = this.parseVariableStatement();
                      break;
                    case "while":
                      statement = this.parseWhileStatement();
                      break;
                    case "with":
                      statement = this.parseWithStatement();
                      break;
                    default:
                      statement = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  statement = this.throwUnexpectedToken(this.lookahead);
              }
              return statement;
            };
            Parser2.prototype.parseFunctionSourceElements = function() {
              var node = this.createNode();
              this.expect("{");
              var body = this.parseDirectivePrologues();
              var previousLabelSet = this.context.labelSet;
              var previousInIteration = this.context.inIteration;
              var previousInSwitch = this.context.inSwitch;
              var previousInFunctionBody = this.context.inFunctionBody;
              this.context.labelSet = {};
              this.context.inIteration = false;
              this.context.inSwitch = false;
              this.context.inFunctionBody = true;
              while (this.lookahead.type !== 2) {
                if (this.match("}")) {
                  break;
                }
                body.push(this.parseStatementListItem());
              }
              this.expect("}");
              this.context.labelSet = previousLabelSet;
              this.context.inIteration = previousInIteration;
              this.context.inSwitch = previousInSwitch;
              this.context.inFunctionBody = previousInFunctionBody;
              return this.finalize(node, new Node.BlockStatement(body));
            };
            Parser2.prototype.validateParam = function(options, param, name) {
              var key = "$" + name;
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(name)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              } else if (!options.firstRestricted) {
                if (this.scanner.isRestrictedWord(name)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                } else if (this.scanner.isStrictModeReservedWord(name)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
              } else {
                options.paramSet[key] = true;
              }
            };
            Parser2.prototype.parseRestElement = function(params) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params);
              if (this.match("=")) {
                this.throwError(messages_1.Messages.DefaultRestParameter);
              }
              if (!this.match(")")) {
                this.throwError(messages_1.Messages.ParameterAfterRestParameter);
              }
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseFormalParameter = function(options) {
              var params = [];
              var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
              for (var i = 0; i < params.length; i++) {
                this.validateParam(options, params[i], params[i].value);
              }
              options.simple = options.simple && param instanceof Node.Identifier;
              options.params.push(param);
            };
            Parser2.prototype.parseFormalParameters = function(firstRestricted) {
              var options;
              options = {
                simple: true,
                params: [],
                firstRestricted
              };
              this.expect("(");
              if (!this.match(")")) {
                options.paramSet = {};
                while (this.lookahead.type !== 2) {
                  this.parseFormalParameter(options);
                  if (this.match(")")) {
                    break;
                  }
                  this.expect(",");
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return {
                simple: options.simple,
                params: options.params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.matchAsyncFunction = function() {
              var match = this.matchContextualKeyword("async");
              if (match) {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next2 = this.scanner.lex();
                this.scanner.restoreState(state);
                match = state.lineNumber === next2.lineNumber && next2.type === 4 && next2.value === "function";
              }
              return match;
            };
            Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted = null;
              if (!identifierIsOptional || !this.match("(")) {
                var token = this.lookahead;
                id = this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
            };
            Parser2.prototype.parseFunctionExpression = function() {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted;
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              if (!this.match("(")) {
                var token = this.lookahead;
                id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
            };
            Parser2.prototype.parseDirective = function() {
              var token = this.lookahead;
              var node = this.createNode();
              var expr = this.parseExpression();
              var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
              this.consumeSemicolon();
              return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseDirectivePrologues = function() {
              var firstRestricted = null;
              var body = [];
              while (true) {
                var token = this.lookahead;
                if (token.type !== 8) {
                  break;
                }
                var statement = this.parseDirective();
                body.push(statement);
                var directive = statement.directive;
                if (typeof directive !== "string") {
                  break;
                }
                if (directive === "use strict") {
                  this.context.strict = true;
                  if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                  }
                  if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                  }
                } else {
                  if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                  }
                }
              }
              return body;
            };
            Parser2.prototype.qualifiedPropertyName = function(token) {
              switch (token.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return true;
                case 7:
                  return token.value === "[";
              }
              return false;
            };
            Parser2.prototype.parseGetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length > 0) {
                this.tolerateError(messages_1.Messages.BadGetterArity);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseSetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length !== 1) {
                this.tolerateError(messages_1.Messages.BadSetterArity);
              } else if (formalParameters.params[0] instanceof Node.RestElement) {
                this.tolerateError(messages_1.Messages.BadSetterRestParameter);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseGeneratorMethod = function() {
              var node = this.createNode();
              var isGenerator = true;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              this.context.allowYield = false;
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.isStartOfExpression = function() {
              var start = true;
              var value2 = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  start = value2 === "[" || value2 === "(" || value2 === "{" || value2 === "+" || value2 === "-" || value2 === "!" || value2 === "~" || value2 === "++" || value2 === "--" || value2 === "/" || value2 === "/=";
                  break;
                case 4:
                  start = value2 === "class" || value2 === "delete" || value2 === "function" || value2 === "let" || value2 === "new" || value2 === "super" || value2 === "this" || value2 === "typeof" || value2 === "void" || value2 === "yield";
                  break;
              }
              return start;
            };
            Parser2.prototype.parseYieldExpression = function() {
              var node = this.createNode();
              this.expectKeyword("yield");
              var argument = null;
              var delegate = false;
              if (!this.hasLineTerminator) {
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = false;
                delegate = this.match("*");
                if (delegate) {
                  this.nextToken();
                  argument = this.parseAssignmentExpression();
                } else if (this.isStartOfExpression()) {
                  argument = this.parseAssignmentExpression();
                }
                this.context.allowYield = previousAllowYield;
              }
              return this.finalize(node, new Node.YieldExpression(argument, delegate));
            };
            Parser2.prototype.parseClassElement = function(hasConstructor) {
              var token = this.lookahead;
              var node = this.createNode();
              var kind = "";
              var key = null;
              var value2 = null;
              var computed = false;
              var method = false;
              var isStatic = false;
              var isAsync = false;
              if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                var id = key;
                if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                  token = this.lookahead;
                  isStatic = true;
                  computed = this.match("[");
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    key = this.parseObjectPropertyKey();
                  }
                }
                if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                  var punctuator = this.lookahead.value;
                  if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                    isAsync = true;
                    token = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token.type === 3 && token.value === "constructor") {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                    }
                  }
                }
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3) {
                if (token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value2 = this.parseGetterMethod();
                } else if (token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value2 = this.parseSetterMethod();
                }
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseGeneratorMethod();
                method = true;
              }
              if (!kind && key && this.match("(")) {
                kind = "init";
                value2 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              }
              if (!kind) {
                this.throwUnexpectedToken(this.lookahead);
              }
              if (kind === "init") {
                kind = "method";
              }
              if (!computed) {
                if (isStatic && this.isPropertyKey(key, "prototype")) {
                  this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                }
                if (!isStatic && this.isPropertyKey(key, "constructor")) {
                  if (kind !== "method" || !method || value2 && value2.generator) {
                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                  }
                  if (hasConstructor.value) {
                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                  } else {
                    hasConstructor.value = true;
                  }
                  kind = "constructor";
                }
              }
              return this.finalize(node, new Node.MethodDefinition(key, computed, value2, kind, isStatic));
            };
            Parser2.prototype.parseClassElementList = function() {
              var body = [];
              var hasConstructor = { value: false };
              this.expect("{");
              while (!this.match("}")) {
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  body.push(this.parseClassElement(hasConstructor));
                }
              }
              this.expect("}");
              return body;
            };
            Parser2.prototype.parseClassBody = function() {
              var node = this.createNode();
              var elementList = this.parseClassElementList();
              return this.finalize(node, new Node.ClassBody(elementList));
            };
            Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
            };
            Parser2.prototype.parseClassExpression = function() {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
            };
            Parser2.prototype.parseModule = function() {
              this.context.strict = true;
              this.context.isModule = true;
              this.scanner.isModule = true;
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Module(body));
            };
            Parser2.prototype.parseScript = function() {
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Script(body));
            };
            Parser2.prototype.parseModuleSpecifier = function() {
              var node = this.createNode();
              if (this.lookahead.type !== 8) {
                this.throwError(messages_1.Messages.InvalidModuleSpecifier);
              }
              var token = this.nextToken();
              var raw = this.getTokenRaw(token);
              return this.finalize(node, new Node.Literal(token.value, raw));
            };
            Parser2.prototype.parseImportSpecifier = function() {
              var node = this.createNode();
              var imported;
              var local;
              if (this.lookahead.type === 3) {
                imported = this.parseVariableIdentifier();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                }
              } else {
                imported = this.parseIdentifierName();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.ImportSpecifier(local, imported));
            };
            Parser2.prototype.parseNamedImports = function() {
              this.expect("{");
              var specifiers = [];
              while (!this.match("}")) {
                specifiers.push(this.parseImportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return specifiers;
            };
            Parser2.prototype.parseImportDefaultSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportDefaultSpecifier(local));
            };
            Parser2.prototype.parseImportNamespaceSpecifier = function() {
              var node = this.createNode();
              this.expect("*");
              if (!this.matchContextualKeyword("as")) {
                this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
              }
              this.nextToken();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
            };
            Parser2.prototype.parseImportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalImportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("import");
              var src2;
              var specifiers = [];
              if (this.lookahead.type === 8) {
                src2 = this.parseModuleSpecifier();
              } else {
                if (this.match("{")) {
                  specifiers = specifiers.concat(this.parseNamedImports());
                } else if (this.match("*")) {
                  specifiers.push(this.parseImportNamespaceSpecifier());
                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                  specifiers.push(this.parseImportDefaultSpecifier());
                  if (this.match(",")) {
                    this.nextToken();
                    if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                src2 = this.parseModuleSpecifier();
              }
              this.consumeSemicolon();
              return this.finalize(node, new Node.ImportDeclaration(specifiers, src2));
            };
            Parser2.prototype.parseExportSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              var exported = local;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                exported = this.parseIdentifierName();
              }
              return this.finalize(node, new Node.ExportSpecifier(local, exported));
            };
            Parser2.prototype.parseExportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalExportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("export");
              var exportDeclaration;
              if (this.matchKeyword("default")) {
                this.nextToken();
                if (this.matchKeyword("function")) {
                  var declaration = this.parseFunctionDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchKeyword("class")) {
                  var declaration = this.parseClassDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchContextualKeyword("async")) {
                  var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else {
                  if (this.matchContextualKeyword("from")) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                  }
                  var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                }
              } else if (this.match("*")) {
                this.nextToken();
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                var src2 = this.parseModuleSpecifier();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src2));
              } else if (this.lookahead.type === 4) {
                var declaration = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    declaration = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else if (this.matchAsyncFunction()) {
                var declaration = this.parseFunctionDeclaration();
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else {
                var specifiers = [];
                var source = null;
                var isExportFromIdentifier = false;
                this.expect("{");
                while (!this.match("}")) {
                  isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                  specifiers.push(this.parseExportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                if (this.matchContextualKeyword("from")) {
                  this.nextToken();
                  source = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                } else if (isExportFromIdentifier) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                } else {
                  this.consumeSemicolon();
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
              }
              return exportDeclaration;
            };
            return Parser2;
          }();
          exports2.Parser = Parser;
        },
        /* 9 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          function assert(condition, message) {
            if (!condition) {
              throw new Error("ASSERT: " + message);
            }
          }
          exports2.assert = assert;
        },
        /* 10 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var ErrorHandler = function() {
            function ErrorHandler2() {
              this.errors = [];
              this.tolerant = false;
            }
            ErrorHandler2.prototype.recordError = function(error) {
              this.errors.push(error);
            };
            ErrorHandler2.prototype.tolerate = function(error) {
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            ErrorHandler2.prototype.constructError = function(msg2, column) {
              var error = new Error(msg2);
              try {
                throw error;
              } catch (base) {
                if (Object.create && Object.defineProperty) {
                  error = Object.create(base);
                  Object.defineProperty(error, "column", { value: column });
                }
              }
              return error;
            };
            ErrorHandler2.prototype.createError = function(index2, line, col, description) {
              var msg2 = "Line " + line + ": " + description;
              var error = this.constructError(msg2, col);
              error.index = index2;
              error.lineNumber = line;
              error.description = description;
              return error;
            };
            ErrorHandler2.prototype.throwError = function(index2, line, col, description) {
              throw this.createError(index2, line, col, description);
            };
            ErrorHandler2.prototype.tolerateError = function(index2, line, col, description) {
              var error = this.createError(index2, line, col, description);
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            return ErrorHandler2;
          }();
          exports2.ErrorHandler = ErrorHandler;
        },
        /* 11 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        /* 12 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var character_1 = __webpack_require__(4);
          var messages_1 = __webpack_require__(11);
          function hexValue(ch) {
            return "0123456789abcdef".indexOf(ch.toLowerCase());
          }
          function octalValue(ch) {
            return "01234567".indexOf(ch);
          }
          var Scanner = function() {
            function Scanner2(code, handler2) {
              this.source = code;
              this.errorHandler = handler2;
              this.trackComment = false;
              this.isModule = false;
              this.length = code.length;
              this.index = 0;
              this.lineNumber = code.length > 0 ? 1 : 0;
              this.lineStart = 0;
              this.curlyStack = [];
            }
            Scanner2.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            };
            Scanner2.prototype.restoreState = function(state) {
              this.index = state.index;
              this.lineNumber = state.lineNumber;
              this.lineStart = state.lineStart;
            };
            Scanner2.prototype.eof = function() {
              return this.index >= this.length;
            };
            Scanner2.prototype.throwUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.tolerateUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.skipSingleLineComment = function(offset) {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - offset;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                ++this.index;
                if (character_1.Character.isLineTerminator(ch)) {
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var entry = {
                      multiLine: false,
                      slice: [start + offset, this.index - 1],
                      range: [start, this.index - 1],
                      loc
                    };
                    comments.push(entry);
                  }
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  return comments;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              return comments;
            };
            Scanner2.prototype.skipMultiLineComment = function() {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - 2;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isLineTerminator(ch)) {
                  if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  ++this.index;
                  this.lineStart = this.index;
                } else if (ch === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    this.index += 2;
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index - 2],
                        range: [start, this.index],
                        loc
                      };
                      comments.push(entry);
                    }
                    return comments;
                  }
                  ++this.index;
                } else {
                  ++this.index;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: true,
                  slice: [start + 2, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              this.tolerateUnexpectedToken();
              return comments;
            };
            Scanner2.prototype.scanComments = function() {
              var comments;
              if (this.trackComment) {
                comments = [];
              }
              var start = this.index === 0;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isWhiteSpace(ch)) {
                  ++this.index;
                } else if (character_1.Character.isLineTerminator(ch)) {
                  ++this.index;
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  start = true;
                } else if (ch === 47) {
                  ch = this.source.charCodeAt(this.index + 1);
                  if (ch === 47) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                    start = true;
                  } else if (ch === 42) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (start && ch === 45) {
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (ch === 60 && !this.isModule) {
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              return comments;
            };
            Scanner2.prototype.isFutureReservedWord = function(id) {
              switch (id) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isStrictModeReservedWord = function(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isRestrictedWord = function(id) {
              return id === "eval" || id === "arguments";
            };
            Scanner2.prototype.isKeyword = function(id) {
              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";
                case 3:
                  return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                case 4:
                  return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                case 5:
                  return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                case 6:
                  return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                case 7:
                  return id === "default" || id === "finally" || id === "extends";
                case 8:
                  return id === "function" || id === "continue" || id === "debugger";
                case 10:
                  return id === "instanceof";
                default:
                  return false;
              }
            };
            Scanner2.prototype.codePointAt = function(i) {
              var cp = this.source.charCodeAt(i);
              if (cp >= 55296 && cp <= 56319) {
                var second = this.source.charCodeAt(i + 1);
                if (second >= 56320 && second <= 57343) {
                  var first = cp;
                  cp = (first - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return cp;
            };
            Scanner2.prototype.scanHexEscape = function(prefix) {
              var len = prefix === "u" ? 4 : 2;
              var code = 0;
              for (var i = 0; i < len; ++i) {
                if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  code = code * 16 + hexValue(this.source[this.index++]);
                } else {
                  return null;
                }
              }
              return String.fromCharCode(code);
            };
            Scanner2.prototype.scanUnicodeCodePointEscape = function() {
              var ch = this.source[this.index];
              var code = 0;
              if (ch === "}") {
                this.throwUnexpectedToken();
              }
              while (!this.eof()) {
                ch = this.source[this.index++];
                if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                  break;
                }
                code = code * 16 + hexValue(ch);
              }
              if (code > 1114111 || ch !== "}") {
                this.throwUnexpectedToken();
              }
              return character_1.Character.fromCodePoint(code);
            };
            Scanner2.prototype.getIdentifier = function() {
              var start = this.index++;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (ch === 92) {
                  this.index = start;
                  return this.getComplexIdentifier();
                } else if (ch >= 55296 && ch < 57343) {
                  this.index = start;
                  return this.getComplexIdentifier();
                }
                if (character_1.Character.isIdentifierPart(ch)) {
                  ++this.index;
                } else {
                  break;
                }
              }
              return this.source.slice(start, this.index);
            };
            Scanner2.prototype.getComplexIdentifier = function() {
              var cp = this.codePointAt(this.index);
              var id = character_1.Character.fromCodePoint(cp);
              this.index += id.length;
              var ch;
              if (cp === 92) {
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id = ch;
              }
              while (!this.eof()) {
                cp = this.codePointAt(this.index);
                if (!character_1.Character.isIdentifierPart(cp)) {
                  break;
                }
                ch = character_1.Character.fromCodePoint(cp);
                id += ch;
                this.index += ch.length;
                if (cp === 92) {
                  id = id.substr(0, id.length - 1);
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id += ch;
                }
              }
              return id;
            };
            Scanner2.prototype.octalToDecimal = function(ch) {
              var octal = ch !== "0";
              var code = octalValue(ch);
              if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                octal = true;
                code = code * 8 + octalValue(this.source[this.index++]);
                if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  code = code * 8 + octalValue(this.source[this.index++]);
                }
              }
              return {
                code,
                octal
              };
            };
            Scanner2.prototype.scanIdentifier = function() {
              var type2;
              var start = this.index;
              var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (id.length === 1) {
                type2 = 3;
              } else if (this.isKeyword(id)) {
                type2 = 4;
              } else if (id === "null") {
                type2 = 5;
              } else if (id === "true" || id === "false") {
                type2 = 1;
              } else {
                type2 = 3;
              }
              if (type2 !== 3 && start + id.length !== this.index) {
                var restore = this.index;
                this.index = start;
                this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                this.index = restore;
              }
              return {
                type: type2,
                value: id,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanPunctuator = function() {
              var start = this.index;
              var str2 = this.source[this.index];
              switch (str2) {
                case "(":
                case "{":
                  if (str2 === "{") {
                    this.curlyStack.push("{");
                  }
                  ++this.index;
                  break;
                case ".":
                  ++this.index;
                  if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                    this.index += 2;
                    str2 = "...";
                  }
                  break;
                case "}":
                  ++this.index;
                  this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  str2 = this.source.substr(this.index, 4);
                  if (str2 === ">>>=") {
                    this.index += 4;
                  } else {
                    str2 = str2.substr(0, 3);
                    if (str2 === "===" || str2 === "!==" || str2 === ">>>" || str2 === "<<=" || str2 === ">>=" || str2 === "**=") {
                      this.index += 3;
                    } else {
                      str2 = str2.substr(0, 2);
                      if (str2 === "&&" || str2 === "||" || str2 === "==" || str2 === "!=" || str2 === "+=" || str2 === "-=" || str2 === "*=" || str2 === "/=" || str2 === "++" || str2 === "--" || str2 === "<<" || str2 === ">>" || str2 === "&=" || str2 === "|=" || str2 === "^=" || str2 === "%=" || str2 === "<=" || str2 === ">=" || str2 === "=>" || str2 === "**") {
                        this.index += 2;
                      } else {
                        str2 = this.source[this.index];
                        if ("<>=!+-*%&|^/".indexOf(str2) >= 0) {
                          ++this.index;
                        }
                      }
                    }
                  }
              }
              if (this.index === start) {
                this.throwUnexpectedToken();
              }
              return {
                type: 7,
                value: str2,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanHexLiteral = function(start) {
              var num2 = "";
              while (!this.eof()) {
                if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num2 += this.source[this.index++];
              }
              if (num2.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt("0x" + num2, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanBinaryLiteral = function(start) {
              var num2 = "";
              var ch;
              while (!this.eof()) {
                ch = this.source[this.index];
                if (ch !== "0" && ch !== "1") {
                  break;
                }
                num2 += this.source[this.index++];
              }
              if (num2.length === 0) {
                this.throwUnexpectedToken();
              }
              if (!this.eof()) {
                ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                  this.throwUnexpectedToken();
                }
              }
              return {
                type: 6,
                value: parseInt(num2, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
              var num2 = "";
              var octal = false;
              if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                octal = true;
                num2 = "0" + this.source[this.index++];
              } else {
                ++this.index;
              }
              while (!this.eof()) {
                if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num2 += this.source[this.index++];
              }
              if (!octal && num2.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt(num2, 8),
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.isImplicitOctalLiteral = function() {
              for (var i = this.index + 1; i < this.length; ++i) {
                var ch = this.source[i];
                if (ch === "8" || ch === "9") {
                  return false;
                }
                if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  return true;
                }
              }
              return true;
            };
            Scanner2.prototype.scanNumericLiteral = function() {
              var start = this.index;
              var ch = this.source[start];
              assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
              var num2 = "";
              if (ch !== ".") {
                num2 = this.source[this.index++];
                ch = this.source[this.index];
                if (num2 === "0") {
                  if (ch === "x" || ch === "X") {
                    ++this.index;
                    return this.scanHexLiteral(start);
                  }
                  if (ch === "b" || ch === "B") {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                  }
                  if (ch === "o" || ch === "O") {
                    return this.scanOctalLiteral(ch, start);
                  }
                  if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                      return this.scanOctalLiteral(ch, start);
                    }
                  }
                }
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num2 += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === ".") {
                num2 += this.source[this.index++];
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num2 += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === "e" || ch === "E") {
                num2 += this.source[this.index++];
                ch = this.source[this.index];
                if (ch === "+" || ch === "-") {
                  num2 += this.source[this.index++];
                }
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num2 += this.source[this.index++];
                  }
                } else {
                  this.throwUnexpectedToken();
                }
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseFloat(num2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanStringLiteral = function() {
              var start = this.index;
              var quote2 = this.source[start];
              assert_1.assert(quote2 === "'" || quote2 === '"', "String literal must starts with a quote");
              ++this.index;
              var octal = false;
              var str2 = "";
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === quote2) {
                  quote2 = "";
                  break;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          str2 += this.scanUnicodeCodePointEscape();
                        } else {
                          var unescaped_1 = this.scanHexEscape(ch);
                          if (unescaped_1 === null) {
                            this.throwUnexpectedToken();
                          }
                          str2 += unescaped_1;
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        str2 += unescaped;
                        break;
                      case "n":
                        str2 += "\n";
                        break;
                      case "r":
                        str2 += "\r";
                        break;
                      case "t":
                        str2 += "	";
                        break;
                      case "b":
                        str2 += "\b";
                        break;
                      case "f":
                        str2 += "\f";
                        break;
                      case "v":
                        str2 += "\v";
                        break;
                      case "8":
                      case "9":
                        str2 += ch;
                        this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          var octToDec = this.octalToDecimal(ch);
                          octal = octToDec.octal || octal;
                          str2 += String.fromCharCode(octToDec.code);
                        } else {
                          str2 += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  break;
                } else {
                  str2 += ch;
                }
              }
              if (quote2 !== "") {
                this.index = start;
                this.throwUnexpectedToken();
              }
              return {
                type: 8,
                value: str2,
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanTemplate = function() {
              var cooked = "";
              var terminated = false;
              var start = this.index;
              var head = this.source[start] === "`";
              var tail = false;
              var rawOffset = 2;
              ++this.index;
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === "`") {
                  rawOffset = 1;
                  tail = true;
                  terminated = true;
                  break;
                } else if (ch === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${");
                    ++this.index;
                    terminated = true;
                    break;
                  }
                  cooked += ch;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "n":
                        cooked += "\n";
                        break;
                      case "r":
                        cooked += "\r";
                        break;
                      case "t":
                        cooked += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          cooked += this.scanUnicodeCodePointEscape();
                        } else {
                          var restore = this.index;
                          var unescaped_2 = this.scanHexEscape(ch);
                          if (unescaped_2 !== null) {
                            cooked += unescaped_2;
                          } else {
                            this.index = restore;
                            cooked += ch;
                          }
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        cooked += unescaped;
                        break;
                      case "b":
                        cooked += "\b";
                        break;
                      case "f":
                        cooked += "\f";
                        break;
                      case "v":
                        cooked += "\v";
                        break;
                      default:
                        if (ch === "0") {
                          if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          }
                          cooked += "\0";
                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        } else {
                          cooked += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                  cooked += "\n";
                } else {
                  cooked += ch;
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken();
              }
              if (!head) {
                this.curlyStack.pop();
              }
              return {
                type: 10,
                value: this.source.slice(start + 1, this.index - rawOffset),
                cooked,
                head,
                tail,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.testRegExp = function(pattern2, flags) {
              var astralSubstitute = "";
              var tmp = pattern2;
              var self2 = this;
              if (flags.indexOf("u") >= 0) {
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  if (codePoint > 1114111) {
                    self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  if (codePoint <= 65535) {
                    return String.fromCharCode(codePoint);
                  }
                  return astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
              }
              try {
                RegExp(tmp);
              } catch (e) {
                this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(pattern2, flags);
              } catch (exception2) {
                return null;
              }
            };
            Scanner2.prototype.scanRegExpBody = function() {
              var ch = this.source[this.index];
              assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
              var str2 = this.source[this.index++];
              var classMarker = false;
              var terminated = false;
              while (!this.eof()) {
                ch = this.source[this.index++];
                str2 += ch;
                if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  str2 += ch;
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                } else if (classMarker) {
                  if (ch === "]") {
                    classMarker = false;
                  }
                } else {
                  if (ch === "/") {
                    terminated = true;
                    break;
                  } else if (ch === "[") {
                    classMarker = true;
                  }
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              return str2.substr(1, str2.length - 2);
            };
            Scanner2.prototype.scanRegExpFlags = function() {
              var str2 = "";
              var flags = "";
              while (!this.eof()) {
                var ch = this.source[this.index];
                if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                  break;
                }
                ++this.index;
                if (ch === "\\" && !this.eof()) {
                  ch = this.source[this.index];
                  if (ch === "u") {
                    ++this.index;
                    var restore = this.index;
                    var char = this.scanHexEscape("u");
                    if (char !== null) {
                      flags += char;
                      for (str2 += "\\u"; restore < this.index; ++restore) {
                        str2 += this.source[restore];
                      }
                    } else {
                      this.index = restore;
                      flags += "u";
                      str2 += "\\u";
                    }
                    this.tolerateUnexpectedToken();
                  } else {
                    str2 += "\\";
                    this.tolerateUnexpectedToken();
                  }
                } else {
                  flags += ch;
                  str2 += ch;
                }
              }
              return flags;
            };
            Scanner2.prototype.scanRegExp = function() {
              var start = this.index;
              var pattern2 = this.scanRegExpBody();
              var flags = this.scanRegExpFlags();
              var value2 = this.testRegExp(pattern2, flags);
              return {
                type: 9,
                value: "",
                pattern: pattern2,
                flags,
                regex: value2,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.lex = function() {
              if (this.eof()) {
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              }
              var cp = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(cp)) {
                return this.scanIdentifier();
              }
              if (cp === 40 || cp === 41 || cp === 59) {
                return this.scanPunctuator();
              }
              if (cp === 39 || cp === 34) {
                return this.scanStringLiteral();
              }
              if (cp === 46) {
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                  return this.scanNumericLiteral();
                }
                return this.scanPunctuator();
              }
              if (character_1.Character.isDecimalDigit(cp)) {
                return this.scanNumericLiteral();
              }
              if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                return this.scanTemplate();
              }
              if (cp >= 55296 && cp < 57343) {
                if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                  return this.scanIdentifier();
                }
              }
              return this.scanPunctuator();
            };
            return Scanner2;
          }();
          exports2.Scanner = Scanner;
        },
        /* 13 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TokenName = {};
          exports2.TokenName[
            1
            /* BooleanLiteral */
          ] = "Boolean";
          exports2.TokenName[
            2
            /* EOF */
          ] = "<end>";
          exports2.TokenName[
            3
            /* Identifier */
          ] = "Identifier";
          exports2.TokenName[
            4
            /* Keyword */
          ] = "Keyword";
          exports2.TokenName[
            5
            /* NullLiteral */
          ] = "Null";
          exports2.TokenName[
            6
            /* NumericLiteral */
          ] = "Numeric";
          exports2.TokenName[
            7
            /* Punctuator */
          ] = "Punctuator";
          exports2.TokenName[
            8
            /* StringLiteral */
          ] = "String";
          exports2.TokenName[
            9
            /* RegularExpression */
          ] = "RegularExpression";
          exports2.TokenName[
            10
            /* Template */
          ] = "Template";
        },
        /* 14 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "",
            iexcl: "",
            cent: "",
            pound: "",
            curren: "",
            yen: "",
            brvbar: "",
            sect: "",
            uml: "",
            copy: "",
            ordf: "",
            laquo: "",
            not: "",
            shy: "",
            reg: "",
            macr: "",
            deg: "",
            plusmn: "",
            sup2: "",
            sup3: "",
            acute: "",
            micro: "",
            para: "",
            middot: "",
            cedil: "",
            sup1: "",
            ordm: "",
            raquo: "",
            frac14: "",
            frac12: "",
            frac34: "",
            iquest: "",
            Agrave: "",
            Aacute: "",
            Acirc: "",
            Atilde: "",
            Auml: "",
            Aring: "",
            AElig: "",
            Ccedil: "",
            Egrave: "",
            Eacute: "",
            Ecirc: "",
            Euml: "",
            Igrave: "",
            Iacute: "",
            Icirc: "",
            Iuml: "",
            ETH: "",
            Ntilde: "",
            Ograve: "",
            Oacute: "",
            Ocirc: "",
            Otilde: "",
            Ouml: "",
            times: "",
            Oslash: "",
            Ugrave: "",
            Uacute: "",
            Ucirc: "",
            Uuml: "",
            Yacute: "",
            THORN: "",
            szlig: "",
            agrave: "",
            aacute: "",
            acirc: "",
            atilde: "",
            auml: "",
            aring: "",
            aelig: "",
            ccedil: "",
            egrave: "",
            eacute: "",
            ecirc: "",
            euml: "",
            igrave: "",
            iacute: "",
            icirc: "",
            iuml: "",
            eth: "",
            ntilde: "",
            ograve: "",
            oacute: "",
            ocirc: "",
            otilde: "",
            ouml: "",
            divide: "",
            oslash: "",
            ugrave: "",
            uacute: "",
            ucirc: "",
            uuml: "",
            yacute: "",
            thorn: "",
            yuml: "",
            OElig: "",
            oelig: "",
            Scaron: "",
            scaron: "",
            Yuml: "",
            fnof: "",
            circ: "",
            tilde: "",
            Alpha: "",
            Beta: "",
            Gamma: "",
            Delta: "",
            Epsilon: "",
            Zeta: "",
            Eta: "",
            Theta: "",
            Iota: "",
            Kappa: "",
            Lambda: "",
            Mu: "",
            Nu: "",
            Xi: "",
            Omicron: "",
            Pi: "",
            Rho: "",
            Sigma: "",
            Tau: "",
            Upsilon: "",
            Phi: "",
            Chi: "",
            Psi: "",
            Omega: "",
            alpha: "",
            beta: "",
            gamma: "",
            delta: "",
            epsilon: "",
            zeta: "",
            eta: "",
            theta: "",
            iota: "",
            kappa: "",
            lambda: "",
            mu: "",
            nu: "",
            xi: "",
            omicron: "",
            pi: "",
            rho: "",
            sigmaf: "",
            sigma: "",
            tau: "",
            upsilon: "",
            phi: "",
            chi: "",
            psi: "",
            omega: "",
            thetasym: "",
            upsih: "",
            piv: "",
            ensp: "",
            emsp: "",
            thinsp: "",
            zwnj: "",
            zwj: "",
            lrm: "",
            rlm: "",
            ndash: "",
            mdash: "",
            lsquo: "",
            rsquo: "",
            sbquo: "",
            ldquo: "",
            rdquo: "",
            bdquo: "",
            dagger: "",
            Dagger: "",
            bull: "",
            hellip: "",
            permil: "",
            prime: "",
            Prime: "",
            lsaquo: "",
            rsaquo: "",
            oline: "",
            frasl: "",
            euro: "",
            image: "",
            weierp: "",
            real: "",
            trade: "",
            alefsym: "",
            larr: "",
            uarr: "",
            rarr: "",
            darr: "",
            harr: "",
            crarr: "",
            lArr: "",
            uArr: "",
            rArr: "",
            dArr: "",
            hArr: "",
            forall: "",
            part: "",
            exist: "",
            empty: "",
            nabla: "",
            isin: "",
            notin: "",
            ni: "",
            prod: "",
            sum: "",
            minus: "",
            lowast: "",
            radic: "",
            prop: "",
            infin: "",
            ang: "",
            and: "",
            or: "",
            cap: "",
            cup: "",
            int: "",
            there4: "",
            sim: "",
            cong: "",
            asymp: "",
            ne: "",
            equiv: "",
            le: "",
            ge: "",
            sub: "",
            sup: "",
            nsub: "",
            sube: "",
            supe: "",
            oplus: "",
            otimes: "",
            perp: "",
            sdot: "",
            lceil: "",
            rceil: "",
            lfloor: "",
            rfloor: "",
            loz: "",
            spades: "",
            clubs: "",
            hearts: "",
            diams: "",
            lang: "",
            rang: ""
          };
        },
        /* 15 */
        /***/
        function(module2, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var error_handler_1 = __webpack_require__(10);
          var scanner_1 = __webpack_require__(12);
          var token_1 = __webpack_require__(13);
          var Reader = function() {
            function Reader2() {
              this.values = [];
              this.curly = this.paren = -1;
            }
            Reader2.prototype.beforeFunctionExpression = function(t) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                // assignment operators
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                // binary/unary operators
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(t) >= 0;
            };
            Reader2.prototype.isRegexStart = function() {
              var previous = this.values[this.values.length - 1];
              var regex2 = previous !== null;
              switch (previous) {
                case "this":
                case "]":
                  regex2 = false;
                  break;
                case ")":
                  var keyword = this.values[this.paren - 1];
                  regex2 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                  break;
                case "}":
                  regex2 = false;
                  if (this.values[this.curly - 3] === "function") {
                    var check = this.values[this.curly - 4];
                    regex2 = check ? !this.beforeFunctionExpression(check) : false;
                  } else if (this.values[this.curly - 4] === "function") {
                    var check = this.values[this.curly - 5];
                    regex2 = check ? !this.beforeFunctionExpression(check) : true;
                  }
                  break;
              }
              return regex2;
            };
            Reader2.prototype.push = function(token) {
              if (token.type === 7 || token.type === 4) {
                if (token.value === "{") {
                  this.curly = this.values.length;
                } else if (token.value === "(") {
                  this.paren = this.values.length;
                }
                this.values.push(token.value);
              } else {
                this.values.push(null);
              }
            };
            return Reader2;
          }();
          var Tokenizer = function() {
            function Tokenizer2(code, config) {
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
              this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
              this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
              this.buffer = [];
              this.reader = new Reader();
            }
            Tokenizer2.prototype.errors = function() {
              return this.errorHandler.errors;
            };
            Tokenizer2.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var comments = this.scanner.scanComments();
                if (this.scanner.trackComment) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var value2 = this.scanner.source.slice(e.slice[0], e.slice[1]);
                    var comment = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value: value2
                    };
                    if (this.trackRange) {
                      comment.range = e.range;
                    }
                    if (this.trackLoc) {
                      comment.loc = e.loc;
                    }
                    this.buffer.push(comment);
                  }
                }
                if (!this.scanner.eof()) {
                  var loc = void 0;
                  if (this.trackLoc) {
                    loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    };
                  }
                  var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                  var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                  this.reader.push(token);
                  var entry = {
                    type: token_1.TokenName[token.type],
                    value: this.scanner.source.slice(token.start, token.end)
                  };
                  if (this.trackRange) {
                    entry.range = [token.start, token.end];
                  }
                  if (this.trackLoc) {
                    loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                  }
                  if (token.type === 9) {
                    var pattern2 = token.pattern;
                    var flags = token.flags;
                    entry.regex = { pattern: pattern2, flags };
                  }
                  this.buffer.push(entry);
                }
              }
              return this.buffer.shift();
            };
            return Tokenizer2;
          }();
          exports2.Tokenizer = Tokenizer;
        }
        /******/
      ])
    );
  });
})(esprima$1);
var esprimaExports = esprima$1.exports;
var util = {};
function isArray$3(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === "[object Array]";
}
util.isArray = isArray$3;
function isBoolean$1(arg) {
  return typeof arg === "boolean";
}
util.isBoolean = isBoolean$1;
function isNull$1(arg) {
  return arg === null;
}
util.isNull = isNull$1;
function isNullOrUndefined(arg) {
  return arg == null;
}
util.isNullOrUndefined = isNullOrUndefined;
function isNumber$2(arg) {
  return typeof arg === "number";
}
util.isNumber = isNumber$2;
function isString$2(arg) {
  return typeof arg === "string";
}
util.isString = isString$2;
function isSymbol(arg) {
  return typeof arg === "symbol";
}
util.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
util.isUndefined = isUndefined;
function isRegExp(re) {
  return objectToString(re) === "[object RegExp]";
}
util.isRegExp = isRegExp;
function isObject$4(arg) {
  return typeof arg === "object" && arg !== null;
}
util.isObject = isObject$4;
function isDate(d) {
  return objectToString(d) === "[object Date]";
}
util.isDate = isDate;
function isError(e) {
  return objectToString(e) === "[object Error]" || e instanceof Error;
}
util.isError = isError;
function isFunction$1(arg) {
  return typeof arg === "function";
}
util.isFunction = isFunction$1;
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
util.isPrimitive = isPrimitive;
util.isBuffer = require$$0$1.Buffer.isBuffer;
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
const DEFAULT_MIN_MERGE = 32;
const DEFAULT_MIN_GALLOPING = 7;
const DEFAULT_TMP_STORAGE_LENGTH = 256;
const POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
let results;
const log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
function alphabeticalCompare(a, b) {
  if (a === b) {
    return 0;
  }
  if (~~a === a && ~~b === b) {
    if (a === 0 || b === 0) {
      return a < b ? -1 : 1;
    }
    if (a < 0 || b < 0) {
      if (b >= 0) {
        return -1;
      }
      if (a >= 0) {
        return 1;
      }
      a = -a;
      b = -b;
    }
    const al = log10(a);
    const bl = log10(b);
    let t = 0;
    if (al < bl) {
      a *= POWERS_OF_TEN[bl - al - 1];
      b /= 10;
      t = -1;
    } else if (al > bl) {
      b *= POWERS_OF_TEN[al - bl - 1];
      a /= 10;
      t = 1;
    }
    if (a === b) {
      return t;
    }
    return a < b ? -1 : 1;
  }
  const aStr = String(a);
  const bStr = String(b);
  if (aStr === bStr) {
    return 0;
  }
  return aStr < bStr ? -1 : 1;
}
function minRunLength(n) {
  let r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array2, lo, hi, compare) {
  let runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare(array2[runHi++], array2[lo]) < 0) {
    while (runHi < hi && compare(array2[runHi], array2[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array2, lo, runHi);
    reverseRun(results, lo, runHi);
  } else {
    while (runHi < hi && compare(array2[runHi], array2[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array2, lo, hi) {
  hi--;
  while (lo < hi) {
    const t = array2[lo];
    array2[lo++] = array2[hi];
    array2[hi--] = t;
  }
}
function binaryInsertionSort(array2, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }
  for (; start < hi; start++) {
    const pivot = array2[start];
    const pivotIndex = results[start];
    let left = lo;
    let right = start;
    while (left < right) {
      const mid = left + right >>> 1;
      if (compare(pivot, array2[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    let n = start - left;
    switch (n) {
      case 3:
        array2[left + 3] = array2[left + 2];
        results[left + 3] = results[left + 2];
      case 2:
        array2[left + 2] = array2[left + 1];
        results[left + 2] = results[left + 1];
      case 1:
        array2[left + 1] = array2[left];
        results[left + 1] = results[left];
        break;
      default:
        while (n > 0) {
          array2[left + n] = array2[left + n - 1];
          results[left + n] = results[left + n - 1];
          n--;
        }
    }
    array2[left] = pivot;
    results[left] = pivotIndex;
  }
}
function gallopLeft(value2, array2, start, length, hint, compare) {
  let lastOffset = 0;
  let maxOffset = 0;
  let offset = 1;
  if (compare(value2, array2[start + hint]) > 0) {
    maxOffset = length - hint;
    while (offset < maxOffset && compare(value2, array2[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare(value2, array2[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    const tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    const m = lastOffset + (offset - lastOffset >>> 1);
    if (compare(value2, array2[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }
  return offset;
}
function gallopRight(value2, array2, start, length, hint, compare) {
  let lastOffset = 0;
  let maxOffset = 0;
  let offset = 1;
  if (compare(value2, array2[start + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare(value2, array2[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    const tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;
    while (offset < maxOffset && compare(value2, array2[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    const m = lastOffset + (offset - lastOffset >>> 1);
    if (compare(value2, array2[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }
  return offset;
}
class TimSort {
  constructor(array2, compare) {
    this.array = array2;
    this.compare = compare;
    const { length } = array2;
    this.length = length;
    this.minGallop = DEFAULT_MIN_GALLOPING;
    this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
    this.tmp = new Array(this.tmpStorageLength);
    this.tmpIndex = new Array(this.tmpStorageLength);
    this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
    this.runStart = new Array(this.stackLength);
    this.runLength = new Array(this.stackLength);
    this.stackSize = 0;
  }
  /**
   * Push a new run on TimSort's stack.
   *
   * @param {number} runStart - Start index of the run in the original array.
   * @param {number} runLength - Length of the run;
   */
  pushRun(runStart, runLength) {
    this.runStart[this.stackSize] = runStart;
    this.runLength[this.stackSize] = runLength;
    this.stackSize += 1;
  }
  /**
   * Merge runs on TimSort's stack so that the following holds for all i:
   * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
   * 2) runLength[i - 2] > runLength[i - 1]
   */
  mergeRuns() {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2;
      if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
        if (this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }
      } else if (this.runLength[n] > this.runLength[n + 1]) {
        break;
      }
      this.mergeAt(n);
    }
  }
  /**
   * Merge all runs on TimSort's stack until only one remains.
   */
  forceMergeRuns() {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2;
      if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
        n--;
      }
      this.mergeAt(n);
    }
  }
  /**
   * Merge the runs on the stack at positions i and i+1. Must be always be called
   * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
   *
   * @param {number} i - Index of the run to merge in TimSort's stack.
   */
  mergeAt(i) {
    const { compare } = this;
    const { array: array2 } = this;
    let start1 = this.runStart[i];
    let length1 = this.runLength[i];
    const start2 = this.runStart[i + 1];
    let length2 = this.runLength[i + 1];
    this.runLength[i] = length1 + length2;
    if (i === this.stackSize - 3) {
      this.runStart[i + 1] = this.runStart[i + 2];
      this.runLength[i + 1] = this.runLength[i + 2];
    }
    this.stackSize--;
    const k = gallopRight(array2[start2], array2, start1, length1, 0, compare);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(
      array2[start1 + length1 - 1],
      array2,
      start2,
      length2,
      length2 - 1,
      compare
    );
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      this.mergeLow(start1, length1, start2, length2);
    } else {
      this.mergeHigh(start1, length1, start2, length2);
    }
  }
  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length <= run2.length as it uses
   * TimSort temporary array to store run1. Use mergeHigh if run1.length >
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeLow(start1, length1, start2, length2) {
    const { compare } = this;
    const { array: array2 } = this;
    const { tmp } = this;
    const { tmpIndex } = this;
    let i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array2[start1 + i];
      tmpIndex[i] = results[start1 + i];
    }
    let cursor1 = 0;
    let cursor2 = start2;
    let dest = start1;
    array2[dest] = array2[cursor2];
    results[dest] = results[cursor2];
    dest++;
    cursor2++;
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array2[dest + i] = tmp[cursor1 + i];
        results[dest + i] = tmpIndex[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array2[dest + i] = array2[cursor2 + i];
        results[dest + i] = results[cursor2 + i];
      }
      array2[dest + length2] = tmp[cursor1];
      results[dest + length2] = tmpIndex[cursor1];
      return;
    }
    let { minGallop } = this;
    while (true) {
      let count1 = 0;
      let count2 = 0;
      let exit = false;
      do {
        if (compare(array2[cursor2], tmp[cursor1]) < 0) {
          array2[dest] = array2[cursor2];
          results[dest] = results[cursor2];
          dest++;
          cursor2++;
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array2[dest] = tmp[cursor1];
          results[dest] = tmpIndex[cursor1];
          dest++;
          cursor1++;
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array2[cursor2], tmp, cursor1, length1, 0, compare);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array2[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array2[dest] = array2[cursor2];
        results[dest] = results[cursor2];
        dest++;
        cursor2++;
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array2, cursor2, length2, 0, compare);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array2[dest + i] = array2[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array2[dest] = tmp[cursor1];
        results[dest] = tmpIndex[cursor1];
        dest++;
        cursor1++;
        if (--length1 === 1) {
          exit = true;
          break;
        }
        minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (minGallop < 0) {
        minGallop = 0;
      }
      minGallop += 2;
    }
    this.minGallop = minGallop;
    if (minGallop < 1) {
      this.minGallop = 1;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array2[dest + i] = array2[cursor2 + i];
        results[dest + i] = results[cursor2 + i];
      }
      array2[dest + length2] = tmp[cursor1];
      results[dest + length2] = tmpIndex[cursor1];
    } else if (length1 === 0) {
      throw new Error("mergeLow preconditions were not respected");
    } else {
      for (i = 0; i < length1; i++) {
        array2[dest + i] = tmp[cursor1 + i];
        results[dest + i] = tmpIndex[cursor1 + i];
      }
    }
  }
  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length > run2.length as it uses
   * TimSort temporary array to store run2. Use mergeLow if run1.length <=
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeHigh(start1, length1, start2, length2) {
    const { compare } = this;
    const { array: array2 } = this;
    const { tmp } = this;
    const { tmpIndex } = this;
    let i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array2[start2 + i];
      tmpIndex[i] = results[start2 + i];
    }
    let cursor1 = start1 + length1 - 1;
    let cursor2 = length2 - 1;
    let dest = start2 + length2 - 1;
    let customCursor = 0;
    let customDest = 0;
    array2[dest] = array2[cursor1];
    results[dest] = results[cursor1];
    dest--;
    cursor1--;
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array2[customCursor + i] = tmp[i];
        results[customCursor + i] = tmpIndex[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array2[customDest + i] = array2[customCursor + i];
        results[customDest + i] = results[customCursor + i];
      }
      array2[dest] = tmp[cursor2];
      results[dest] = tmpIndex[cursor2];
      return;
    }
    let { minGallop } = this;
    while (true) {
      let count1 = 0;
      let count2 = 0;
      let exit = false;
      do {
        if (compare(tmp[cursor2], array2[cursor1]) < 0) {
          array2[dest] = array2[cursor1];
          results[dest] = results[cursor1];
          dest--;
          cursor1--;
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array2[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          dest--;
          cursor2--;
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(
          tmp[cursor2],
          array2,
          start1,
          length1,
          length1 - 1,
          compare
        );
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array2[customDest + i] = array2[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array2[dest] = tmp[cursor2];
        results[dest] = tmpIndex[cursor2];
        dest--;
        cursor2--;
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(
          array2[cursor1],
          tmp,
          0,
          length2,
          length2 - 1,
          compare
        );
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array2[customDest + i] = tmp[customCursor + i];
            results[customDest + i] = tmpIndex[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array2[dest] = array2[cursor1];
        results[dest] = results[cursor1];
        dest--;
        cursor1--;
        if (--length1 === 0) {
          exit = true;
          break;
        }
        minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (minGallop < 0) {
        minGallop = 0;
      }
      minGallop += 2;
    }
    this.minGallop = minGallop;
    if (minGallop < 1) {
      this.minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array2[customDest + i] = array2[customCursor + i];
        results[customDest + i] = results[customCursor + i];
      }
      array2[dest] = tmp[cursor2];
      results[dest] = tmpIndex[cursor2];
    } else if (length2 === 0) {
      throw new Error("mergeHigh preconditions were not respected");
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array2[customCursor + i] = tmp[i];
        results[customCursor + i] = tmpIndex[i];
      }
    }
  }
}
function sort$1(array2, compare, lo, hi) {
  if (!Array.isArray(array2)) {
    throw new TypeError(
      `The "array" argument must be an array. Received ${array2}`
    );
  }
  results = [];
  const { length } = array2;
  let i = 0;
  while (i < length) {
    results[i] = i++;
  }
  if (!compare) {
    compare = alphabeticalCompare;
  } else if (typeof compare !== "function") {
    hi = lo;
    lo = compare;
    compare = alphabeticalCompare;
  }
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = length;
  }
  let remaining = hi - lo;
  if (remaining < 2) {
    return results;
  }
  let runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array2, lo, hi, compare);
    binaryInsertionSort(array2, lo, hi, lo + runLength, compare);
    return results;
  }
  const ts = new TimSort(array2, compare);
  const minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array2, lo, hi, compare);
    if (runLength < minRun) {
      let force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array2, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
  return results;
}
var src$1 = {
  sort: sort$1
};
const hasOwnProp = Object.prototype.hasOwnProperty;
var hasOwnProp_1 = (object, property) => hasOwnProp.call(object, property);
const hasOwnProperty = hasOwnProp_1;
const {
  isObject: isObject$3,
  isArray: isArray$2,
  isString: isString$1,
  isNumber: isNumber$1
} = util;
const PREFIX_BEFORE$2 = "before";
const PREFIX_AFTER_PROP$2 = "after-prop";
const PREFIX_AFTER_COLON$2 = "after-colon";
const PREFIX_AFTER_VALUE$2 = "after-value";
const PREFIX_AFTER$2 = "after";
const PREFIX_BEFORE_ALL$2 = "before-all";
const PREFIX_AFTER_ALL$2 = "after-all";
const BRACKET_OPEN$2 = "[";
const BRACKET_CLOSE$2 = "]";
const CURLY_BRACKET_OPEN$2 = "{";
const CURLY_BRACKET_CLOSE$2 = "}";
const COMMA$2 = ",";
const EMPTY$2 = "";
const MINUS$1 = "-";
const SYMBOL_PREFIXES$1 = [
  PREFIX_BEFORE$2,
  PREFIX_AFTER_PROP$2,
  PREFIX_AFTER_COLON$2,
  PREFIX_AFTER_VALUE$2,
  PREFIX_AFTER$2
];
const NON_PROP_SYMBOL_KEYS = [
  PREFIX_BEFORE$2,
  PREFIX_BEFORE_ALL$2,
  PREFIX_AFTER_ALL$2
].map(Symbol.for);
const COLON$2 = ":";
const UNDEFINED$3 = void 0;
const symbol$1 = (prefix, key) => Symbol.for(prefix + COLON$2 + key);
const define$1 = (target, key, value2) => Object.defineProperty(target, key, {
  value: value2,
  writable: true,
  configurable: true
});
const copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
  const source_prop = symbol$1(prefix, source_key);
  if (!hasOwnProperty(source, source_prop)) {
    return;
  }
  const target_prop = target_key === source_key ? source_prop : symbol$1(prefix, target_key);
  define$1(target, target_prop, source[source_prop]);
  if (remove_source) {
    delete source[source_prop];
  }
};
const copy_comments$1 = (target, source, target_key, source_key, remove_source) => {
  SYMBOL_PREFIXES$1.forEach((prefix) => {
    copy_comments_by_kind(
      target,
      source,
      target_key,
      source_key,
      prefix,
      remove_source
    );
  });
};
const swap_comments$1 = (array2, from, to) => {
  if (from === to) {
    return;
  }
  SYMBOL_PREFIXES$1.forEach((prefix) => {
    const target_prop = symbol$1(prefix, to);
    if (!hasOwnProperty(array2, target_prop)) {
      copy_comments_by_kind(array2, array2, to, from, prefix, true);
      return;
    }
    const comments = array2[target_prop];
    delete array2[target_prop];
    copy_comments_by_kind(array2, array2, to, from, prefix, true);
    define$1(array2, symbol$1(prefix, from), comments);
  });
};
const assign_non_prop_comments$1 = (target, source) => {
  NON_PROP_SYMBOL_KEYS.forEach((key) => {
    const comments = source[key];
    if (comments) {
      define$1(target, key, comments);
    }
  });
};
const assign$1 = (target, source, keys) => {
  keys.forEach((key) => {
    if (!isString$1(key) && !isNumber$1(key)) {
      return;
    }
    if (!hasOwnProperty(source, key)) {
      return;
    }
    target[key] = source[key];
    copy_comments$1(target, source, key, key);
  });
  return target;
};
var common$1 = {
  SYMBOL_PREFIXES: SYMBOL_PREFIXES$1,
  PREFIX_BEFORE: PREFIX_BEFORE$2,
  PREFIX_AFTER_PROP: PREFIX_AFTER_PROP$2,
  PREFIX_AFTER_COLON: PREFIX_AFTER_COLON$2,
  PREFIX_AFTER_VALUE: PREFIX_AFTER_VALUE$2,
  PREFIX_AFTER: PREFIX_AFTER$2,
  PREFIX_BEFORE_ALL: PREFIX_BEFORE_ALL$2,
  PREFIX_AFTER_ALL: PREFIX_AFTER_ALL$2,
  BRACKET_OPEN: BRACKET_OPEN$2,
  BRACKET_CLOSE: BRACKET_CLOSE$2,
  CURLY_BRACKET_OPEN: CURLY_BRACKET_OPEN$2,
  CURLY_BRACKET_CLOSE: CURLY_BRACKET_CLOSE$2,
  COLON: COLON$2,
  COMMA: COMMA$2,
  MINUS: MINUS$1,
  EMPTY: EMPTY$2,
  UNDEFINED: UNDEFINED$3,
  symbol: symbol$1,
  define: define$1,
  copy_comments: copy_comments$1,
  swap_comments: swap_comments$1,
  assign_non_prop_comments: assign_non_prop_comments$1,
  assign(target, source, keys) {
    if (!isObject$3(target)) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    if (!isObject$3(source)) {
      return target;
    }
    if (keys === UNDEFINED$3) {
      keys = Object.keys(source);
      assign_non_prop_comments$1(target, source);
    } else if (!isArray$2(keys)) {
      throw new TypeError("keys must be array or undefined");
    } else if (keys.length === 0) {
      assign_non_prop_comments$1(target, source);
    }
    return assign$1(target, source, keys);
  }
};
const { isArray: isArray$1 } = util;
const { sort } = src$1;
const {
  SYMBOL_PREFIXES,
  UNDEFINED: UNDEFINED$2,
  symbol,
  copy_comments,
  swap_comments
} = common$1;
const reverse_comments = (array2) => {
  const { length } = array2;
  let i = 0;
  const max = length / 2;
  for (; i < max; i++) {
    swap_comments(array2, i, length - i - 1);
  }
};
const move_comment = (target, source, i, offset, remove2) => {
  copy_comments(target, source, i + offset, i, remove2);
};
const move_comments = (target, source, start, count, offset, remove2) => {
  if (offset > 0) {
    let i2 = count;
    while (i2-- > 0) {
      move_comment(target, source, start + i2, offset, remove2);
    }
    return;
  }
  let i = 0;
  while (i < count) {
    const ii = i++;
    move_comment(target, source, start + ii, offset, remove2);
  }
};
const remove_comments$1 = (array2, key) => {
  SYMBOL_PREFIXES.forEach((prefix) => {
    const prop = symbol(prefix, key);
    delete array2[prop];
  });
};
const get_mapped = (map2, key) => {
  let mapped = key;
  while (mapped in map2) {
    mapped = map2[mapped];
  }
  return mapped;
};
let CommentArray$2 = class CommentArray extends Array {
  // - deleteCount + items.length
  // We should avoid `splice(begin, deleteCount, ...items)`,
  // because `splice(0, undefined)` is not equivalent to `splice(0)`,
  // as well as:
  // - slice
  splice(...args) {
    const { length } = this;
    const ret = super.splice(...args);
    let [begin, deleteCount, ...items] = args;
    if (begin < 0) {
      begin += length;
    }
    if (arguments.length === 1) {
      deleteCount = length - begin;
    } else {
      deleteCount = Math.min(length - begin, deleteCount);
    }
    const {
      length: item_length
    } = items;
    const offset = item_length - deleteCount;
    const start = begin + deleteCount;
    const count = length - start;
    move_comments(this, this, start, count, offset, true);
    return ret;
  }
  slice(...args) {
    const { length } = this;
    const array2 = super.slice(...args);
    if (!array2.length) {
      return new CommentArray();
    }
    let [begin, before] = args;
    if (before === UNDEFINED$2) {
      before = length;
    } else if (before < 0) {
      before += length;
    }
    if (begin < 0) {
      begin += length;
    } else if (begin === UNDEFINED$2) {
      begin = 0;
    }
    move_comments(array2, this, begin, before - begin, -begin);
    return array2;
  }
  unshift(...items) {
    const { length } = this;
    const ret = super.unshift(...items);
    const {
      length: items_length
    } = items;
    if (items_length > 0) {
      move_comments(this, this, 0, length, items_length, true);
    }
    return ret;
  }
  shift() {
    const ret = super.shift();
    const { length } = this;
    remove_comments$1(this, 0);
    move_comments(this, this, 1, length, -1, true);
    return ret;
  }
  reverse() {
    super.reverse();
    reverse_comments(this);
    return this;
  }
  pop() {
    const ret = super.pop();
    remove_comments$1(this, this.length);
    return ret;
  }
  concat(...items) {
    let { length } = this;
    const ret = super.concat(...items);
    if (!items.length) {
      return ret;
    }
    move_comments(ret, this, 0, this.length, 0);
    items.forEach((item) => {
      const prev = length;
      length += isArray$1(item) ? item.length : 1;
      if (!(item instanceof CommentArray)) {
        return;
      }
      move_comments(ret, item, 0, item.length, prev);
    });
    return ret;
  }
  sort(...args) {
    const result = sort(
      this,
      ...args.slice(0, 1)
    );
    const map2 = /* @__PURE__ */ Object.create(null);
    result.forEach((source_index, index2) => {
      if (source_index === index2) {
        return;
      }
      const real_source_index = get_mapped(map2, source_index);
      if (real_source_index === index2) {
        return;
      }
      map2[index2] = real_source_index;
      swap_comments(this, index2, real_source_index);
    });
    return this;
  }
};
var array = {
  CommentArray: CommentArray$2
};
const esprima = esprimaExports;
const {
  CommentArray: CommentArray$1
} = array;
const {
  PREFIX_BEFORE: PREFIX_BEFORE$1,
  PREFIX_AFTER_PROP: PREFIX_AFTER_PROP$1,
  PREFIX_AFTER_COLON: PREFIX_AFTER_COLON$1,
  PREFIX_AFTER_VALUE: PREFIX_AFTER_VALUE$1,
  PREFIX_AFTER: PREFIX_AFTER$1,
  PREFIX_BEFORE_ALL: PREFIX_BEFORE_ALL$1,
  PREFIX_AFTER_ALL: PREFIX_AFTER_ALL$1,
  BRACKET_OPEN: BRACKET_OPEN$1,
  BRACKET_CLOSE: BRACKET_CLOSE$1,
  CURLY_BRACKET_OPEN: CURLY_BRACKET_OPEN$1,
  CURLY_BRACKET_CLOSE: CURLY_BRACKET_CLOSE$1,
  COLON: COLON$1,
  COMMA: COMMA$1,
  MINUS,
  EMPTY: EMPTY$1,
  UNDEFINED: UNDEFINED$1,
  define,
  assign_non_prop_comments
} = common$1;
const tokenize$1 = (code) => esprima.tokenize(code, {
  comment: true,
  loc: true
});
const previous_hosts = [];
let comments_host = null;
let unassigned_comments = null;
const previous_props = [];
let last_prop;
let remove_comments = false;
let inline = false;
let tokens = null;
let last = null;
let current = null;
let index;
let reviver = null;
const clean$1 = () => {
  previous_props.length = previous_hosts.length = 0;
  last = null;
  last_prop = UNDEFINED$1;
};
const free = () => {
  clean$1();
  tokens.length = 0;
  unassigned_comments = comments_host = tokens = last = current = reviver = null;
};
const symbolFor = (prefix) => Symbol.for(
  last_prop !== UNDEFINED$1 ? prefix + COLON$1 + last_prop : prefix
);
const transform = (k, v) => reviver ? reviver(k, v) : v;
const unexpected = () => {
  const error = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
  Object.assign(error, current.loc.start);
  throw error;
};
const unexpected_end = () => {
  const error = new SyntaxError("Unexpected end of JSON input");
  Object.assign(error, last ? last.loc.end : {
    line: 1,
    column: 0
  });
  throw error;
};
const next = () => {
  const new_token = tokens[++index];
  inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
  last = current;
  current = new_token;
};
const type$1 = () => {
  if (!current) {
    unexpected_end();
  }
  return current.type === "Punctuator" ? current.value : current.type;
};
const is = (t) => type$1() === t;
const expect = (a) => {
  if (!is(a)) {
    unexpected();
  }
};
const set_comments_host = (new_host) => {
  previous_hosts.push(comments_host);
  comments_host = new_host;
};
const restore_comments_host = () => {
  comments_host = previous_hosts.pop();
};
const assign_after_comments = () => {
  if (!unassigned_comments) {
    return;
  }
  const after_comments = [];
  for (const comment of unassigned_comments) {
    if (comment.inline) {
      after_comments.push(comment);
    } else {
      break;
    }
  }
  const { length } = after_comments;
  if (!length) {
    return;
  }
  if (length === unassigned_comments.length) {
    unassigned_comments = null;
  } else {
    unassigned_comments.splice(0, length);
  }
  define(comments_host, symbolFor(PREFIX_AFTER$1), after_comments);
};
const assign_comments = (prefix) => {
  if (!unassigned_comments) {
    return;
  }
  define(comments_host, symbolFor(prefix), unassigned_comments);
  unassigned_comments = null;
};
const parse_comments = (prefix) => {
  const comments = [];
  while (current && (is("LineComment") || is("BlockComment"))) {
    const comment = {
      ...current,
      inline
    };
    comments.push(comment);
    next();
  }
  if (remove_comments) {
    return;
  }
  if (!comments.length) {
    return;
  }
  if (prefix) {
    define(comments_host, symbolFor(prefix), comments);
    return;
  }
  unassigned_comments = comments;
};
const set_prop = (prop, push2) => {
  if (push2) {
    previous_props.push(last_prop);
  }
  last_prop = prop;
};
const restore_prop = () => {
  last_prop = previous_props.pop();
};
const parse_object = () => {
  const obj = {};
  set_comments_host(obj);
  set_prop(UNDEFINED$1, true);
  let started = false;
  let name;
  parse_comments();
  while (!is(CURLY_BRACKET_CLOSE$1)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE$1);
      expect(COMMA$1);
      next();
      parse_comments();
      assign_after_comments();
      if (is(CURLY_BRACKET_CLOSE$1)) {
        break;
      }
    }
    started = true;
    expect("String");
    name = JSON.parse(current.value);
    set_prop(name);
    assign_comments(PREFIX_BEFORE$1);
    next();
    parse_comments(PREFIX_AFTER_PROP$1);
    expect(COLON$1);
    next();
    parse_comments(PREFIX_AFTER_COLON$1);
    obj[name] = transform(name, walk());
    parse_comments();
  }
  if (started) {
    assign_comments(PREFIX_AFTER$1);
  }
  next();
  last_prop = void 0;
  if (!started) {
    assign_comments(PREFIX_BEFORE$1);
  }
  restore_comments_host();
  restore_prop();
  return obj;
};
const parse_array = () => {
  const array2 = new CommentArray$1();
  set_comments_host(array2);
  set_prop(UNDEFINED$1, true);
  let started = false;
  let i = 0;
  parse_comments();
  while (!is(BRACKET_CLOSE$1)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE$1);
      expect(COMMA$1);
      next();
      parse_comments();
      assign_after_comments();
      if (is(BRACKET_CLOSE$1)) {
        break;
      }
    }
    started = true;
    set_prop(i);
    assign_comments(PREFIX_BEFORE$1);
    array2[i] = transform(i, walk());
    i++;
    parse_comments();
  }
  if (started) {
    assign_comments(PREFIX_AFTER$1);
  }
  next();
  last_prop = void 0;
  if (!started) {
    assign_comments(PREFIX_BEFORE$1);
  }
  restore_comments_host();
  restore_prop();
  return array2;
};
function walk() {
  let tt = type$1();
  if (tt === CURLY_BRACKET_OPEN$1) {
    next();
    return parse_object();
  }
  if (tt === BRACKET_OPEN$1) {
    next();
    return parse_array();
  }
  let negative = EMPTY$1;
  if (tt === MINUS) {
    next();
    tt = type$1();
    negative = MINUS;
  }
  let v;
  switch (tt) {
    case "String":
    case "Boolean":
    case "Null":
    case "Numeric":
      v = current.value;
      next();
      return JSON.parse(negative + v);
  }
}
const isObject$2 = (subject) => Object(subject) === subject;
const parse$1 = (code, rev, no_comments) => {
  clean$1();
  tokens = tokenize$1(code);
  reviver = rev;
  remove_comments = no_comments;
  if (!tokens.length) {
    unexpected_end();
  }
  index = -1;
  next();
  set_comments_host({});
  parse_comments(PREFIX_BEFORE_ALL$1);
  let result = walk();
  parse_comments(PREFIX_AFTER_ALL$1);
  if (current) {
    unexpected();
  }
  if (!no_comments && result !== null) {
    if (!isObject$2(result)) {
      result = new Object(result);
    }
    assign_non_prop_comments(result, comments_host);
  }
  restore_comments_host();
  result = transform("", result);
  free();
  return result;
};
var parse_1 = {
  parse: parse$1,
  tokenize: tokenize$1
};
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var res = "";
var cache;
var repeatString = repeat$2;
function repeat$2(str2, num2) {
  if (typeof str2 !== "string") {
    throw new TypeError("expected a string");
  }
  if (num2 === 1)
    return str2;
  if (num2 === 2)
    return str2 + str2;
  var max = str2.length * num2;
  if (cache !== str2 || typeof cache === "undefined") {
    cache = str2;
    res = "";
  } else if (res.length >= max) {
    return res.substr(0, max);
  }
  while (max > res.length && num2 > 1) {
    if (num2 & 1) {
      res += str2;
    }
    num2 >>= 1;
    str2 += str2;
  }
  res += str2;
  res = res.substr(0, max);
  return res;
}
const {
  isArray,
  isObject: isObject$1,
  isFunction,
  isNumber,
  isString
} = util;
const repeat$1 = repeatString;
const {
  PREFIX_BEFORE_ALL,
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,
  PREFIX_AFTER_ALL,
  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,
  COLON,
  COMMA,
  EMPTY,
  UNDEFINED
} = common$1;
const ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
const SPACE = " ";
const LF = "\n";
const STR_NULL = "null";
const BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
const AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
const AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
const AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
const AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
const meta = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
const escape = (string) => {
  ESCAPABLE.lastIndex = 0;
  if (!ESCAPABLE.test(string)) {
    return string;
  }
  return string.replace(ESCAPABLE, (a) => {
    const c2 = meta[a];
    return typeof c2 === "string" ? c2 : a;
  });
};
const quote = (string) => `"${escape(string)}"`;
const comment_stringify = (value2, line) => line ? `//${value2}` : `/*${value2}*/`;
const process_comments = (host, symbol_tag, deeper_gap, display_block) => {
  const comments = host[Symbol.for(symbol_tag)];
  if (!comments || !comments.length) {
    return EMPTY;
  }
  let is_line_comment = false;
  const str2 = comments.reduce((prev, {
    inline: inline2,
    type: type2,
    value: value2
  }) => {
    const delimiter = inline2 ? SPACE : LF + deeper_gap;
    is_line_comment = type2 === "LineComment";
    return prev + delimiter + comment_stringify(value2, is_line_comment);
  }, EMPTY);
  return display_block || is_line_comment ? str2 + LF + deeper_gap : str2;
};
let replacer = null;
let indent = EMPTY;
const clean2 = () => {
  replacer = null;
  indent = EMPTY;
};
const join = (one, two, gap) => one ? two ? one + two.trim() + LF + gap : one.trimRight() + LF + gap : two ? two.trimRight() + LF + gap : EMPTY;
const join_content = (inside, value2, gap) => {
  const comment = process_comments(value2, PREFIX_BEFORE, gap + indent, true);
  return join(comment, inside, gap);
};
const array_stringify = (value2, gap) => {
  const deeper_gap = gap + indent;
  const { length } = value2;
  let inside = EMPTY;
  let after_comma = EMPTY;
  for (let i = 0; i < length; i++) {
    if (i !== 0) {
      inside += COMMA;
    }
    const before = join(
      after_comma,
      process_comments(value2, BEFORE(i), deeper_gap),
      deeper_gap
    );
    inside += before || LF + deeper_gap;
    inside += stringify$1(i, value2, deeper_gap) || STR_NULL;
    inside += process_comments(value2, AFTER_VALUE(i), deeper_gap);
    after_comma = process_comments(value2, AFTER(i), deeper_gap);
  }
  inside += join(
    after_comma,
    process_comments(value2, PREFIX_AFTER, deeper_gap),
    deeper_gap
  );
  return BRACKET_OPEN + join_content(inside, value2, gap) + BRACKET_CLOSE;
};
const object_stringify = (value2, gap) => {
  if (!value2) {
    return "null";
  }
  const deeper_gap = gap + indent;
  let inside = EMPTY;
  let after_comma = EMPTY;
  let first = true;
  const keys = isArray(replacer) ? replacer : Object.keys(value2);
  const iteratee = (key) => {
    const sv = stringify$1(key, value2, deeper_gap);
    if (sv === UNDEFINED) {
      return;
    }
    if (!first) {
      inside += COMMA;
    }
    first = false;
    const before = join(
      after_comma,
      process_comments(value2, BEFORE(key), deeper_gap),
      deeper_gap
    );
    inside += before || LF + deeper_gap;
    inside += quote(key) + process_comments(value2, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value2, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value2, AFTER_VALUE(key), deeper_gap);
    after_comma = process_comments(value2, AFTER(key), deeper_gap);
  };
  keys.forEach(iteratee);
  inside += join(
    after_comma,
    process_comments(value2, PREFIX_AFTER, deeper_gap),
    deeper_gap
  );
  return CURLY_BRACKET_OPEN + join_content(inside, value2, gap) + CURLY_BRACKET_CLOSE;
};
function stringify$1(key, holder, gap) {
  let value2 = holder[key];
  if (isObject$1(value2) && isFunction(value2.toJSON)) {
    value2 = value2.toJSON(key);
  }
  if (isFunction(replacer)) {
    value2 = replacer.call(holder, key, value2);
  }
  switch (typeof value2) {
    case "string":
      return quote(value2);
    case "number":
      return Number.isFinite(value2) ? String(value2) : STR_NULL;
    case "boolean":
    case "null":
      return String(value2);
    case "object":
      return isArray(value2) ? array_stringify(value2, gap) : object_stringify(value2, gap);
  }
}
const get_indent = (space) => isString(space) ? space : isNumber(space) ? repeat$1(SPACE, space) : EMPTY;
const { toString } = Object.prototype;
const PRIMITIVE_OBJECT_TYPES = [
  "[object Number]",
  "[object String]",
  "[object Boolean]"
];
const is_primitive_object = (subject) => {
  if (typeof subject !== "object") {
    return false;
  }
  const str2 = toString.call(subject);
  return PRIMITIVE_OBJECT_TYPES.includes(str2);
};
var stringify_1 = (value2, replacer_, space) => {
  const indent_ = get_indent(space);
  if (!indent_) {
    return JSON.stringify(value2, replacer_);
  }
  if (!isFunction(replacer_) && !isArray(replacer_)) {
    replacer_ = null;
  }
  replacer = replacer_;
  indent = indent_;
  const str2 = is_primitive_object(value2) ? JSON.stringify(value2) : stringify$1("", { "": value2 }, EMPTY);
  clean2();
  return isObject$1(value2) ? process_comments(value2, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str2 + process_comments(value2, PREFIX_AFTER_ALL, EMPTY).trimRight() : str2;
};
const { parse, tokenize } = parse_1;
const stringify = stringify_1;
const { CommentArray: CommentArray2 } = array;
const { assign } = common$1;
var src = {
  parse,
  stringify,
  tokenize,
  CommentArray: CommentArray2,
  assign
};
const ExtensionsJson = typebox.Type.Object({
  recommendations: typebox.Type.Array(typebox.Type.String())
});
async function pathExists(filePath, nodeishFs) {
  try {
    await nodeishFs.stat(filePath);
    return true;
  } catch (error) {
    return false;
  }
}
const vsCodePath = "./.vscode";
async function addRecommendationToWorkspace(fs, workingDirectory) {
  const vscodeFolderPath = workingDirectory ? normalizePath$2(joinPath(workingDirectory ?? "", vsCodePath)) : vsCodePath;
  const extensionsJsonPath = joinPath(vscodeFolderPath, "extensions.json");
  if (!await pathExists(vscodeFolderPath, fs)) {
    await fs.mkdir(vscodeFolderPath);
  }
  let extensions;
  if (await pathExists(extensionsJsonPath, fs)) {
    try {
      const parsed = src.parse(await fs.readFile(extensionsJsonPath, { encoding: "utf-8" }));
      if (value.Value.Check(ExtensionsJson, parsed)) {
        extensions = parsed;
      } else {
        extensions = { recommendations: [] };
      }
    } catch (error) {
      extensions = { recommendations: [] };
    }
  } else {
    extensions = { recommendations: [] };
  }
  if (!extensions.recommendations.includes("inlang.vs-code-extension")) {
    extensions.recommendations.push("inlang.vs-code-extension");
    await fs.writeFile(extensionsJsonPath, src.stringify(extensions, void 0, 2));
  }
}
async function isInWorkspaceRecommendation(fs, workingDirectory) {
  const vscodeFolderPath = workingDirectory ? normalizePath$2(joinPath(workingDirectory ?? "", vsCodePath)) : vsCodePath;
  const extensionsJsonPath = joinPath(vscodeFolderPath, "extensions.json");
  if (!await pathExists(extensionsJsonPath, fs) || !await pathExists(vscodeFolderPath, fs)) {
    return false;
  }
  const extensions = src.parse(await fs.readFile(extensionsJsonPath, { encoding: "utf-8" }));
  if (!value.Value.Check(ExtensionsJson, extensions)) {
    return false;
  }
  return (extensions == null ? void 0 : extensions.recommendations.includes("inlang.vs-code-extension")) || false;
}
async function isAdopted$1(args) {
  return await isInWorkspaceRecommendation(args.fs, args.workingDirectory);
}
async function add$1(args) {
  await addRecommendationToWorkspace(args.fs, args.workingDirectory);
}
const maybeAddSherlock = async (ctx) => {
  var _a2;
  const isCertainlyVsCode = ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2.TERM_PROGRAM) === "vscode";
  let response = isCertainlyVsCode;
  if (!isCertainlyVsCode) {
    response = await prompt(`Are you using Visual Studio Code?`, {
      type: "confirm",
      initial: true
    });
  }
  if (response === false)
    return ctx;
  const settings = ctx.project.settings();
  if (settings.modules.some((m) => m.includes("plugin-m-function-matcher")) === false) {
    settings.modules.push(
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@latest/dist/index.js"
    );
    ctx.project.setSettings(settings);
  }
  try {
    if (!await isAdopted$1({ fs: ctx.repo.nodeishFs })) {
      await add$1({ fs: ctx.repo.nodeishFs });
      telemetry.capture({ event: "PARAGLIDE JS init added Sherlock" });
      ctx.logger.success(
        "Added the inlang Visual Studio Code extension (Sherlock) to the workspace recommendations."
      );
    }
  } catch (error) {
    ctx.logger.error(
      "Failed to add the inlang Visual Studio Code extension (Sherlock). Please open an issue"
    );
  }
  return ctx;
};
const maybeChangeTsConfig = async (ctx) => {
  const ctx1 = await maybeChangeTsConfigModuleResolution(ctx);
  return await maybeChangeTsConfigAllowJs(ctx1);
};
const maybeChangeTsConfigAllowJs = async (ctx) => {
  var _a2, _b2;
  if (await pathExists$1("./tsconfig.json", ctx.repo.nodeishFs) === false) {
    return ctx;
  }
  const file = await ctx.repo.nodeishFs.readFile("./tsconfig.json", { encoding: "utf-8" });
  let tsconfig = JSON5.parse(file);
  if (((_a2 = tsconfig.compilerOptions) == null ? void 0 : _a2.allowJs) === true) {
    return ctx;
  }
  ctx.logger.info(
    `The option \`compilerOptions.allowJs\` needs to be set to \`true\` in the \`tsconfig.json\` file:

\`{
  "compilerOptions": {
    "allowJs": true
  }
}\``
  );
  let isValid = false;
  while (isValid === false) {
    const response = await prompt(`Is \`compilerOptions.allowJs\` set to \`true\`?`, {
      type: "confirm",
      initial: true
    });
    if (response === false) {
      ctx.logger.warn(
        "Continuing without adjusting the tsconfig.json. This may lead to type errors."
      );
      return ctx;
    }
    if (tsconfig.extends) {
      isValid = true;
      return ctx;
    }
    const file2 = await ctx.repo.nodeishFs.readFile("./tsconfig.json", { encoding: "utf-8" });
    tsconfig = JSON5.parse(file2);
    if (((_b2 = tsconfig == null ? void 0 : tsconfig.compilerOptions) == null ? void 0 : _b2.allowJs) === true) {
      isValid = true;
      return ctx;
    } else {
      ctx.logger.error(
        "The compiler options has not been adjusted. Please sets `compilerOptions.allowJs` to `true`."
      );
    }
  }
  return ctx;
};
const maybeChangeTsConfigModuleResolution = async (ctx) => {
  var _a2, _b2, _c;
  if (await pathExists$1("./tsconfig.json", ctx.repo.nodeishFs) === false) {
    return ctx;
  }
  const file = await ctx.repo.nodeishFs.readFile("./tsconfig.json", { encoding: "utf-8" });
  let tsconfig = JSON5.parse(file);
  let parentTsConfig;
  if (tsconfig.extends) {
    try {
      const parentTsConfigPath = nodePath__default.resolve(process.cwd(), tsconfig.extends);
      const parentTsConfigFile = await ctx.repo.nodeishFs.readFile(parentTsConfigPath, {
        encoding: "utf-8"
      });
      parentTsConfig = JSON5.parse(parentTsConfigFile);
    } catch {
      ctx.logger.warn(
        `The tsconfig.json is extended from a tsconfig that couldn't be read. Maybe the file doesn't exist yet or is a NPM package. Continuing without taking the extended from tsconfig into consideration.`
      );
    }
  }
  const invalidOptions = ["classic", "node", "node10"];
  const moduleResolution = ((_a2 = tsconfig.compilerOptions) == null ? void 0 : _a2.moduleResolution) ?? ((_b2 = parentTsConfig == null ? void 0 : parentTsConfig.compilerOptions) == null ? void 0 : _b2.moduleResolution);
  if (moduleResolution && invalidOptions.includes(moduleResolution.toLowerCase()) === false) {
    return ctx;
  }
  ctx.logger.info(
    `The \`compilerOptions.moduleResolution\` options must be set to "Bundler" in the \`tsconfig.json\` file:

\`{
 "compilerOptions": {
   "moduleResolution": "Bundler"
 }
}\``
  );
  let isValid = false;
  while (isValid === false) {
    const response = await prompt(`Is \`compilerOptions.moduleResolution\` set to "Bundler"?`, {
      type: "confirm",
      initial: true
    });
    if (response === false) {
      ctx.logger.warn(
        "Continuing without adjusting the tsconfig.json. This may lead to type errors."
      );
      return ctx;
    }
    if (tsconfig.extends) {
      isValid = true;
      return ctx;
    }
    const file2 = await ctx.repo.nodeishFs.readFile("./tsconfig.json", { encoding: "utf-8" });
    tsconfig = JSON5.parse(file2);
    if (((_c = tsconfig == null ? void 0 : tsconfig.compilerOptions) == null ? void 0 : _c.moduleResolution) && tsconfig.compilerOptions.moduleResolution.toLowerCase() === "bundler") {
      isValid = true;
      return ctx;
    } else {
      ctx.logger.error(
        "The compiler options have not been adjusted. Please set the `compilerOptions.moduleResolution` to `Bundler`."
      );
    }
  }
  return ctx;
};
const promptForOutdir = async (ctx) => {
  const response = await prompt("Where should the compiled files be placed?", {
    type: "text",
    initial: DEFAULT_OUTDIR,
    default: DEFAULT_OUTDIR,
    placeholder: "Relative path from the package root to the desired compiler output directory"
  });
  if (!response.startsWith("./")) {
    ctx.logger.warn("You must enter a valid relative path starting from the package root.");
    return await promptForOutdir(ctx);
  }
  return {
    ...ctx,
    outdir: response
  };
};
function updatePackageJson(opt) {
  return async (ctx) => {
    const file = await ctx.repo.nodeishFs.readFile(ctx.packageJsonPath, {
      encoding: "utf-8"
    });
    const stringify2 = detectJsonFormatting(file);
    let pkg2;
    try {
      pkg2 = JSON.parse(file);
      if (typeof pkg2 !== "object" || pkg2 === null) {
        throw new Error();
      }
    } catch {
      ctx.logger.error(
        `Your ./package.json does not contain valid JSON. Please fix it and try again.`
      );
      process.exit(1);
    }
    try {
      if (opt.dependencies)
        pkg2.dependencies = await opt.dependencies(pkg2.dependencies || {});
      if (opt.devDependencies)
        pkg2.devDependencies = await opt.devDependencies(pkg2.devDependencies || {});
      if (opt.scripts)
        pkg2.scripts = await opt.scripts(pkg2.scripts || {});
    } catch (e) {
      return ctx;
    }
    await ctx.repo.nodeishFs.writeFile("./package.json", stringify2(pkg2));
    return ctx;
  };
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag2, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag2 + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag2;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$12) {
    if (!(type$12 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$12.loadKind && type$12.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$12.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$12) {
    if (!(type$12 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index2 = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max)
      return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index2 < max; index2++) {
    ch = data[index2];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value2 = data, sign = 1, ch;
  if (value2.indexOf("_") !== -1) {
    value2 = value2.replace(/_/g, "");
  }
  ch = value2[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value2 = value2.slice(1);
    ch = value2[0];
  }
  if (value2 === "0")
    return 0;
  if (ch === "0") {
    if (value2[1] === "b")
      return sign * parseInt(value2.slice(2), 2);
    if (value2[1] === "x")
      return sign * parseInt(value2.slice(2), 16);
    if (value2[1] === "o")
      return sign * parseInt(value2.slice(2), 8);
  }
  return sign * parseInt(value2, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value2, sign;
  value2 = data.replace(/_/g, "").toLowerCase();
  sign = value2[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value2[0]) >= 0) {
    value2 = value2.slice(1);
  }
  if (value2 === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value2 === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value2, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys = Object.keys(pair);
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? "" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator2(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var load = loader.load;
const GitHubActionStep = typebox.Type.Object({
  name: typebox.Type.Optional(typebox.Type.String()),
  id: typebox.Type.Optional(typebox.Type.String()),
  uses: typebox.Type.Optional(typebox.Type.String()),
  with: typebox.Type.Optional(typebox.Type.Record(typebox.Type.String(), typebox.Type.Any())),
  env: typebox.Type.Optional(typebox.Type.Record(typebox.Type.String(), typebox.Type.Any()))
});
const GitHubActionJob = typebox.Type.Object({
  name: typebox.Type.Optional(typebox.Type.String()),
  "runs-on": typebox.Type.String(),
  steps: typebox.Type.Array(GitHubActionStep)
});
const GitHubActionEvent = typebox.Type.Union([
  typebox.Type.Literal("pull_request_target"),
  typebox.Type.Array(typebox.Type.Literal("pull_request_target")),
  typebox.Type.Object({
    pull_request_target: typebox.Type.Optional(typebox.Type.Any())
    // Define other events as necessary, ensuring correct property names
  })
]);
const GitHubActionsWorkflow = typebox.Type.Object({
  name: typebox.Type.String(),
  on: GitHubActionEvent,
  jobs: typebox.Type.Record(typebox.Type.String(), GitHubActionJob)
  // Use Record to define an object with string keys and GitHubActionJob values
});
async function shouldRecommend(args) {
  try {
    const gitConfigPath = await relativePathStringFromRoot(args.fs) + ".git/config";
    await args.fs.stat(gitConfigPath);
    const configData = await args.fs.readFile(gitConfigPath, { encoding: "utf-8" });
    const match = configData.match(/url = (.+)/);
    const remoteOriginUrl = match ? match[1] : void 0;
    const isNinjaAdopted = await isAdopted({ fs: args.fs });
    if (remoteOriginUrl && remoteOriginUrl.includes("github.com") && !isNinjaAdopted) {
      return true;
    } else {
      return false;
    }
  } catch (error) {
    return false;
  }
}
async function isAdopted(args) {
  async function searchWorkflowFiles(directoryPath, depth = 0) {
    if (depth > 3) {
      return false;
    }
    try {
      await args.fs.stat(directoryPath);
    } catch (error) {
      return false;
    }
    const items = await args.fs.readdir(directoryPath);
    for (const item of items) {
      const itemPath = `${directoryPath}/${item}`;
      const stats = await args.fs.stat(itemPath);
      if (stats.isDirectory()) {
        if (await searchWorkflowFiles(itemPath, depth + 1)) {
          return true;
        }
      } else if (item.endsWith(".yml") || item.endsWith(".yaml")) {
        const fileContents = await args.fs.readFile(itemPath, { encoding: "utf-8" });
        const workflow = load(fileContents);
        if (value.Value.Check(GitHubActionsWorkflow, workflow) && workflow && workflow.jobs) {
          for (const jobKey in workflow.jobs) {
            const job = workflow.jobs[jobKey];
            if (job && job.steps) {
              for (const step of job.steps) {
                if (step.uses && step.uses.includes("opral/ninja-i18n-action")) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  return await searchWorkflowFiles(await relativePathStringFromRoot(args.fs) + ".github/workflows");
}
async function add(args) {
  const workflowDirPath = await relativePathStringFromRoot(args.fs) + ".github/workflows";
  const workflowFilePath = `${workflowDirPath}/ninja_i18n.yml`;
  const ninjaI18nWorkflowYaml = `
name: Ninja i18n action

on: pull_request_target

# explicitly configure permissions, in case your GITHUB_TOKEN workflow permissions are set to read-only in repository settings
permissions:
  pull-requests: write # Necessary to comment on PRs
  issues: read         # Necessary to read issue comments
  contents: read       # Necessary to access the repo content

jobs:
  ninja-i18n:
    name: Ninja i18n - GitHub Lint Action
    runs-on: ubuntu-latest

    steps:
      - name: Run Ninja i18n
        # @main ensures that the latest version of the action is used
        uses: opral/ninja-i18n-action@main
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
    `;
  let workflowDirExists = false;
  try {
    await args.fs.stat(workflowDirPath);
  } catch (error) {
    workflowDirExists = false;
  }
  if (!workflowDirExists) {
    try {
      await args.fs.mkdir(workflowDirPath, { recursive: true });
    } catch (error) {
      console.error("Failed to create the workflow directory", error);
      throw error;
    }
  }
  await args.fs.writeFile(workflowFilePath, ninjaI18nWorkflowYaml);
}
async function relativePathStringFromRoot(fs) {
  const repoRoot = await findRepoRoot({
    nodeishFs: fs,
    path: process.cwd()
  });
  const repoRootPath = (repoRoot == null ? void 0 : repoRoot.replace("file://", "")) ?? "";
  const currentWorkingDirectory = process.cwd();
  const directoriesAboveRepoRootLength = currentWorkingDirectory.replace(repoRootPath, "").split("/").length - 1;
  return "../".repeat(directoriesAboveRepoRootLength);
}
const maybeAddNinja = async (ctx) => {
  if (await shouldRecommend({ fs: ctx.repo.nodeishFs })) {
    const response = await prompt(
      "Do you want to add the  Ninja Github Action for linting translations in CI?\n\nhttps://inlang.com/m/3gk8n4n4/app-inlang-ninjaI18nAction",
      {
        type: "confirm",
        initial: true
      }
    );
    if (response !== true)
      return ctx;
    try {
      await add({ fs: ctx.repo.nodeishFs });
      telemetry.capture({ event: "PARAGLIDE JS init added Ninja" });
      ctx.logger.success("Added the  Ninja Github Action for linting translations");
    } catch (error) {
      ctx.logger.error("Failed to add the  Ninja Github Action. Please open an issue");
    }
  }
  return ctx;
};
const steps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkForUncommittedChanges,
  initializeInlangProject,
  maybeAddNinja,
  maybeAddSherlock,
  maybeChangeTsConfig,
  maybeChangeTsConfigAllowJs,
  maybeChangeTsConfigModuleResolution,
  promptForOutdir,
  runCompiler,
  updatePackageJson
}, Symbol.toStringTag, { value: "Module" }));
const initCommand = new Command().name("init").summary("Initializes inlang Paraglide-JS.").action(async () => {
  const repoRoot = await findRepoRoot({
    nodeishFs: nodeFsPromises,
    path: process.cwd()
  });
  const repo = await openRepository(repoRoot ?? "file://" + process.cwd(), {
    nodeishFs: nodeFsPromises
  });
  const logger = new Logger({ silent: false, prefix: false });
  logger.box("Welcome to inlang Paraglide-JS ");
  telemetry.capture({ event: "PARAGLIDE-JS init started" });
  const ctx = {
    logger,
    repo,
    repoRoot: (repoRoot == null ? void 0 : repoRoot.replace("file://", "")) ?? process.cwd(),
    appId: "library.inlang.paraglideJs"
  };
  const ctx1 = await checkForUncommittedChanges(ctx);
  const ctx2 = await enforcePackageJsonExists(ctx1);
  const ctx3 = await initializeInlangProject(ctx2);
  const ctx4 = await promptForOutdir(ctx3);
  telemetry.capture({ event: "PARAGLIDE-JS init project initialized" });
  const ctx5 = await addParaglideJsToDevDependencies(ctx4);
  telemetry.capture({ event: "PARAGLIDE-JS init added to devDependencies" });
  const ctx6 = await addCompileStepToPackageJSON(ctx5);
  telemetry.capture({ event: "PARAGLIDE-JS init added compile commands" });
  const ctx7 = await maybeChangeTsConfig(ctx6);
  const ctx8 = await maybeAddSherlock(ctx7);
  const ctx9 = await maybeAddNinja(ctx8);
  try {
    await runCompiler(ctx9);
    ctx.logger.success("Run paraglide compiler");
  } catch (e) {
    ctx.logger.warn(
      "Failed to compile project automatically. You will need to run the compiler manually"
    );
  }
  telemetry.capture({ event: "PARAGLIDE-JS init finished" });
  const absoluteSettingsPath = nodePath.resolve(ctx9.projectPath, "settings.json");
  const relativeSettingsFilePath = absoluteSettingsPath.replace(process.cwd(), ".");
  const successMessage = dedent`inlang Paraglide-JS has been set up sucessfully.
			
			1. Run your install command (npm i, yarn install, etc)
			2. Register all your languages in ${relativeSettingsFilePath}
			3. Run the build script (npm run build, or similar.)
			4. Done :) Happy paragliding 
			
			For questions and feedback, visit 
			https://github.com/opral/monorepo/discussions`;
  ctx.logger.box(successMessage);
});
const addParaglideJsToDevDependencies = async (ctx) => {
  const ctx1 = await updatePackageJson({
    devDependencies: async (devDeps) => ({
      ...devDeps,
      "@inlang/paraglide-js": "1.11.2"
    })
  })(ctx);
  ctx.logger.success("Added @inlang/paraglide-js to the devDependencies in package.json.");
  return ctx1;
};
const enforcePackageJsonExists = async (ctx) => {
  const packageJsonPath = await findPackageJson(ctx.repo.nodeishFs, process.cwd());
  if (!packageJsonPath) {
    ctx.logger.warn(
      "No package.json found in the current working directory. Please change the working directory to the directory with a package.json file."
    );
    return process.exit(0);
  }
  return { ...ctx, packageJsonPath };
};
const addCompileStepToPackageJSON = async (ctx) => {
  const projectPath = "./" + nodePath.relative(process.cwd(), ctx.projectPath);
  const outdir = "./" + nodePath.relative(process.cwd(), ctx.outdir);
  let shouldExit = false;
  ctx = await updatePackageJson({
    scripts: async (scripts) => {
      var _a2;
      if (!((_a2 = scripts.postinstall) == null ? void 0 : _a2.includes("paraglide-js compile"))) {
        scripts.postinstall = `paraglide-js compile --project ${projectPath} --outdir ${outdir}` + (scripts.postinstall ? " && " + scripts.postinstall : "");
      }
      if (scripts.build === void 0) {
        scripts.build = `paraglide-js compile --project ${projectPath} --outdir ${outdir}`;
      } else if (scripts.build.includes("paraglide-js compile") === false) {
        scripts.build = `paraglide-js compile --project ${projectPath} --outdir ${outdir} && ${scripts.build}`;
      } else {
        ctx.logger.warn(`The "build" script in the \`package.json\` already contains a "paraglide-js compile" command.
				
				Please add the following command to your build script manually:
				
				\`paraglide-js compile --project ${ctx.projectPath}`);
        const response = await consola.prompt(
          "Have you added the compile command to your build script?",
          {
            type: "confirm",
            initial: false
          }
        );
        if (response === false) {
          ctx.logger.log("Please add the paraglide-js compile to your build script and try again.");
          shouldExit = true;
          throw new Error("Skip write");
        } else {
          throw new Error("Skip write");
        }
      }
      ctx.logger.success(
        "Successfully added the compile command to the build step in package.json."
      );
      return scripts;
    }
  })(ctx);
  if (shouldExit)
    process.exit(1);
  return ctx;
};
const cli = new Command().name("paraglide-js").addCommand(compileCommand).addCommand(initCommand).showHelpAfterError().version("1.11.2");
export {
  defaults as Defaults,
  GitPackIndex as G,
  steps as Steps,
  utils as Utils,
  GitTree as a,
  GitCommit as b,
  collect$1 as c,
  cli,
  index$1 as i
};
